{"version":3,"file":"index.js","sources":["../../src/main/workspace/index.ts","../../src/main/git/index.ts","../../src/main/diff/index.ts","../../src/main/events/index.ts","../../src/main/watchers/index.ts","../../src/main/thread/index.ts","../../src/main/composer/registry.ts","../../src/main/composer/parser.ts","../../src/main/composer/mentions.ts","../../src/main/composer/index.ts","../../src/main/providers/claude.ts","../../src/main/providers/index.ts","../../src/main/ipc/index.ts","../../src/main/index.ts"],"sourcesContent":["/**\n * @fileoverview Workspace management module for handling user workspaces.\n * Provides functionality for creating, listing, removing, and discovering workspaces.\n * Stores workspace state in a JSON file in the user data directory.\n * @module main/workspace\n */\n\nimport { app, BrowserWindow, dialog, type OpenDialogOptions } from 'electron';\nimport type { Dirent } from 'node:fs';\nimport fs from 'node:fs/promises';\nimport path from 'node:path';\nimport { randomUUID } from 'node:crypto';\n\n/**\n * Represents a workspace entry stored in the application.\n */\nexport type WorkspaceEntry = {\n  id: string;\n  name: string;\n  path: string;\n  lastOpenedAt: string;\n};\n\n/**\n * Represents a workspace discovered during filesystem scanning.\n */\nexport type DiscoveredWorkspace = {\n  name: string;\n  path: string;\n  lastModifiedAt: string;\n};\n\n/**\n * Internal state structure for workspace management.\n */\ntype WorkspaceState = {\n  currentId: string | null;\n  entries: WorkspaceEntry[];\n  ignoredPaths: string[];\n};\n\n/** Current workspace state held in memory */\nconst state: WorkspaceState = {\n  currentId: null,\n  entries: [],\n  ignoredPaths: []\n};\n\n/** Promise that resolves when state is loaded */\nlet ready: Promise<void> = Promise.resolve();\n\n/**\n * Gets the file path for storing workspace state.\n * @returns {string} Path to workspaces.json in user data directory\n */\nfunction getStorePath() {\n  return path.join(app.getPath('userData'), 'workspaces.json');\n}\n\n/**\n * Loads workspace state from the persistent storage file.\n * Initializes empty state if the file doesn't exist or is invalid.\n * @returns {Promise<void>}\n */\nasync function loadState() {\n  try {\n    const data = await fs.readFile(getStorePath(), 'utf-8');\n    const parsed = JSON.parse(data) as WorkspaceState;\n    state.currentId = parsed.currentId ?? null;\n    state.entries = Array.isArray(parsed.entries) ? parsed.entries : [];\n    state.ignoredPaths = Array.isArray(parsed.ignoredPaths) ? parsed.ignoredPaths : [];\n  } catch {\n    state.currentId = null;\n    state.entries = [];\n    state.ignoredPaths = [];\n  }\n}\n\n/**\n * Saves the current workspace state to the persistent storage file.\n * @returns {Promise<void>}\n */\nasync function saveState() {\n  const payload: WorkspaceState = {\n    currentId: state.currentId,\n    entries: state.entries,\n    ignoredPaths: state.ignoredPaths\n  };\n  await fs.writeFile(getStorePath(), JSON.stringify(payload, null, 2), 'utf-8');\n}\n\n/**\n * Finds a workspace entry by its directory path.\n * @param {string} dirPath - The directory path to search for\n * @returns {WorkspaceEntry | null} The matching workspace entry or null\n */\nfunction findEntryByPath(dirPath: string) {\n  return state.entries.find((entry) => entry.path === dirPath) ?? null;\n}\n\n/**\n * Gets a workspace entry by its unique identifier.\n * @param {string | null} id - The workspace ID to search for\n * @returns {WorkspaceEntry | null} The matching workspace entry or null\n */\nfunction getEntryById(id: string | null) {\n  if (!id) return null;\n  return state.entries.find((entry) => entry.id === id) ?? null;\n}\n\n/**\n * Ensures the workspace state has been loaded before operations.\n * @returns {Promise<void>}\n */\nasync function ensureReady() {\n  await ready;\n}\n\n/**\n * Initializes the workspace module by loading saved state.\n */\nexport function initWorkspace() {\n  ready = loadState();\n}\n\n/**\n * Lists all workspaces sorted by last opened date (most recent first).\n * @returns {Promise<WorkspaceEntry[]>} Array of workspace entries\n */\nexport async function listWorkspaces() {\n  await ensureReady();\n  return [...state.entries].sort((a, b) => b.lastOpenedAt.localeCompare(a.lastOpenedAt));\n}\n\n/**\n * Lists the most recently opened workspaces.\n * @param {number} [limit=5] - Maximum number of workspaces to return\n * @returns {Promise<WorkspaceEntry[]>} Array of recent workspace entries\n */\nexport async function listRecentWorkspaces(limit = 5) {\n  const list = await listWorkspaces();\n  return list.slice(0, limit);\n}\n\n/**\n * Gets the currently active workspace.\n * @returns {Promise<WorkspaceEntry | null>} The current workspace entry or null\n */\nexport async function getCurrentWorkspace() {\n  await ensureReady();\n  return getEntryById(state.currentId);\n}\n\n/**\n * Sets the current workspace by ID and updates its last opened timestamp.\n * @param {string} id - The workspace ID to set as current\n * @returns {Promise<WorkspaceEntry | null>} The updated workspace entry or null if not found\n */\nexport async function setCurrentWorkspace(id: string) {\n  await ensureReady();\n  const entry = getEntryById(id);\n  if (!entry) return null;\n  state.currentId = entry.id;\n  entry.lastOpenedAt = new Date().toISOString();\n  await saveState();\n  return entry;\n}\n\n/**\n * Adds a new workspace or updates an existing one if the path already exists.\n * Removes the path from ignored list if present.\n * @param {string} dirPath - The directory path to add as a workspace\n * @returns {Promise<WorkspaceEntry>} The created or updated workspace entry\n */\nexport async function addWorkspace(dirPath: string) {\n  await ensureReady();\n  if (state.ignoredPaths.includes(dirPath)) {\n    state.ignoredPaths = state.ignoredPaths.filter((path) => path !== dirPath);\n  }\n  const existing = findEntryByPath(dirPath);\n  if (existing) {\n    existing.lastOpenedAt = new Date().toISOString();\n    state.currentId = existing.id;\n    await saveState();\n    return existing;\n  }\n\n  const entry: WorkspaceEntry = {\n    id: randomUUID(),\n    name: path.basename(dirPath),\n    path: dirPath,\n    lastOpenedAt: new Date().toISOString()\n  };\n\n  state.entries.push(entry);\n  state.currentId = entry.id;\n  await saveState();\n  return entry;\n}\n\n/**\n * Renames a workspace.\n * @param {string} id - The workspace ID to rename\n * @param {string} name - The new name for the workspace\n * @returns {Promise<WorkspaceEntry | null>} The updated workspace entry or null if not found\n */\nexport async function renameWorkspace(id: string, name: string) {\n  await ensureReady();\n  const entry = getEntryById(id);\n  if (!entry) return null;\n\n  const nextName = name.trim();\n  if (!nextName) return null;\n\n  entry.name = nextName;\n  await saveState();\n  return entry;\n}\n\n/**\n * Removes a workspace by ID.\n * If the removed workspace was current, sets the first available workspace as current.\n * @param {string} id - The workspace ID to remove\n * @returns {Promise<{removed: boolean, current: WorkspaceEntry | null}>} Result with removal status and new current workspace\n */\nexport async function removeWorkspace(id: string) {\n  await ensureReady();\n  const index = state.entries.findIndex((entry) => entry.id === id);\n  if (index === -1) return { removed: false, current: getEntryById(state.currentId) };\n\n  const [removed] = state.entries.splice(index, 1);\n  if (state.currentId === removed.id) {\n    state.currentId = state.entries[0]?.id ?? null;\n  }\n  await saveState();\n  return { removed: true, current: getEntryById(state.currentId) };\n}\n\n/**\n * Lists all ignored workspace paths.\n * @returns {Promise<string[]>} Array of ignored directory paths\n */\nexport async function listIgnoredWorkspaces() {\n  await ensureReady();\n  return [...state.ignoredPaths];\n}\n\n/**\n * Adds a path to the ignored workspaces list.\n * @param {string} pathToIgnore - The directory path to ignore\n * @returns {Promise<string[]>} Updated array of ignored paths\n */\nexport async function ignoreWorkspacePath(pathToIgnore: string) {\n  await ensureReady();\n  if (!state.ignoredPaths.includes(pathToIgnore)) {\n    state.ignoredPaths.push(pathToIgnore);\n    await saveState();\n  }\n  return [...state.ignoredPaths];\n}\n\n/**\n * Removes a path from the ignored workspaces list.\n * @param {string} pathToRestore - The directory path to restore\n * @returns {Promise<string[]>} Updated array of ignored paths\n */\nexport async function restoreIgnoredWorkspace(pathToRestore: string) {\n  await ensureReady();\n  state.ignoredPaths = state.ignoredPaths.filter((value) => value !== pathToRestore);\n  await saveState();\n  return [...state.ignoredPaths];\n}\n\n/** Default directories to search for git repositories */\nconst DEFAULT_DISCOVERY_DIRS = ['Desktop', 'Documents', 'Projects', 'Code', 'workspace', 'dev'];\n/** Directories to ignore during workspace discovery */\nconst IGNORE_DIRS = new Set(['node_modules', '.git', 'dist', 'build', '.next', 'out', 'coverage']);\n\n/**\n * Discovers git repositories in the filesystem.\n * Searches through specified root directories or default locations.\n * @param {Object} [options] - Discovery options\n * @param {string[]} [options.roots] - Root directories to search in\n * @param {number} [options.maxDepth=4] - Maximum directory depth to traverse\n * @param {number} [options.limit=50] - Maximum number of repositories to return\n * @param {boolean} [options.includeIgnored=false] - Whether to include ignored paths\n * @returns {Promise<DiscoveredWorkspace[]>} Array of discovered workspaces\n */\nexport async function discoverGitWorkspaces(options?: {\n  roots?: string[];\n  maxDepth?: number;\n  limit?: number;\n  includeIgnored?: boolean;\n}): Promise<DiscoveredWorkspace[]> {\n  const home = app.getPath('home');\n  const roots = options?.roots ??\n    (await Promise.all(\n      DEFAULT_DISCOVERY_DIRS.map(async (dir) => {\n        const full = path.join(home, dir);\n        try {\n          const stat = await fs.stat(full);\n          return stat.isDirectory() ? full : null;\n        } catch {\n          return null;\n        }\n      })\n    )).filter((value): value is string => Boolean(value));\n\n  const maxDepth = options?.maxDepth ?? 4;\n  const limit = options?.limit ?? 50;\n  const discovered: DiscoveredWorkspace[] = [];\n  const visited = new Set<string>();\n\n  const isGitRepo = async (dirPath: string) => {\n    try {\n      const stat = await fs.stat(path.join(dirPath, '.git'));\n      return stat.isDirectory();\n    } catch {\n      return false;\n    }\n  };\n\n  const walk = async (dirPath: string, depth: number) => {\n    if (depth < 0 || discovered.length >= limit) return;\n\n    let realPath = dirPath;\n    try {\n      realPath = await fs.realpath(dirPath);\n    } catch {\n      return;\n    }\n\n    if (visited.has(realPath)) return;\n    visited.add(realPath);\n\n    if (await isGitRepo(dirPath)) {\n      try {\n        const stat = await fs.stat(dirPath);\n        discovered.push({\n          name: path.basename(dirPath),\n          path: dirPath,\n          lastModifiedAt: stat.mtime.toISOString()\n        });\n      } catch {\n        discovered.push({\n          name: path.basename(dirPath),\n          path: dirPath,\n          lastModifiedAt: new Date().toISOString()\n        });\n      }\n      return;\n    }\n\n    let entries: Dirent[] = [];\n    try {\n      entries = await fs.readdir(dirPath, { withFileTypes: true });\n    } catch {\n      return;\n    }\n\n    await Promise.all(\n      entries.map(async (entry) => {\n        if (!entry.isDirectory() || entry.isSymbolicLink()) return;\n        if (IGNORE_DIRS.has(entry.name)) return;\n        if (entry.name.startsWith('.')) return;\n        await walk(path.join(dirPath, entry.name), depth - 1);\n      })\n    );\n  };\n\n  await Promise.all(roots.map((root) => walk(root, maxDepth)));\n\n  const filtered = options?.includeIgnored\n    ? discovered\n    : discovered.filter((entry) => !state.ignoredPaths.includes(entry.path));\n\n  return filtered\n    .sort((a, b) => b.lastModifiedAt.localeCompare(a.lastModifiedAt))\n    .slice(0, limit);\n}\n\n/**\n * Opens a native directory picker dialog to select a workspace.\n * @returns {Promise<WorkspaceEntry | null>} The selected workspace entry or null if canceled\n */\nexport async function pickWorkspace() {\n  await ensureReady();\n  const window = BrowserWindow.getFocusedWindow();\n  const options: OpenDialogOptions = {\n    properties: ['openDirectory'],\n    title: 'Select a workspace folder'\n  };\n\n  const result = window\n    ? await dialog.showOpenDialog(window, options)\n    : await dialog.showOpenDialog(options);\n\n  if (result.canceled || result.filePaths.length === 0) {\n    return null;\n  }\n\n  return addWorkspace(result.filePaths[0]);\n}\n\n/**\n * Gets the directory path of the current workspace.\n * @returns {Promise<string | null>} The current workspace path or null\n */\nexport async function getCurrentWorkspacePath() {\n  const entry = await getCurrentWorkspace();\n  return entry?.path ?? null;\n}\n","/**\n * @fileoverview Git integration module for the main process.\n * Provides functions to interact with git repositories including\n * getting status, summaries, and file change information.\n * @module main/git\n */\n\nimport { execFile } from 'node:child_process';\nimport { promisify } from 'node:util';\nimport { getCurrentWorkspacePath } from '../workspace';\n\n/** Promisified version of execFile for async git commands */\nconst execFileAsync = promisify(execFile);\n\n/**\n * Summary information about a git repository.\n */\nexport type GitSummary = {\n  available: boolean;\n  reason?: string;\n  root?: string;\n  branch?: string;\n  status?: string;\n  lastCommit?: string;\n};\n\n/**\n * Status information for a single file in the git repository.\n */\nexport type GitFileStatus = {\n  path: string;\n  staged: boolean;\n  unstaged: boolean;\n  status: string;\n};\n\n/**\n * Executes a git command in the specified directory.\n * @param {string[]} args - Arguments to pass to the git command\n * @param {string} cwd - Working directory for the git command\n * @returns {Promise<{ok: boolean, stdout: string, error?: string}>} Result of the git command\n */\nasync function runGit(args: string[], cwd: string) {\n  try {\n    const { stdout } = await execFileAsync('git', args, { cwd });\n    return { ok: true, stdout: stdout.trim() };\n  } catch (error: any) {\n    return {\n      ok: false,\n      stdout: '',\n      error: error?.stderr?.toString?.() ?? error?.message ?? 'git command failed'\n    };\n  }\n}\n\n/**\n * Initializes the git module.\n * Placeholder for future git module bootstrapping.\n */\nexport function initGit() {\n  // Placeholder for future git module bootstrapping.\n}\n\n/**\n * Gets a summary of the current git repository state.\n * Includes branch name, status, root path, and last commit information.\n * @returns {Promise<GitSummary>} Git repository summary\n */\nexport async function getGitSummary(): Promise<GitSummary> {\n  const cwd = await getCurrentWorkspacePath();\n  if (!cwd) {\n    return { available: false, reason: 'No workspace selected' };\n  }\n\n  const repoCheck = await runGit(['rev-parse', '--is-inside-work-tree'], cwd);\n  if (!repoCheck.ok || repoCheck.stdout !== 'true') {\n    return { available: false, reason: 'Not a git repository' };\n  }\n\n  const root = await runGit(['rev-parse', '--show-toplevel'], cwd);\n  const branch = await runGit(['rev-parse', '--abbrev-ref', 'HEAD'], cwd);\n  const status = await runGit(['status', '-sb'], cwd);\n  const lastCommit = await runGit(\n    ['log', '-1', '--pretty=format:%h %s (%an, %ad)', '--date=short'],\n    cwd\n  );\n\n  return {\n    available: true,\n    root: root.ok ? root.stdout : undefined,\n    branch: branch.ok ? branch.stdout : undefined,\n    status: status.ok ? status.stdout : undefined,\n    lastCommit: lastCommit.ok ? lastCommit.stdout : undefined\n  };\n}\n\n/**\n * Gets the git status for the current workspace.\n * @returns {Promise<GitSummary>} Git status information\n */\nexport async function getGitStatus() {\n  const summary = await getGitSummary();\n  if (!summary.available) {\n    return summary;\n  }\n\n  return { ...summary, status: summary.status ?? '' };\n}\n\n/**\n * Gets the status of all changed files in the current workspace.\n * Parses git porcelain output to determine staged/unstaged state.\n * @returns {Promise<{available: boolean, reason?: string, files: GitFileStatus[]}>} File status information\n */\nexport async function getGitFileStatuses() {\n  const cwd = await getCurrentWorkspacePath();\n  if (!cwd) {\n    return { available: false, reason: 'No workspace selected', files: [] as GitFileStatus[] };\n  }\n\n  const repoCheck = await runGit(['rev-parse', '--is-inside-work-tree'], cwd);\n  if (!repoCheck.ok || repoCheck.stdout !== 'true') {\n    return { available: false, reason: 'Not a git repository', files: [] as GitFileStatus[] };\n  }\n\n  const status = await runGit(['status', '--porcelain=v1'], cwd);\n  if (!status.ok) {\n    return { available: false, reason: status.error ?? 'git status failed', files: [] as GitFileStatus[] };\n  }\n\n  const files = status.stdout\n    .split('\\n')\n    .map((line) => line.trimEnd())\n    .filter(Boolean)\n    .map((line) => {\n      const statusCode = line.slice(0, 2);\n      const rawPath = line.slice(3).trim();\n      const pathPart = rawPath.includes(' -> ')\n        ? rawPath.split(' -> ').slice(-1)[0]\n        : rawPath;\n\n      return {\n        path: pathPart,\n        status: statusCode,\n        staged: statusCode[0] !== ' ',\n        unstaged: statusCode[1] !== ' '\n      };\n    });\n\n  return { available: true, files };\n}\n","/**\n * @fileoverview Git diff module for the main process.\n * Provides functions to retrieve staged and unstaged diffs\n * for the current workspace.\n * @module main/diff\n */\n\nimport { execFile } from 'node:child_process';\nimport { promisify } from 'node:util';\nimport { getCurrentWorkspacePath } from '../workspace';\n\n/** Promisified version of execFile for async git commands */\nconst execFileAsync = promisify(execFile);\n/** Maximum characters to include in diff output before truncation */\nconst MAX_CHARS = 20000;\n\n/**\n * Result of a diff operation.\n */\nexport type DiffResult = {\n  available: boolean;\n  reason?: string;\n  unstaged?: string;\n  staged?: string;\n};\n\n/**\n * Truncates text to the maximum allowed characters.\n * @param {string} text - The text to truncate\n * @returns {string} The truncated text with a message if truncated\n */\nfunction truncate(text: string) {\n  if (text.length <= MAX_CHARS) return text;\n  return `${text.slice(0, MAX_CHARS)}\\n...diff truncated (${text.length - MAX_CHARS} more chars)`;\n}\n\n/**\n * Runs a git diff command with the specified arguments.\n * @param {string[]} args - Arguments to pass to git diff\n * @param {string} cwd - Working directory for the command\n * @returns {Promise<string>} The diff output or error message\n */\nasync function runGitDiff(args: string[], cwd: string) {\n  try {\n    const { stdout } = await execFileAsync('git', args, { cwd });\n    const content = stdout.trim();\n    return content.length === 0 ? '(no changes)' : truncate(content);\n  } catch (error: any) {\n    return `git diff failed: ${error?.stderr?.toString?.() ?? error?.message ?? 'unknown error'}`;\n  }\n}\n\n/**\n * Initializes the diff module.\n * Placeholder for future diff module bootstrapping.\n */\nexport function initDiff() {\n  // Placeholder for future diff module bootstrapping.\n}\n\n/**\n * Checks if the given directory is inside a git repository.\n * @param {string} cwd - Directory path to check\n * @returns {Promise<boolean>} True if inside a git repository\n */\nasync function ensureRepo(cwd: string) {\n  try {\n    await execFileAsync('git', ['rev-parse', '--is-inside-work-tree'], { cwd });\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Gets the diff for all files in the current workspace.\n * Returns both staged and unstaged changes.\n * @returns {Promise<DiffResult>} The diff result with staged and unstaged changes\n */\nexport async function getDiff(): Promise<DiffResult> {\n  const cwd = await getCurrentWorkspacePath();\n  if (!cwd) {\n    return { available: false, reason: 'No workspace selected' };\n  }\n\n  const isRepo = await ensureRepo(cwd);\n  if (!isRepo) {\n    return { available: false, reason: 'Not a git repository' };\n  }\n\n  const unstaged = await runGitDiff(['diff'], cwd);\n  const staged = await runGitDiff(['diff', '--staged'], cwd);\n\n  return {\n    available: true,\n    unstaged,\n    staged\n  };\n}\n\n/**\n * Gets the diff for a specific file in the current workspace.\n * Returns both staged and unstaged changes for the file.\n * @param {string} filePath - Path to the file relative to the repository root\n * @returns {Promise<DiffResult>} The diff result for the specified file\n */\nexport async function getDiffForFile(filePath: string): Promise<DiffResult> {\n  const cwd = await getCurrentWorkspacePath();\n  if (!cwd) {\n    return { available: false, reason: 'No workspace selected' };\n  }\n\n  const isRepo = await ensureRepo(cwd);\n  if (!isRepo) {\n    return { available: false, reason: 'Not a git repository' };\n  }\n\n  const unstaged = await runGitDiff(['diff', '--', filePath], cwd);\n  const staged = await runGitDiff(['diff', '--staged', '--', filePath], cwd);\n\n  return {\n    available: true,\n    unstaged,\n    staged\n  };\n}\n","/**\n * @fileoverview Application event bus for internal event communication.\n * Provides a centralized event emitter for broadcasting app state changes.\n * @module main/events\n */\n\nimport { EventEmitter } from 'node:events';\n\n/**\n * Application event types that can be emitted and listened to.\n */\nexport type AppEvent = 'workspace:changed' | 'git:changed' | 'diff:changed';\n\n/**\n * Event listener callback function type.\n */\ntype Listener = () => void;\n\n/** Internal event emitter instance */\nconst emitter = new EventEmitter();\n\n/**\n * Registers a listener for an application event.\n * @param {AppEvent} event - The event type to listen for\n * @param {Listener} listener - Callback function to invoke when event fires\n * @returns {() => void} Unsubscribe function to remove the listener\n */\nexport function onAppEvent(event: AppEvent, listener: Listener) {\n  emitter.on(event, listener);\n  return () => emitter.off(event, listener);\n}\n\n/**\n * Emits an application event to all registered listeners.\n * @param {AppEvent} event - The event type to emit\n */\nexport function emitAppEvent(event: AppEvent) {\n  emitter.emit(event);\n}\n","/**\n * @fileoverview File system watchers for detecting workspace and git changes.\n * Uses chokidar to watch for file changes and emits debounced events.\n * @module main/watchers\n */\n\nimport chokidar, { type FSWatcher } from 'chokidar';\nimport path from 'node:path';\nimport { emitAppEvent } from '../events';\n\n/** File watcher for workspace files */\nlet fileWatcher: FSWatcher | null = null;\n/** Watcher for .git directory changes */\nlet gitWatcher: FSWatcher | null = null;\n/** Timer for debouncing event emissions */\nlet debounceTimer: NodeJS.Timeout | null = null;\n/** Pending events to emit after debounce */\nlet pending = {\n  workspace: false,\n  git: false,\n  diff: false\n};\n\n/**\n * Schedules events to be emitted after a debounce period.\n * Consolidates multiple rapid file changes into a single event emission.\n * @param {Partial<typeof pending>} events - Events to schedule for emission\n */\nfunction schedule(events: Partial<typeof pending>) {\n  pending = {\n    workspace: pending.workspace || Boolean(events.workspace),\n    git: pending.git || Boolean(events.git),\n    diff: pending.diff || Boolean(events.diff)\n  };\n\n  if (debounceTimer) clearTimeout(debounceTimer);\n  debounceTimer = setTimeout(() => {\n    if (pending.workspace) emitAppEvent('workspace:changed');\n    if (pending.git) emitAppEvent('git:changed');\n    if (pending.diff) emitAppEvent('diff:changed');\n\n    pending = { workspace: false, git: false, diff: false };\n    debounceTimer = null;\n  }, 250);\n}\n\n/**\n * Stops all active file system watchers.\n * @returns {Promise<void>}\n */\nexport async function stopWatchers() {\n  if (fileWatcher) {\n    await fileWatcher.close();\n    fileWatcher = null;\n  }\n  if (gitWatcher) {\n    await gitWatcher.close();\n    gitWatcher = null;\n  }\n}\n\n/**\n * Starts file system watchers for a workspace directory.\n * Watches for general file changes and git-specific changes separately.\n * @param {string} rootPath - Root directory path to watch\n * @returns {Promise<void>}\n */\nexport async function startWatchers(rootPath: string) {\n  await stopWatchers();\n\n  fileWatcher = chokidar.watch(rootPath, {\n    ignored: [\n      '**/node_modules/**',\n      '**/.git/**',\n      '**/dist/**',\n      '**/.next/**'\n    ],\n    ignoreInitial: true\n  });\n\n  fileWatcher.on('all', () => {\n    schedule({ workspace: true, git: true, diff: true });\n  });\n\n  gitWatcher = chokidar.watch(path.join(rootPath, '.git'), {\n    ignoreInitial: true,\n    depth: 5\n  });\n\n  gitWatcher.on('all', () => {\n    schedule({ git: true, diff: true });\n  });\n}\n","/**\n * @fileoverview Thread management module for the main process.\n * Provides functionality for creating, listing, renaming, and removing threads.\n * Stores thread state in a JSON file in the user data directory.\n * @module main/thread\n */\n\nimport { app } from 'electron';\nimport fs from 'node:fs/promises';\nimport path from 'node:path';\nimport { randomUUID } from 'node:crypto';\nimport type { Thread } from '../../shared/thread';\n\n/**\n * Internal store structure for thread management.\n */\ntype ThreadStore = {\n  threads: Thread[];\n};\n\n/** Current thread store held in memory */\nlet store: ThreadStore = { threads: [] };\n\n/**\n * Gets the file path for storing thread state.\n * @returns Path to threads.json in user data directory\n */\nfunction getStorePath() {\n  return path.join(app.getPath('userData'), 'threads.json');\n}\n\n/**\n * Loads thread state from the persistent storage file.\n * Initializes empty state if the file doesn't exist or is invalid.\n */\nasync function loadStore() {\n  try {\n    const data = await fs.readFile(getStorePath(), 'utf-8');\n    store = JSON.parse(data) as ThreadStore;\n  } catch {\n    store = { threads: [] };\n  }\n}\n\n/**\n * Saves the current thread state to the persistent storage file.\n */\nasync function saveStore() {\n  await fs.writeFile(getStorePath(), JSON.stringify(store, null, 2), 'utf-8');\n}\n\n/**\n * Initializes the thread module by loading saved state.\n */\nexport async function initThread() {\n  await loadStore();\n}\n\n/**\n * Lists all threads for a specific workspace.\n * @param workspaceId - The workspace ID to filter threads by\n * @returns Array of threads sorted by updatedAt descending\n */\nexport async function listThreads(workspaceId: string): Promise<Thread[]> {\n  return store.threads\n    .filter((t) => t.workspaceId === workspaceId)\n    .sort((a, b) => b.updatedAt - a.updatedAt);\n}\n\n/**\n * Creates a new thread in the specified workspace.\n * @param workspaceId - The workspace ID to create the thread in\n * @param title - The title of the new thread\n * @returns The newly created thread\n */\nexport async function createThread(workspaceId: string, title: string): Promise<Thread> {\n  const now = Date.now();\n  const thread: Thread = {\n    id: randomUUID(),\n    workspaceId,\n    title,\n    createdAt: now,\n    updatedAt: now\n  };\n  store.threads.push(thread);\n  await saveStore();\n  return thread;\n}\n\n/**\n * Renames an existing thread.\n * @param id - The thread ID to rename\n * @param title - The new title for the thread\n * @returns The updated thread or null if not found\n */\nexport async function renameThread(id: string, title: string): Promise<Thread | null> {\n  const thread = store.threads.find((t) => t.id === id);\n  if (!thread) return null;\n  thread.title = title;\n  thread.updatedAt = Date.now();\n  await saveStore();\n  return thread;\n}\n\n/**\n * Removes a thread by ID.\n * @param id - The thread ID to remove\n * @returns True if the thread was removed, false if not found\n */\nexport async function removeThread(id: string): Promise<boolean> {\n  const index = store.threads.findIndex((t) => t.id === id);\n  if (index === -1) return false;\n  store.threads.splice(index, 1);\n  await saveStore();\n  return true;\n}\n","/**\n * @fileoverview Slash command registry for composer command parsing and suggestions.\n * @module main/composer/registry\n */\n\nimport type { CommandDefinition, CommandName } from '../../shared/composer';\n\n/**\n * Canonical v1 slash command definitions.\n */\nconst commandRegistry: CommandDefinition[] = [\n  {\n    name: 'help',\n    syntax: '/help',\n    description: 'Show supported slash commands and usage.',\n    minArgs: 0,\n    maxArgs: 0,\n    allowFlags: false\n  },\n  {\n    name: 'clear',\n    syntax: '/clear',\n    description: 'Clear the current composer draft context.',\n    minArgs: 0,\n    maxArgs: 0,\n    allowFlags: false\n  },\n  {\n    name: 'model',\n    syntax: '/model <model>',\n    description: 'Override the Claude model for subsequent requests.',\n    minArgs: 1,\n    maxArgs: 1,\n    allowFlags: false\n  },\n  {\n    name: 'compact',\n    syntax: '/compact',\n    description: 'Request concise output style.',\n    minArgs: 0,\n    maxArgs: 0,\n    allowFlags: false\n  },\n  {\n    name: 'review',\n    syntax: '/review',\n    description: 'Switch to review-oriented response behavior.',\n    minArgs: 0,\n    maxArgs: 0,\n    allowFlags: false\n  },\n  {\n    name: 'plan',\n    syntax: '/plan',\n    description: 'Switch to planning-oriented response behavior.',\n    minArgs: 0,\n    maxArgs: 0,\n    allowFlags: false\n  },\n  {\n    name: 'status',\n    syntax: '/status',\n    description: 'Request current workspace status behavior.',\n    minArgs: 0,\n    maxArgs: 0,\n    allowFlags: false\n  },\n  {\n    name: 'diff',\n    syntax: '/diff [target]',\n    description: 'Request diff-focused behavior for optional target path.',\n    minArgs: 0,\n    maxArgs: 1,\n    allowFlags: false\n  },\n  {\n    name: 'test',\n    syntax: '/test [scope]',\n    description: 'Request test-focused behavior for optional scope.',\n    minArgs: 0,\n    maxArgs: 1,\n    allowFlags: false\n  }\n];\n\n/**\n * Fast command map by command name.\n */\nconst commandByName = new Map<CommandName, CommandDefinition>(\n  commandRegistry.map((definition) => [definition.name, definition])\n);\n\n/**\n * Lists all registered commands.\n */\nexport function listCommands(): CommandDefinition[] {\n  return commandRegistry;\n}\n\n/**\n * Gets a command definition by name.\n */\nexport function getCommand(name: string): CommandDefinition | null {\n  return commandByName.get(name as CommandName) ?? null;\n}\n","/**\n * @fileoverview Parser for slash commands and @mention tokens in composer input.\n * @module main/composer/parser\n */\n\nimport type { CommandInvocation, ComposerDiagnostic, ComposerToken } from '../../shared/composer';\nimport { getCommand } from './registry';\n\n/**\n * Unresolved mention query extracted from raw input.\n */\nexport type MentionQuery = {\n  raw: string;\n  query: string;\n  start: number;\n  end: number;\n};\n\n/**\n * Intermediate parse result before mention resolution.\n */\nexport type ComposerParseDraft = {\n  tokens: ComposerToken[];\n  command: CommandInvocation | null;\n  mentionQueries: MentionQuery[];\n  diagnostics: ComposerDiagnostic[];\n  normalizedPrompt: string;\n};\n\n/**\n * Parses quoted command arguments from input text.\n */\nfunction parseArgs(raw: string): string[] {\n  const args: string[] = [];\n  let current = '';\n  let quote: '\"' | '\\'' | null = null;\n\n  for (let i = 0; i < raw.length; i += 1) {\n    const ch = raw[i];\n\n    if (quote) {\n      if (ch === quote) {\n        quote = null;\n        continue;\n      }\n      current += ch;\n      continue;\n    }\n\n    if (ch === '\"' || ch === '\\'') {\n      quote = ch;\n      continue;\n    }\n\n    if (/\\s/.test(ch)) {\n      if (current) {\n        args.push(current);\n        current = '';\n      }\n      continue;\n    }\n\n    current += ch;\n  }\n\n  if (current) {\n    args.push(current);\n  }\n\n  return args;\n}\n\n/**\n * Adds a parser diagnostic.\n */\nfunction pushDiagnostic(\n  diagnostics: ComposerDiagnostic[],\n  code: ComposerDiagnostic['code'],\n  message: string,\n  start: number,\n  end: number\n) {\n  diagnostics.push({\n    code,\n    message,\n    severity: 'error',\n    blocking: true,\n    start,\n    end\n  });\n}\n\n/**\n * Returns true if current position is a safe mention boundary.\n */\nfunction isMentionBoundary(rawInput: string, atIndex: number): boolean {\n  const prev = rawInput[atIndex - 1];\n  if (!prev) return true;\n  return /\\s|[([{,]/.test(prev);\n}\n\n/**\n * Extracts unresolved @mentions from raw composer text.\n */\nfunction parseMentionQueries(rawInput: string): MentionQuery[] {\n  const mentionQueries: MentionQuery[] = [];\n  const mentionPattern = /@([A-Za-z0-9_./-]+)/g;\n\n  for (const match of rawInput.matchAll(mentionPattern)) {\n    const start = match.index ?? -1;\n    if (start < 0 || !isMentionBoundary(rawInput, start)) continue;\n    const raw = match[0];\n    const query = match[1];\n    mentionQueries.push({ raw, query, start, end: start + raw.length });\n  }\n\n  return mentionQueries;\n}\n\n/**\n * Creates lexical tokens from parsed command and mentions.\n */\nfunction buildTokens(rawInput: string, command: CommandInvocation | null, mentions: MentionQuery[]): ComposerToken[] {\n  const chunks: ComposerToken[] = [];\n  const special: ComposerToken[] = [];\n\n  if (command) {\n    special.push({\n      kind: 'command',\n      raw: command.raw,\n      start: command.start,\n      end: command.end\n    });\n  }\n\n  for (const mention of mentions) {\n    special.push({\n      kind: 'mention',\n      raw: mention.raw,\n      start: mention.start,\n      end: mention.end\n    });\n  }\n\n  special.sort((a, b) => a.start - b.start);\n\n  let cursor = 0;\n  for (const token of special) {\n    if (token.start > cursor) {\n      chunks.push({\n        kind: 'text',\n        raw: rawInput.slice(cursor, token.start),\n        start: cursor,\n        end: token.start\n      });\n    }\n    chunks.push(token);\n    cursor = token.end;\n  }\n\n  if (cursor < rawInput.length) {\n    chunks.push({\n      kind: 'text',\n      raw: rawInput.slice(cursor),\n      start: cursor,\n      end: rawInput.length\n    });\n  }\n\n  return chunks;\n}\n\n/**\n * Parses raw composer input into command and mention draft structures.\n */\nexport function parseComposerInput(rawInput: string): ComposerParseDraft {\n  const diagnostics: ComposerDiagnostic[] = [];\n  const mentionQueries = parseMentionQueries(rawInput);\n  let command: CommandInvocation | null = null;\n  const normalizedPrompt = rawInput.trim();\n\n  const firstNonWhitespace = rawInput.search(/\\S/);\n  if (firstNonWhitespace >= 0 && rawInput[firstNonWhitespace] === '/') {\n    const tail = rawInput.slice(firstNonWhitespace);\n    const spaceIndex = tail.search(/\\s/);\n    const commandToken = spaceIndex < 0 ? tail : tail.slice(0, spaceIndex);\n    const commandName = commandToken.slice(1).toLowerCase();\n    const argsRaw = spaceIndex < 0 ? '' : tail.slice(spaceIndex + 1).trim();\n    const args = parseArgs(argsRaw);\n    const def = getCommand(commandName);\n\n    if (!def) {\n      pushDiagnostic(\n        diagnostics,\n        'CMD_UNKNOWN',\n        `Unknown command \"/${commandName}\".`,\n        firstNonWhitespace,\n        firstNonWhitespace + commandToken.length\n      );\n    } else {\n      command = {\n        name: def.name,\n        args,\n        raw: commandToken,\n        start: firstNonWhitespace,\n        end: firstNonWhitespace + commandToken.length\n      };\n\n      if (!def.allowFlags && args.some((arg) => arg.startsWith('-'))) {\n        pushDiagnostic(\n          diagnostics,\n          'CMD_UNSUPPORTED_FLAG',\n          `Command \"/${def.name}\" does not support flags.`,\n          firstNonWhitespace,\n          rawInput.length\n        );\n      } else if (args.length < def.minArgs || args.length > def.maxArgs) {\n        pushDiagnostic(\n          diagnostics,\n          'CMD_INVALID_ARGS',\n          `Invalid arguments for \"/${def.name}\". Expected syntax: ${def.syntax}.`,\n          firstNonWhitespace,\n          rawInput.length\n        );\n      }\n    }\n  }\n\n  return {\n    tokens: buildTokens(rawInput, command, mentionQueries),\n    command,\n    mentionQueries,\n    diagnostics,\n    normalizedPrompt\n  };\n}\n","/**\n * @fileoverview Workspace mention indexing and resolution for composer @mentions.\n * @module main/composer/mentions\n */\n\nimport type { MentionRef, MentionSuggestion } from '../../shared/composer';\nimport fs from 'node:fs/promises';\nimport path from 'node:path';\nimport type { Dirent } from 'node:fs';\n\n/**\n * Indexed workspace files cache.\n */\ntype WorkspaceMentionCache = {\n  entries: MentionSuggestion[];\n  builtAt: number;\n};\n\n/**\n * In-memory index cache by workspace ID.\n */\nconst cache = new Map<string, WorkspaceMentionCache>();\n\n/**\n * Directories excluded from mention indexing.\n */\nconst ignoredDirectories = new Set(['.git', 'node_modules', 'dist', 'build', 'coverage', '.next', 'out']);\n\nconst MAX_INDEX_FILES = 8000;\nconst CACHE_TTL_MS = 10000;\n\n/**\n * Converts path separators to POSIX style for stable mention text.\n */\nfunction toPosixPath(value: string): string {\n  return value.split(path.sep).join('/');\n}\n\n/**\n * Returns true if candidate path resides inside the workspace root.\n */\nfunction isPathInsideWorkspace(workspaceRoot: string, candidatePath: string): boolean {\n  const relative = path.relative(workspaceRoot, candidatePath);\n  return relative === '' || (!relative.startsWith('..') && !path.isAbsolute(relative));\n}\n\n/**\n * Walks workspace files and builds mention suggestion entries.\n */\nasync function buildWorkspaceIndex(workspaceId: string, workspacePath: string): Promise<MentionSuggestion[]> {\n  const entries: MentionSuggestion[] = [];\n  const stack: string[] = [workspacePath];\n\n  while (stack.length > 0 && entries.length < MAX_INDEX_FILES) {\n    const current = stack.pop();\n    if (!current) continue;\n\n    let children: Dirent[] = [];\n    try {\n      children = await fs.readdir(current, { withFileTypes: true });\n    } catch {\n      continue;\n    }\n\n    for (const child of children) {\n      if (child.name.startsWith('.')) continue;\n      const absolutePath = path.join(current, child.name);\n\n      if (child.isDirectory()) {\n        if (ignoredDirectories.has(child.name)) continue;\n        stack.push(absolutePath);\n        continue;\n      }\n\n      if (!child.isFile()) continue;\n\n      const relativePath = toPosixPath(path.relative(workspacePath, absolutePath));\n      entries.push({\n        kind: 'mention',\n        id: `${workspaceId}:${relativePath}`,\n        display: relativePath,\n        value: relativePath,\n        absolutePath,\n        relativePath\n      });\n\n      if (entries.length >= MAX_INDEX_FILES) break;\n    }\n  }\n\n  cache.set(workspaceId, { entries, builtAt: Date.now() });\n  return entries;\n}\n\n/**\n * Returns cached index or rebuilds if stale.\n */\nasync function getWorkspaceIndex(workspaceId: string, workspacePath: string): Promise<MentionSuggestion[]> {\n  const hit = cache.get(workspaceId);\n  if (hit && Date.now() - hit.builtAt < CACHE_TTL_MS) {\n    return hit.entries;\n  }\n  return buildWorkspaceIndex(workspaceId, workspacePath);\n}\n\n/**\n * Returns mention suggestions for a query string.\n */\nexport async function suggestMentions(\n  workspaceId: string,\n  workspacePath: string,\n  query: string\n): Promise<MentionSuggestion[]> {\n  const entries = await getWorkspaceIndex(workspaceId, workspacePath);\n  const normalized = query.toLowerCase();\n\n  if (!normalized) {\n    return entries.slice(0, 20);\n  }\n\n  const startsWith = entries.filter((entry) => entry.relativePath.toLowerCase().startsWith(normalized));\n  const includes = entries.filter(\n    (entry) =>\n      !entry.relativePath.toLowerCase().startsWith(normalized) &&\n      entry.relativePath.toLowerCase().includes(normalized)\n  );\n  return [...startsWith, ...includes].slice(0, 20);\n}\n\n/**\n * Resolves a raw mention query into a stable mention reference.\n */\nexport async function resolveMention(\n  workspaceId: string,\n  workspacePath: string,\n  query: string\n): Promise<{ mention: MentionRef | null; reason?: 'unresolved' | 'outside-workspace' }> {\n  const normalized = query.replace(/^\\.?\\//, '');\n  const directPath = path.resolve(workspacePath, normalized);\n\n  if (!isPathInsideWorkspace(workspacePath, directPath)) {\n    return { mention: null, reason: 'outside-workspace' };\n  }\n\n  try {\n    const stat = await fs.stat(directPath);\n    if (stat.isFile()) {\n      const relativePath = toPosixPath(path.relative(workspacePath, directPath));\n      return {\n        mention: {\n          id: `${workspaceId}:${relativePath}`,\n          type: 'file',\n          workspaceId,\n          absolutePath: directPath,\n          relativePath,\n          display: relativePath\n        }\n      };\n    }\n  } catch {\n    // Fall through to fuzzy search.\n  }\n\n  const matches = await suggestMentions(workspaceId, workspacePath, normalized);\n  const best = matches.find((entry) => entry.relativePath.toLowerCase() === normalized.toLowerCase()) ?? matches[0];\n  if (!best) {\n    return { mention: null, reason: 'unresolved' };\n  }\n\n  return {\n    mention: {\n      id: best.id,\n      type: 'file',\n      workspaceId,\n      absolutePath: best.absolutePath,\n      relativePath: best.relativePath,\n      display: best.display\n    }\n  };\n}\n","/**\n * @fileoverview Main-process composer service for suggestions and authoritative parse.\n * @module main/composer\n */\n\nimport type {\n  ComposerDiagnostic,\n  ComposerParseResult,\n  ComposerSuggestResult,\n  CommandSuggestion,\n  MentionRef,\n  ComposerPrepareInput,\n  ComposerSuggestInput\n} from '../../shared/composer';\nimport { listWorkspaces } from '../workspace';\nimport { parseComposerInput } from './parser';\nimport { listCommands } from './registry';\nimport { resolveMention, suggestMentions } from './mentions';\n\n/**\n * Looks up workspace path by workspace ID.\n */\nexport async function getWorkspacePathById(workspaceId: string): Promise<string | null> {\n  const workspaces = await listWorkspaces();\n  return workspaces.find((workspace) => workspace.id === workspaceId)?.path ?? null;\n}\n\n/**\n * Builds command suggestion entries filtered by query text.\n */\nfunction getCommandSuggestions(query: string): CommandSuggestion[] {\n  const normalized = query.toLowerCase();\n  return listCommands()\n    .filter((command) => command.name.startsWith(normalized))\n    .map((command) => ({\n      kind: 'command' as const,\n      name: command.name,\n      syntax: command.syntax,\n      description: command.description\n    }));\n}\n\n/**\n * Suggestion context at a cursor location.\n */\ntype SuggestionContext =\n  | { context: 'none'; query: '' }\n  | { context: 'command'; query: string }\n  | { context: 'mention'; query: string };\n\n/**\n * Detects whether the cursor is currently in command or mention completion context.\n */\nfunction detectSuggestionContext(rawInput: string, cursor: number): SuggestionContext {\n  const prefix = rawInput.slice(0, Math.max(0, Math.min(cursor, rawInput.length)));\n  const mentionMatch = prefix.match(/(?:^|\\s)@([A-Za-z0-9_./-]*)$/);\n  if (mentionMatch) {\n    return { context: 'mention', query: mentionMatch[1] };\n  }\n\n  const commandMatch = prefix.match(/^\\s*\\/([A-Za-z0-9-]*)$/);\n  if (commandMatch) {\n    return { context: 'command', query: commandMatch[1] };\n  }\n\n  return { context: 'none', query: '' };\n}\n\n/**\n * Returns composer suggestions for slash commands or @mentions at cursor position.\n */\nexport async function suggestComposer(input: ComposerSuggestInput): Promise<ComposerSuggestResult> {\n  const context = detectSuggestionContext(input.rawInput, input.cursor);\n  if (context.context === 'none') {\n    return { context: 'none', query: '', suggestions: [] };\n  }\n\n  if (context.context === 'command') {\n    return {\n      context: 'command',\n      query: context.query,\n      suggestions: getCommandSuggestions(context.query)\n    };\n  }\n\n  const workspacePath = await getWorkspacePathById(input.workspaceId);\n  if (!workspacePath) {\n    return { context: 'mention', query: context.query, suggestions: [] };\n  }\n\n  const suggestions = await suggestMentions(input.workspaceId, workspacePath, context.query);\n  return {\n    context: 'mention',\n    query: context.query,\n    suggestions\n  };\n}\n\n/**\n * Resolves extracted mention queries into stable mention references.\n */\nasync function resolveMentions(\n  workspaceId: string,\n  workspacePath: string,\n  mentionQueries: Array<{ query: string; start: number; end: number }>\n): Promise<{ mentions: MentionRef[]; diagnostics: ComposerDiagnostic[] }> {\n  const diagnostics: ComposerDiagnostic[] = [];\n  const mentions: MentionRef[] = [];\n  const seen = new Set<string>();\n\n  for (const query of mentionQueries) {\n    const result = await resolveMention(workspaceId, workspacePath, query.query);\n    if (result.mention) {\n      if (!seen.has(result.mention.id)) {\n        seen.add(result.mention.id);\n        mentions.push(result.mention);\n      }\n      continue;\n    }\n\n    if (result.reason === 'outside-workspace') {\n      diagnostics.push({\n        code: 'MENTION_OUTSIDE_WORKSPACE',\n        severity: 'error',\n        message: `Mention \"@${query.query}\" is outside the current workspace.`,\n        start: query.start,\n        end: query.end,\n        blocking: true\n      });\n      continue;\n    }\n\n    diagnostics.push({\n      code: 'MENTION_UNRESOLVED',\n      severity: 'error',\n      message: `Unable to resolve mention \"@${query.query}\".`,\n      start: query.start,\n      end: query.end,\n      blocking: true\n    });\n  }\n\n  return { mentions, diagnostics };\n}\n\n/**\n * Authoritatively parses and validates a composer input submission.\n */\nexport async function prepareComposer(input: ComposerPrepareInput): Promise<ComposerParseResult> {\n  const draft = parseComposerInput(input.rawInput);\n  const diagnostics: ComposerDiagnostic[] = [...draft.diagnostics];\n  let mentions: MentionRef[] = [];\n\n  const workspacePath = await getWorkspacePathById(input.workspaceId);\n  if (!workspacePath) {\n    diagnostics.push({\n      code: 'PARSE_SYNTAX',\n      severity: 'error',\n      message: 'No active workspace was found for this composer action.',\n      start: 0,\n      end: input.rawInput.length,\n      blocking: true\n    });\n  } else {\n    const mentionResult = await resolveMentions(input.workspaceId, workspacePath, draft.mentionQueries);\n    mentions = mentionResult.mentions;\n    diagnostics.push(...mentionResult.diagnostics);\n  }\n\n  return {\n    rawInput: input.rawInput,\n    tokens: draft.tokens,\n    command: draft.command,\n    mentions,\n    normalizedPrompt: draft.normalizedPrompt,\n    diagnostics,\n    blocking: diagnostics.some((diagnostic) => diagnostic.blocking)\n  };\n}\n","/**\n * @fileoverview Claude provider bridge for composer execution.\n * @module main/providers/claude\n */\n\nimport { execa } from 'execa';\nimport type { ClaudeExecutionRequest, ComposerExecutionResult } from '../../shared/composer';\n\n/**\n * Claude CLI JSON result shape for --output-format json.\n */\ntype ClaudeCliResult = {\n  is_error?: boolean;\n  result?: string;\n};\n\n/**\n * Creates a provider-unavailable result with a stable diagnostic.\n */\nfunction providerUnavailable(message: string): ComposerExecutionResult {\n  return {\n    ok: false,\n    provider: 'claude-code',\n    diagnostics: [\n      {\n        code: 'PROVIDER_UNAVAILABLE',\n        severity: 'error',\n        message,\n        start: 0,\n        end: 0,\n        blocking: true\n      }\n    ],\n    action: 'none'\n  };\n}\n\n/**\n * Creates a provider error result with configurable diagnostic code.\n */\nfunction providerError(\n  code: 'PROVIDER_UNAVAILABLE' | 'PROVIDER_AUTH_REQUIRED' | 'CMD_INVALID_ARGS',\n  message: string\n): ComposerExecutionResult {\n  return {\n    ok: false,\n    provider: 'claude-code',\n    diagnostics: [\n      {\n        code,\n        severity: 'error',\n        message,\n        start: 0,\n        end: 0,\n        blocking: true\n      }\n    ],\n    action: 'none'\n  };\n}\n\n/**\n * Builds a Claude CLI prompt from normalized parse output.\n */\nfunction buildPrompt(request: ClaudeExecutionRequest): string {\n  const { parseResult } = request;\n  const command = parseResult.command;\n  const lines: string[] = [];\n\n  if (command) {\n    const argsText = command.args.join(' ').trim();\n    switch (command.name) {\n      case 'compact':\n        lines.push('Respond concisely.');\n        break;\n      case 'review':\n        lines.push('Perform a review-style response focused on issues, risks, and missing tests.');\n        break;\n      case 'plan':\n        lines.push('Provide an implementation plan with clear steps.');\n        break;\n      case 'status':\n        lines.push('Summarize the current workspace status.');\n        break;\n      case 'diff':\n        lines.push(argsText ? `Focus on diff analysis for target: ${argsText}.` : 'Focus on relevant git diff analysis.');\n        break;\n      case 'test':\n        lines.push(argsText ? `Focus on testing scope: ${argsText}.` : 'Focus on test strategy and validation.');\n        break;\n      default:\n        break;\n    }\n  }\n\n  if (parseResult.mentions.length > 0) {\n    lines.push(\n      `Referenced files:\\n${parseResult.mentions.map((mention) => `- ${mention.relativePath}`).join('\\n')}`\n    );\n  }\n\n  let userPrompt = parseResult.normalizedPrompt;\n  if (command) {\n    const prefix = `/${command.name}`;\n    if (userPrompt.startsWith(prefix)) {\n      userPrompt = userPrompt.slice(prefix.length).trim();\n    }\n  }\n\n  if (userPrompt) {\n    lines.push(`User request:\\n${userPrompt}`);\n  }\n\n  return lines.join('\\n\\n').trim();\n}\n\n/**\n * Executes a prepared request through Claude Code CLI.\n */\nexport async function executeClaudeRequest(request: ClaudeExecutionRequest): Promise<ComposerExecutionResult> {\n  const prompt = buildPrompt(request);\n  if (!prompt) {\n    return providerUnavailable('Composer prompt is empty after normalization.');\n  }\n\n  const args = ['-p', '--output-format', 'json'];\n  if (request.modelOverride) {\n    args.push('--model', request.modelOverride);\n  }\n  args.push(prompt);\n\n  try {\n    const result = await execa('claude', args, {\n      cwd: request.workspacePath,\n      reject: false,\n      timeout: 120000\n    });\n\n    const raw = result.stdout.trim() || result.stderr.trim();\n    if (!raw) {\n      return providerUnavailable('Claude Code returned an empty response.');\n    }\n\n    let payload: ClaudeCliResult | null = null;\n    try {\n      payload = JSON.parse(raw) as ClaudeCliResult;\n    } catch {\n      payload = null;\n    }\n\n    if (payload?.is_error) {\n      const errorMessage = payload.result ?? 'Claude Code returned an error response.';\n      const normalized = errorMessage.toLowerCase();\n      if (normalized.includes('invalid_model')) {\n        return providerError('CMD_INVALID_ARGS', errorMessage);\n      }\n      if (normalized.includes('auth') || normalized.includes('token')) {\n        return providerError('PROVIDER_AUTH_REQUIRED', errorMessage);\n      }\n      return providerUnavailable(errorMessage);\n    }\n\n    return {\n      ok: true,\n      provider: 'claude-code',\n      output: payload?.result ?? raw,\n      action: 'none'\n    };\n  } catch (error) {\n    const message = error instanceof Error ? error.message : 'Unknown Claude Code execution failure.';\n    return providerUnavailable(`Failed to execute Claude Code CLI: ${message}`);\n  }\n}\n","/**\n * @fileoverview Provider orchestration for composer execution.\n * @module main/providers\n */\n\nimport type { ClaudeExecutionRequest, ComposerExecutionResult } from '../../shared/composer';\nimport { executeClaudeRequest } from './claude';\n\n/**\n * Initializes provider integrations.\n */\nexport function initProviders() {\n  // Reserved for future provider bootstrapping.\n}\n\n/**\n * Executes a prepared composer request against local/provider handlers.\n */\nexport async function executeComposerRequest(\n  request: ClaudeExecutionRequest\n): Promise<ComposerExecutionResult> {\n  const command = request.parseResult.command;\n\n  if (command?.name === 'help') {\n    return {\n      ok: true,\n      provider: 'local',\n      output:\n        '/help, /clear, /model <model>, /compact, /review, /plan, /status, /diff [target], /test [scope]',\n      action: 'none'\n    };\n  }\n\n  if (command?.name === 'clear') {\n    return {\n      ok: true,\n      provider: 'local',\n      output: '',\n      action: 'clear'\n    };\n  }\n\n  if (command?.name === 'model') {\n    return {\n      ok: true,\n      provider: 'local',\n      output: `Model override set to ${command.args[0]}.`,\n      modelOverride: command.args[0],\n      action: 'none'\n    };\n  }\n\n  return executeClaudeRequest(request);\n}\n","/**\n * @fileoverview IPC handler registration for main process communication.\n * Registers all IPC channels for workspace, git, and diff operations,\n * and broadcasts events to all renderer windows.\n * @module main/ipc\n */\n\nimport { BrowserWindow, ipcMain } from 'electron';\nimport {\n  addWorkspace,\n  getCurrentWorkspace,\n  listRecentWorkspaces,\n  listWorkspaces,\n  discoverGitWorkspaces,\n  pickWorkspace,\n  removeWorkspace,\n  ignoreWorkspacePath,\n  listIgnoredWorkspaces,\n  renameWorkspace,\n  restoreIgnoredWorkspace,\n  setCurrentWorkspace\n} from '../workspace';\nimport { getGitSummary, getGitStatus, getGitFileStatuses } from '../git';\nimport { getDiff, getDiffForFile } from '../diff';\nimport { emitAppEvent, onAppEvent, type AppEvent } from '../events';\nimport { startWatchers, stopWatchers } from '../watchers';\nimport { listThreads, createThread, renameThread, removeThread } from '../thread';\nimport { prepareComposer, suggestComposer, getWorkspacePathById } from '../composer';\nimport { executeComposerRequest } from '../providers';\nimport type { ComposerPrepareInput, ComposerSuggestInput } from '../../shared/composer';\n\n/** Flag to track if event listeners have been bound */\nlet eventsBound = false;\n\n/**\n * Broadcasts an event to all open browser windows.\n * @param {AppEvent} event - The event name to broadcast\n */\nfunction broadcast(event: AppEvent) {\n  for (const window of BrowserWindow.getAllWindows()) {\n    window.webContents.send(event);\n  }\n}\n\n/**\n * Refreshes file system watchers based on the current workspace.\n * Stops existing watchers if no workspace is selected, or starts\n * new watchers for the current workspace path.\n * @returns {Promise<void>}\n */\nasync function refreshWatchers() {\n  const current = await getCurrentWorkspace();\n  if (!current) {\n    await stopWatchers();\n    return;\n  }\n  await startWatchers(current.path);\n}\n\n/**\n * Registers all IPC handlers for the main process.\n * Sets up handlers for workspace, git, and diff operations.\n * Also binds event listeners to broadcast changes to renderer windows.\n */\nexport function registerIpc() {\n  if (!eventsBound) {\n    eventsBound = true;\n    onAppEvent('workspace:changed', () => broadcast('workspace:changed'));\n    onAppEvent('git:changed', () => broadcast('git:changed'));\n    onAppEvent('diff:changed', () => broadcast('diff:changed'));\n  }\n\n  ipcMain.handle('ping', async () => {\n    return 'pong from main';\n  });\n\n  ipcMain.handle('workspace:list', async () => {\n    return listWorkspaces();\n  });\n\n  ipcMain.handle('workspace:recent', async (_event, limit?: number) => {\n    return listRecentWorkspaces(limit ?? 5);\n  });\n\n  ipcMain.handle(\n    'workspace:discover',\n    async (\n      _event,\n      options?: { roots?: string[]; maxDepth?: number; limit?: number; includeIgnored?: boolean }\n    ) => {\n    return discoverGitWorkspaces(options);\n    }\n  );\n\n  ipcMain.handle('workspace:ignored:list', async () => {\n    return listIgnoredWorkspaces();\n  });\n\n  ipcMain.handle('workspace:ignored:add', async (_event, dirPath: string) => {\n    return ignoreWorkspacePath(dirPath);\n  });\n\n  ipcMain.handle('workspace:ignored:remove', async (_event, dirPath: string) => {\n    return restoreIgnoredWorkspace(dirPath);\n  });\n\n  ipcMain.handle('workspace:current', async () => {\n    return getCurrentWorkspace();\n  });\n\n  ipcMain.handle('workspace:add', async (_event, dirPath: string) => {\n    const entry = await addWorkspace(dirPath);\n    await refreshWatchers();\n    emitAppEvent('workspace:changed');\n    emitAppEvent('git:changed');\n    emitAppEvent('diff:changed');\n    return entry;\n  });\n\n  ipcMain.handle('workspace:pick', async () => {\n    const entry = await pickWorkspace();\n    await refreshWatchers();\n    emitAppEvent('workspace:changed');\n    emitAppEvent('git:changed');\n    emitAppEvent('diff:changed');\n    return entry;\n  });\n\n  ipcMain.handle('workspace:set', async (_event, id: string) => {\n    const entry = await setCurrentWorkspace(id);\n    await refreshWatchers();\n    emitAppEvent('workspace:changed');\n    emitAppEvent('git:changed');\n    emitAppEvent('diff:changed');\n    return entry;\n  });\n\n  ipcMain.handle('workspace:rename', async (_event, id: string, name: string) => {\n    const entry = await renameWorkspace(id, name);\n    emitAppEvent('workspace:changed');\n    return entry;\n  });\n\n  ipcMain.handle('workspace:remove', async (_event, id: string) => {\n    const result = await removeWorkspace(id);\n    await refreshWatchers();\n    emitAppEvent('workspace:changed');\n    emitAppEvent('git:changed');\n    emitAppEvent('diff:changed');\n    return result;\n  });\n\n  ipcMain.handle('git:summary', async () => {\n    return getGitSummary();\n  });\n\n  ipcMain.handle('git:status', async () => {\n    return getGitStatus();\n  });\n\n  ipcMain.handle('git:files', async () => {\n    return getGitFileStatuses();\n  });\n\n  ipcMain.handle('diff:current', async () => {\n    return getDiff();\n  });\n\n  ipcMain.handle('diff:file', async (_event, filePath: string) => {\n    return getDiffForFile(filePath);\n  });\n\n  ipcMain.handle('thread:list', async (_event, workspaceId: string) => {\n    return listThreads(workspaceId);\n  });\n\n  ipcMain.handle('thread:create', async (_event, workspaceId: string, title: string) => {\n    return createThread(workspaceId, title);\n  });\n\n  ipcMain.handle('thread:rename', async (_event, id: string, title: string) => {\n    return renameThread(id, title);\n  });\n\n  ipcMain.handle('thread:remove', async (_event, id: string) => {\n    return removeThread(id);\n  });\n\n  ipcMain.handle('composer:suggest', async (_event, input: ComposerSuggestInput) => {\n    return suggestComposer(input);\n  });\n\n  ipcMain.handle('composer:prepare', async (_event, input: ComposerPrepareInput) => {\n    return prepareComposer(input);\n  });\n\n  ipcMain.handle('composer:execute', async (_event, input: ComposerPrepareInput) => {\n    const parseResult = await prepareComposer(input);\n    if (parseResult.blocking) {\n      return {\n        ok: false,\n        provider: 'local',\n        action: 'none',\n        diagnostics: parseResult.diagnostics\n      };\n    }\n\n    const workspacePath = await getWorkspacePathById(input.workspaceId);\n    if (!workspacePath) {\n      return {\n        ok: false,\n        provider: 'local',\n        action: 'none',\n        diagnostics: [\n          {\n            code: 'PARSE_SYNTAX',\n            severity: 'error',\n            message: 'No active workspace found.',\n            start: 0,\n            end: input.rawInput.length,\n            blocking: true\n          }\n        ]\n      };\n    }\n\n    return executeComposerRequest({\n      workspaceId: input.workspaceId,\n      workspacePath,\n      threadId: input.threadId,\n      parseResult,\n      modelOverride: input.modelOverride\n    });\n  });\n\n  refreshWatchers().catch(() => {});\n}\n","/**\n * @fileoverview Main process entry point for the Electron desktop application.\n * Handles app lifecycle, window creation, and module initialization.\n * @module main\n */\n\nimport { app, BrowserWindow } from 'electron';\nimport fs from 'node:fs';\nimport path from 'node:path';\nimport { registerIpc } from './ipc';\nimport { initWorkspace } from './workspace';\nimport { initGit } from './git';\nimport { initDiff } from './diff';\nimport { initScripts } from './scripts';\nimport { initTesting } from './testing';\nimport { initSpotlight } from './spotlight';\nimport { initTodos } from './todos';\nimport { initCheckpoints } from './checkpoints';\nimport { initIntegrations } from './integrations';\nimport { initProviders } from './providers';\nimport { initStorage } from './storage';\nimport { initThread } from './thread';\n\n/** Development server URL from environment variables */\nconst devServerUrl = process.env.VITE_DEV_SERVER_URL ?? process.env.ELECTRON_RENDERER_URL;\n/** Fallback URL when dev server URL is not configured */\nconst fallbackDevServerUrl = 'http://127.0.0.1:5173';\n/** Whether the app is running in development mode */\nconst isDev = Boolean(devServerUrl);\n/** Minimum splash duration in milliseconds */\nconst minimumSplashMs = 900;\n/** Reference to the main application window */\nlet mainWindow: BrowserWindow | null = null;\n/** Reference to the splash window shown during startup */\nlet splashWindow: BrowserWindow | null = null;\n\n/**\n * Creates and returns splash HTML for launch animation.\n */\nfunction getSplashHtml() {\n  return `<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>open-app</title>\n    <style>\n      :root { color-scheme: dark; }\n      * { box-sizing: border-box; }\n      body {\n        margin: 0;\n        width: 100vw;\n        height: 100vh;\n        display: grid;\n        place-items: center;\n        font-family: \"SF Pro Text\", \"SF Pro Display\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", sans-serif;\n        background: #0f0f10;\n        color: #e8e8e8;\n        overflow: hidden;\n      }\n      .logo {\n        font-size: 36px;\n        font-weight: 600;\n        letter-spacing: -0.02em;\n        animation: splash-in 320ms ease-out forwards, splash-out 280ms ease-in 560ms forwards;\n      }\n      @keyframes splash-in {\n        from { opacity: 0; transform: scale(0.95); }\n        to { opacity: 1; transform: scale(1); }\n      }\n      @keyframes splash-out {\n        from { opacity: 1; transform: scale(1); }\n        to { opacity: 0; transform: scale(1.03); }\n      }\n    </style>\n  </head>\n  <body>\n    <div class=\"logo\">open-app</div>\n  </body>\n</html>`;\n}\n\n/**\n * Creates and configures the splash window shown on app launch.\n */\nfunction createSplashWindow() {\n  splashWindow = new BrowserWindow({\n    width: 560,\n    height: 360,\n    frame: false,\n    resizable: false,\n    movable: false,\n    minimizable: false,\n    maximizable: false,\n    fullscreenable: false,\n    skipTaskbar: true,\n    alwaysOnTop: true,\n    transparent: false,\n    backgroundColor: '#0f0f10',\n    show: true\n  });\n\n  splashWindow.setMenuBarVisibility(false);\n  splashWindow.loadURL(`data:text/html;charset=utf-8,${encodeURIComponent(getSplashHtml())}`);\n  splashWindow.on('closed', () => {\n    splashWindow = null;\n  });\n}\n\n/**\n * Creates and configures the main application window.\n * Sets up preload script, window dimensions, and loads the appropriate content\n * based on development or production mode.\n */\nfunction createWindow() {\n  const preloadMjs = path.join(__dirname, '../preload/index.mjs');\n  const preloadJs = path.join(__dirname, '../preload/index.js');\n  const preloadPath = fs.existsSync(preloadMjs) ? preloadMjs : preloadJs;\n\n  mainWindow = new BrowserWindow({\n    width: 1200,\n    height: 800,\n    show: false,\n    backgroundColor: '#0f0f10',\n    webPreferences: {\n      preload: preloadPath,\n      contextIsolation: true,\n      nodeIntegration: false\n    }\n  });\n\n  if (isDev) {\n    const url = devServerUrl ?? fallbackDevServerUrl;\n    mainWindow.loadURL(url);\n  } else {\n    const indexHtml = path.join(__dirname, '../renderer/index.html');\n    mainWindow.loadFile(indexHtml);\n  }\n\n  mainWindow.on('closed', () => {\n    mainWindow = null;\n  });\n\n  return mainWindow;\n}\n\n/**\n * Creates startup windows and keeps splash visible until app shell is ready.\n */\nasync function createStartupWindows() {\n  const startupAt = Date.now();\n  createSplashWindow();\n  const window = createWindow();\n\n  await new Promise<void>((resolve) => {\n    let done = false;\n    const finish = () => {\n      if (done) return;\n      done = true;\n      resolve();\n    };\n    window.webContents.once('did-finish-load', finish);\n    window.webContents.once('did-fail-load', finish);\n  });\n\n  const elapsed = Date.now() - startupAt;\n  const waitMs = Math.max(0, minimumSplashMs - elapsed);\n  if (waitMs > 0) {\n    await new Promise((resolve) => setTimeout(resolve, waitMs));\n  }\n\n  if (splashWindow && !splashWindow.isDestroyed()) {\n    splashWindow.close();\n  }\n\n  if (!window.isDestroyed()) {\n    window.show();\n    if (isDev) {\n      window.webContents.openDevTools({ mode: 'detach' });\n    }\n  }\n}\n\n/**\n * Initializes all application modules.\n * Loads workspace, git, diff, scripts, testing, spotlight, todos,\n * checkpoints, integrations, providers, storage modules, and registers IPC handlers.\n * @returns {Promise<void>}\n */\nasync function initModules() {\n  initWorkspace();\n  initGit();\n  initDiff();\n  initScripts();\n  initTesting();\n  initSpotlight();\n  initTodos();\n  initCheckpoints();\n  initIntegrations();\n  initProviders();\n  initStorage();\n  await initThread();\n  registerIpc();\n}\n\napp.whenReady().then(async () => {\n  await initModules();\n  await createStartupWindows();\n\n  app.on('activate', () => {\n    if (BrowserWindow.getAllWindows().length === 0) {\n      void createStartupWindows();\n    }\n  });\n});\n\napp.on('window-all-closed', () => {\n  if (process.platform !== 'darwin') {\n    app.quit();\n  }\n});\n"],"names":["getStorePath","path","execFileAsync","fs"],"mappings":"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"}