{"version":3,"file":"index.js","sources":["../../src/main/workspace/index.ts","../../src/main/git/index.ts","../../src/main/diff/index.ts","../../src/main/events/index.ts","../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/constants.js","../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/utils.js","../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/scan.js","../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/parse.js","../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/picomatch.js","../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/index.js","../../node_modules/.pnpm/readdirp@3.6.0/node_modules/readdirp/index.js","../../node_modules/.pnpm/normalize-path@3.0.0/node_modules/normalize-path/index.js","../../node_modules/.pnpm/anymatch@3.1.3/node_modules/anymatch/index.js","../../node_modules/.pnpm/is-extglob@2.1.1/node_modules/is-extglob/index.js","../../node_modules/.pnpm/is-glob@4.0.3/node_modules/is-glob/index.js","../../node_modules/.pnpm/glob-parent@5.1.2/node_modules/glob-parent/index.js","../../node_modules/.pnpm/braces@3.0.3/node_modules/braces/lib/utils.js","../../node_modules/.pnpm/braces@3.0.3/node_modules/braces/lib/stringify.js","../../node_modules/.pnpm/is-number@7.0.0/node_modules/is-number/index.js","../../node_modules/.pnpm/to-regex-range@5.0.1/node_modules/to-regex-range/index.js","../../node_modules/.pnpm/fill-range@7.1.1/node_modules/fill-range/index.js","../../node_modules/.pnpm/braces@3.0.3/node_modules/braces/lib/compile.js","../../node_modules/.pnpm/braces@3.0.3/node_modules/braces/lib/expand.js","../../node_modules/.pnpm/braces@3.0.3/node_modules/braces/lib/constants.js","../../node_modules/.pnpm/braces@3.0.3/node_modules/braces/lib/parse.js","../../node_modules/.pnpm/braces@3.0.3/node_modules/braces/index.js","../../node_modules/.pnpm/binary-extensions@2.3.0/node_modules/binary-extensions/index.js","../../node_modules/.pnpm/is-binary-path@2.1.0/node_modules/is-binary-path/index.js","../../node_modules/.pnpm/chokidar@3.6.0/node_modules/chokidar/lib/constants.js","../../node_modules/.pnpm/chokidar@3.6.0/node_modules/chokidar/lib/nodefs-handler.js","../../node_modules/.pnpm/fsevents@2.3.3/node_modules/fsevents/fsevents.node","../../node_modules/.pnpm/fsevents@2.3.3/node_modules/fsevents/fsevents.js","../../node_modules/.pnpm/chokidar@3.6.0/node_modules/chokidar/lib/fsevents-handler.js","../../node_modules/.pnpm/chokidar@3.6.0/node_modules/chokidar/index.js","../../src/main/watchers/index.ts","../../src/main/thread/index.ts","../../src/main/ipc/index.ts","../../src/main/index.ts"],"sourcesContent":["/**\n * @fileoverview Workspace management module for handling user workspaces.\n * Provides functionality for creating, listing, removing, and discovering workspaces.\n * Stores workspace state in a JSON file in the user data directory.\n * @module main/workspace\n */\n\nimport { app, BrowserWindow, dialog, type OpenDialogOptions } from 'electron';\nimport type { Dirent } from 'node:fs';\nimport fs from 'node:fs/promises';\nimport path from 'node:path';\nimport { randomUUID } from 'node:crypto';\n\n/**\n * Represents a workspace entry stored in the application.\n */\nexport type WorkspaceEntry = {\n  id: string;\n  name: string;\n  path: string;\n  lastOpenedAt: string;\n};\n\n/**\n * Represents a workspace discovered during filesystem scanning.\n */\nexport type DiscoveredWorkspace = {\n  name: string;\n  path: string;\n  lastModifiedAt: string;\n};\n\n/**\n * Internal state structure for workspace management.\n */\ntype WorkspaceState = {\n  currentId: string | null;\n  entries: WorkspaceEntry[];\n  ignoredPaths: string[];\n};\n\n/** Current workspace state held in memory */\nconst state: WorkspaceState = {\n  currentId: null,\n  entries: [],\n  ignoredPaths: []\n};\n\n/** Promise that resolves when state is loaded */\nlet ready: Promise<void> = Promise.resolve();\n\n/**\n * Gets the file path for storing workspace state.\n * @returns {string} Path to workspaces.json in user data directory\n */\nfunction getStorePath() {\n  return path.join(app.getPath('userData'), 'workspaces.json');\n}\n\n/**\n * Loads workspace state from the persistent storage file.\n * Initializes empty state if the file doesn't exist or is invalid.\n * @returns {Promise<void>}\n */\nasync function loadState() {\n  try {\n    const data = await fs.readFile(getStorePath(), 'utf-8');\n    const parsed = JSON.parse(data) as WorkspaceState;\n    state.currentId = parsed.currentId ?? null;\n    state.entries = Array.isArray(parsed.entries) ? parsed.entries : [];\n    state.ignoredPaths = Array.isArray(parsed.ignoredPaths) ? parsed.ignoredPaths : [];\n  } catch {\n    state.currentId = null;\n    state.entries = [];\n    state.ignoredPaths = [];\n  }\n}\n\n/**\n * Saves the current workspace state to the persistent storage file.\n * @returns {Promise<void>}\n */\nasync function saveState() {\n  const payload: WorkspaceState = {\n    currentId: state.currentId,\n    entries: state.entries,\n    ignoredPaths: state.ignoredPaths\n  };\n  await fs.writeFile(getStorePath(), JSON.stringify(payload, null, 2), 'utf-8');\n}\n\n/**\n * Finds a workspace entry by its directory path.\n * @param {string} dirPath - The directory path to search for\n * @returns {WorkspaceEntry | null} The matching workspace entry or null\n */\nfunction findEntryByPath(dirPath: string) {\n  return state.entries.find((entry) => entry.path === dirPath) ?? null;\n}\n\n/**\n * Gets a workspace entry by its unique identifier.\n * @param {string | null} id - The workspace ID to search for\n * @returns {WorkspaceEntry | null} The matching workspace entry or null\n */\nfunction getEntryById(id: string | null) {\n  if (!id) return null;\n  return state.entries.find((entry) => entry.id === id) ?? null;\n}\n\n/**\n * Ensures the workspace state has been loaded before operations.\n * @returns {Promise<void>}\n */\nasync function ensureReady() {\n  await ready;\n}\n\n/**\n * Initializes the workspace module by loading saved state.\n */\nexport function initWorkspace() {\n  ready = loadState();\n}\n\n/**\n * Lists all workspaces sorted by last opened date (most recent first).\n * @returns {Promise<WorkspaceEntry[]>} Array of workspace entries\n */\nexport async function listWorkspaces() {\n  await ensureReady();\n  return [...state.entries].sort((a, b) => b.lastOpenedAt.localeCompare(a.lastOpenedAt));\n}\n\n/**\n * Lists the most recently opened workspaces.\n * @param {number} [limit=5] - Maximum number of workspaces to return\n * @returns {Promise<WorkspaceEntry[]>} Array of recent workspace entries\n */\nexport async function listRecentWorkspaces(limit = 5) {\n  const list = await listWorkspaces();\n  return list.slice(0, limit);\n}\n\n/**\n * Gets the currently active workspace.\n * @returns {Promise<WorkspaceEntry | null>} The current workspace entry or null\n */\nexport async function getCurrentWorkspace() {\n  await ensureReady();\n  return getEntryById(state.currentId);\n}\n\n/**\n * Sets the current workspace by ID and updates its last opened timestamp.\n * @param {string} id - The workspace ID to set as current\n * @returns {Promise<WorkspaceEntry | null>} The updated workspace entry or null if not found\n */\nexport async function setCurrentWorkspace(id: string) {\n  await ensureReady();\n  const entry = getEntryById(id);\n  if (!entry) return null;\n  state.currentId = entry.id;\n  entry.lastOpenedAt = new Date().toISOString();\n  await saveState();\n  return entry;\n}\n\n/**\n * Adds a new workspace or updates an existing one if the path already exists.\n * Removes the path from ignored list if present.\n * @param {string} dirPath - The directory path to add as a workspace\n * @returns {Promise<WorkspaceEntry>} The created or updated workspace entry\n */\nexport async function addWorkspace(dirPath: string) {\n  await ensureReady();\n  if (state.ignoredPaths.includes(dirPath)) {\n    state.ignoredPaths = state.ignoredPaths.filter((path) => path !== dirPath);\n  }\n  const existing = findEntryByPath(dirPath);\n  if (existing) {\n    existing.lastOpenedAt = new Date().toISOString();\n    state.currentId = existing.id;\n    await saveState();\n    return existing;\n  }\n\n  const entry: WorkspaceEntry = {\n    id: randomUUID(),\n    name: path.basename(dirPath),\n    path: dirPath,\n    lastOpenedAt: new Date().toISOString()\n  };\n\n  state.entries.push(entry);\n  state.currentId = entry.id;\n  await saveState();\n  return entry;\n}\n\n/**\n * Renames a workspace.\n * @param {string} id - The workspace ID to rename\n * @param {string} name - The new name for the workspace\n * @returns {Promise<WorkspaceEntry | null>} The updated workspace entry or null if not found\n */\nexport async function renameWorkspace(id: string, name: string) {\n  await ensureReady();\n  const entry = getEntryById(id);\n  if (!entry) return null;\n\n  const nextName = name.trim();\n  if (!nextName) return null;\n\n  entry.name = nextName;\n  await saveState();\n  return entry;\n}\n\n/**\n * Removes a workspace by ID.\n * If the removed workspace was current, sets the first available workspace as current.\n * @param {string} id - The workspace ID to remove\n * @returns {Promise<{removed: boolean, current: WorkspaceEntry | null}>} Result with removal status and new current workspace\n */\nexport async function removeWorkspace(id: string) {\n  await ensureReady();\n  const index = state.entries.findIndex((entry) => entry.id === id);\n  if (index === -1) return { removed: false, current: getEntryById(state.currentId) };\n\n  const [removed] = state.entries.splice(index, 1);\n  if (state.currentId === removed.id) {\n    state.currentId = state.entries[0]?.id ?? null;\n  }\n  await saveState();\n  return { removed: true, current: getEntryById(state.currentId) };\n}\n\n/**\n * Lists all ignored workspace paths.\n * @returns {Promise<string[]>} Array of ignored directory paths\n */\nexport async function listIgnoredWorkspaces() {\n  await ensureReady();\n  return [...state.ignoredPaths];\n}\n\n/**\n * Adds a path to the ignored workspaces list.\n * @param {string} pathToIgnore - The directory path to ignore\n * @returns {Promise<string[]>} Updated array of ignored paths\n */\nexport async function ignoreWorkspacePath(pathToIgnore: string) {\n  await ensureReady();\n  if (!state.ignoredPaths.includes(pathToIgnore)) {\n    state.ignoredPaths.push(pathToIgnore);\n    await saveState();\n  }\n  return [...state.ignoredPaths];\n}\n\n/**\n * Removes a path from the ignored workspaces list.\n * @param {string} pathToRestore - The directory path to restore\n * @returns {Promise<string[]>} Updated array of ignored paths\n */\nexport async function restoreIgnoredWorkspace(pathToRestore: string) {\n  await ensureReady();\n  state.ignoredPaths = state.ignoredPaths.filter((value) => value !== pathToRestore);\n  await saveState();\n  return [...state.ignoredPaths];\n}\n\n/** Default directories to search for git repositories */\nconst DEFAULT_DISCOVERY_DIRS = ['Desktop', 'Documents', 'Projects', 'Code', 'workspace', 'dev'];\n/** Directories to ignore during workspace discovery */\nconst IGNORE_DIRS = new Set(['node_modules', '.git', 'dist', 'build', '.next', 'out', 'coverage']);\n\n/**\n * Discovers git repositories in the filesystem.\n * Searches through specified root directories or default locations.\n * @param {Object} [options] - Discovery options\n * @param {string[]} [options.roots] - Root directories to search in\n * @param {number} [options.maxDepth=4] - Maximum directory depth to traverse\n * @param {number} [options.limit=50] - Maximum number of repositories to return\n * @param {boolean} [options.includeIgnored=false] - Whether to include ignored paths\n * @returns {Promise<DiscoveredWorkspace[]>} Array of discovered workspaces\n */\nexport async function discoverGitWorkspaces(options?: {\n  roots?: string[];\n  maxDepth?: number;\n  limit?: number;\n  includeIgnored?: boolean;\n}): Promise<DiscoveredWorkspace[]> {\n  const home = app.getPath('home');\n  const roots = options?.roots ??\n    (await Promise.all(\n      DEFAULT_DISCOVERY_DIRS.map(async (dir) => {\n        const full = path.join(home, dir);\n        try {\n          const stat = await fs.stat(full);\n          return stat.isDirectory() ? full : null;\n        } catch {\n          return null;\n        }\n      })\n    )).filter((value): value is string => Boolean(value));\n\n  const maxDepth = options?.maxDepth ?? 4;\n  const limit = options?.limit ?? 50;\n  const discovered: DiscoveredWorkspace[] = [];\n  const visited = new Set<string>();\n\n  const isGitRepo = async (dirPath: string) => {\n    try {\n      const stat = await fs.stat(path.join(dirPath, '.git'));\n      return stat.isDirectory();\n    } catch {\n      return false;\n    }\n  };\n\n  const walk = async (dirPath: string, depth: number) => {\n    if (depth < 0 || discovered.length >= limit) return;\n\n    let realPath = dirPath;\n    try {\n      realPath = await fs.realpath(dirPath);\n    } catch {\n      return;\n    }\n\n    if (visited.has(realPath)) return;\n    visited.add(realPath);\n\n    if (await isGitRepo(dirPath)) {\n      try {\n        const stat = await fs.stat(dirPath);\n        discovered.push({\n          name: path.basename(dirPath),\n          path: dirPath,\n          lastModifiedAt: stat.mtime.toISOString()\n        });\n      } catch {\n        discovered.push({\n          name: path.basename(dirPath),\n          path: dirPath,\n          lastModifiedAt: new Date().toISOString()\n        });\n      }\n      return;\n    }\n\n    let entries: Dirent[] = [];\n    try {\n      entries = await fs.readdir(dirPath, { withFileTypes: true });\n    } catch {\n      return;\n    }\n\n    await Promise.all(\n      entries.map(async (entry) => {\n        if (!entry.isDirectory() || entry.isSymbolicLink()) return;\n        if (IGNORE_DIRS.has(entry.name)) return;\n        if (entry.name.startsWith('.')) return;\n        await walk(path.join(dirPath, entry.name), depth - 1);\n      })\n    );\n  };\n\n  await Promise.all(roots.map((root) => walk(root, maxDepth)));\n\n  const filtered = options?.includeIgnored\n    ? discovered\n    : discovered.filter((entry) => !state.ignoredPaths.includes(entry.path));\n\n  return filtered\n    .sort((a, b) => b.lastModifiedAt.localeCompare(a.lastModifiedAt))\n    .slice(0, limit);\n}\n\n/**\n * Opens a native directory picker dialog to select a workspace.\n * @returns {Promise<WorkspaceEntry | null>} The selected workspace entry or null if canceled\n */\nexport async function pickWorkspace() {\n  await ensureReady();\n  const window = BrowserWindow.getFocusedWindow();\n  const options: OpenDialogOptions = {\n    properties: ['openDirectory'],\n    title: 'Select a workspace folder'\n  };\n\n  const result = window\n    ? await dialog.showOpenDialog(window, options)\n    : await dialog.showOpenDialog(options);\n\n  if (result.canceled || result.filePaths.length === 0) {\n    return null;\n  }\n\n  return addWorkspace(result.filePaths[0]);\n}\n\n/**\n * Gets the directory path of the current workspace.\n * @returns {Promise<string | null>} The current workspace path or null\n */\nexport async function getCurrentWorkspacePath() {\n  const entry = await getCurrentWorkspace();\n  return entry?.path ?? null;\n}\n","/**\n * @fileoverview Git integration module for the main process.\n * Provides functions to interact with git repositories including\n * getting status, summaries, and file change information.\n * @module main/git\n */\n\nimport { execFile } from 'node:child_process';\nimport { promisify } from 'node:util';\nimport { getCurrentWorkspacePath } from '../workspace';\n\n/** Promisified version of execFile for async git commands */\nconst execFileAsync = promisify(execFile);\n\n/**\n * Summary information about a git repository.\n */\nexport type GitSummary = {\n  available: boolean;\n  reason?: string;\n  root?: string;\n  branch?: string;\n  status?: string;\n  lastCommit?: string;\n};\n\n/**\n * Status information for a single file in the git repository.\n */\nexport type GitFileStatus = {\n  path: string;\n  staged: boolean;\n  unstaged: boolean;\n  status: string;\n};\n\n/**\n * Executes a git command in the specified directory.\n * @param {string[]} args - Arguments to pass to the git command\n * @param {string} cwd - Working directory for the git command\n * @returns {Promise<{ok: boolean, stdout: string, error?: string}>} Result of the git command\n */\nasync function runGit(args: string[], cwd: string) {\n  try {\n    const { stdout } = await execFileAsync('git', args, { cwd });\n    return { ok: true, stdout: stdout.trim() };\n  } catch (error: any) {\n    return {\n      ok: false,\n      stdout: '',\n      error: error?.stderr?.toString?.() ?? error?.message ?? 'git command failed'\n    };\n  }\n}\n\n/**\n * Initializes the git module.\n * Placeholder for future git module bootstrapping.\n */\nexport function initGit() {\n  // Placeholder for future git module bootstrapping.\n}\n\n/**\n * Gets a summary of the current git repository state.\n * Includes branch name, status, root path, and last commit information.\n * @returns {Promise<GitSummary>} Git repository summary\n */\nexport async function getGitSummary(): Promise<GitSummary> {\n  const cwd = await getCurrentWorkspacePath();\n  if (!cwd) {\n    return { available: false, reason: 'No workspace selected' };\n  }\n\n  const repoCheck = await runGit(['rev-parse', '--is-inside-work-tree'], cwd);\n  if (!repoCheck.ok || repoCheck.stdout !== 'true') {\n    return { available: false, reason: 'Not a git repository' };\n  }\n\n  const root = await runGit(['rev-parse', '--show-toplevel'], cwd);\n  const branch = await runGit(['rev-parse', '--abbrev-ref', 'HEAD'], cwd);\n  const status = await runGit(['status', '-sb'], cwd);\n  const lastCommit = await runGit(\n    ['log', '-1', '--pretty=format:%h %s (%an, %ad)', '--date=short'],\n    cwd\n  );\n\n  return {\n    available: true,\n    root: root.ok ? root.stdout : undefined,\n    branch: branch.ok ? branch.stdout : undefined,\n    status: status.ok ? status.stdout : undefined,\n    lastCommit: lastCommit.ok ? lastCommit.stdout : undefined\n  };\n}\n\n/**\n * Gets the git status for the current workspace.\n * @returns {Promise<GitSummary>} Git status information\n */\nexport async function getGitStatus() {\n  const summary = await getGitSummary();\n  if (!summary.available) {\n    return summary;\n  }\n\n  return { ...summary, status: summary.status ?? '' };\n}\n\n/**\n * Gets the status of all changed files in the current workspace.\n * Parses git porcelain output to determine staged/unstaged state.\n * @returns {Promise<{available: boolean, reason?: string, files: GitFileStatus[]}>} File status information\n */\nexport async function getGitFileStatuses() {\n  const cwd = await getCurrentWorkspacePath();\n  if (!cwd) {\n    return { available: false, reason: 'No workspace selected', files: [] as GitFileStatus[] };\n  }\n\n  const repoCheck = await runGit(['rev-parse', '--is-inside-work-tree'], cwd);\n  if (!repoCheck.ok || repoCheck.stdout !== 'true') {\n    return { available: false, reason: 'Not a git repository', files: [] as GitFileStatus[] };\n  }\n\n  const status = await runGit(['status', '--porcelain=v1'], cwd);\n  if (!status.ok) {\n    return { available: false, reason: status.error ?? 'git status failed', files: [] as GitFileStatus[] };\n  }\n\n  const files = status.stdout\n    .split('\\n')\n    .map((line) => line.trimEnd())\n    .filter(Boolean)\n    .map((line) => {\n      const statusCode = line.slice(0, 2);\n      const rawPath = line.slice(3).trim();\n      const pathPart = rawPath.includes(' -> ')\n        ? rawPath.split(' -> ').slice(-1)[0]\n        : rawPath;\n\n      return {\n        path: pathPart,\n        status: statusCode,\n        staged: statusCode[0] !== ' ',\n        unstaged: statusCode[1] !== ' '\n      };\n    });\n\n  return { available: true, files };\n}\n","/**\n * @fileoverview Git diff module for the main process.\n * Provides functions to retrieve staged and unstaged diffs\n * for the current workspace.\n * @module main/diff\n */\n\nimport { execFile } from 'node:child_process';\nimport { promisify } from 'node:util';\nimport { getCurrentWorkspacePath } from '../workspace';\n\n/** Promisified version of execFile for async git commands */\nconst execFileAsync = promisify(execFile);\n/** Maximum characters to include in diff output before truncation */\nconst MAX_CHARS = 20000;\n\n/**\n * Result of a diff operation.\n */\nexport type DiffResult = {\n  available: boolean;\n  reason?: string;\n  unstaged?: string;\n  staged?: string;\n};\n\n/**\n * Truncates text to the maximum allowed characters.\n * @param {string} text - The text to truncate\n * @returns {string} The truncated text with a message if truncated\n */\nfunction truncate(text: string) {\n  if (text.length <= MAX_CHARS) return text;\n  return `${text.slice(0, MAX_CHARS)}\\n...diff truncated (${text.length - MAX_CHARS} more chars)`;\n}\n\n/**\n * Runs a git diff command with the specified arguments.\n * @param {string[]} args - Arguments to pass to git diff\n * @param {string} cwd - Working directory for the command\n * @returns {Promise<string>} The diff output or error message\n */\nasync function runGitDiff(args: string[], cwd: string) {\n  try {\n    const { stdout } = await execFileAsync('git', args, { cwd });\n    const content = stdout.trim();\n    return content.length === 0 ? '(no changes)' : truncate(content);\n  } catch (error: any) {\n    return `git diff failed: ${error?.stderr?.toString?.() ?? error?.message ?? 'unknown error'}`;\n  }\n}\n\n/**\n * Initializes the diff module.\n * Placeholder for future diff module bootstrapping.\n */\nexport function initDiff() {\n  // Placeholder for future diff module bootstrapping.\n}\n\n/**\n * Checks if the given directory is inside a git repository.\n * @param {string} cwd - Directory path to check\n * @returns {Promise<boolean>} True if inside a git repository\n */\nasync function ensureRepo(cwd: string) {\n  try {\n    await execFileAsync('git', ['rev-parse', '--is-inside-work-tree'], { cwd });\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Gets the diff for all files in the current workspace.\n * Returns both staged and unstaged changes.\n * @returns {Promise<DiffResult>} The diff result with staged and unstaged changes\n */\nexport async function getDiff(): Promise<DiffResult> {\n  const cwd = await getCurrentWorkspacePath();\n  if (!cwd) {\n    return { available: false, reason: 'No workspace selected' };\n  }\n\n  const isRepo = await ensureRepo(cwd);\n  if (!isRepo) {\n    return { available: false, reason: 'Not a git repository' };\n  }\n\n  const unstaged = await runGitDiff(['diff'], cwd);\n  const staged = await runGitDiff(['diff', '--staged'], cwd);\n\n  return {\n    available: true,\n    unstaged,\n    staged\n  };\n}\n\n/**\n * Gets the diff for a specific file in the current workspace.\n * Returns both staged and unstaged changes for the file.\n * @param {string} filePath - Path to the file relative to the repository root\n * @returns {Promise<DiffResult>} The diff result for the specified file\n */\nexport async function getDiffForFile(filePath: string): Promise<DiffResult> {\n  const cwd = await getCurrentWorkspacePath();\n  if (!cwd) {\n    return { available: false, reason: 'No workspace selected' };\n  }\n\n  const isRepo = await ensureRepo(cwd);\n  if (!isRepo) {\n    return { available: false, reason: 'Not a git repository' };\n  }\n\n  const unstaged = await runGitDiff(['diff', '--', filePath], cwd);\n  const staged = await runGitDiff(['diff', '--staged', '--', filePath], cwd);\n\n  return {\n    available: true,\n    unstaged,\n    staged\n  };\n}\n","/**\n * @fileoverview Application event bus for internal event communication.\n * Provides a centralized event emitter for broadcasting app state changes.\n * @module main/events\n */\n\nimport { EventEmitter } from 'node:events';\n\n/**\n * Application event types that can be emitted and listened to.\n */\nexport type AppEvent = 'workspace:changed' | 'git:changed' | 'diff:changed';\n\n/**\n * Event listener callback function type.\n */\ntype Listener = () => void;\n\n/** Internal event emitter instance */\nconst emitter = new EventEmitter();\n\n/**\n * Registers a listener for an application event.\n * @param {AppEvent} event - The event type to listen for\n * @param {Listener} listener - Callback function to invoke when event fires\n * @returns {() => void} Unsubscribe function to remove the listener\n */\nexport function onAppEvent(event: AppEvent, listener: Listener) {\n  emitter.on(event, listener);\n  return () => emitter.off(event, listener);\n}\n\n/**\n * Emits an application event to all registered listeners.\n * @param {AppEvent} event - The event type to emit\n */\nexport function emitAppEvent(event: AppEvent) {\n  emitter.emit(event);\n}\n","'use strict';\n\nconst path = require('path');\nconst WIN_SLASH = '\\\\\\\\/';\nconst WIN_NO_SLASH = `[^${WIN_SLASH}]`;\n\n/**\n * Posix glob regex\n */\n\nconst DOT_LITERAL = '\\\\.';\nconst PLUS_LITERAL = '\\\\+';\nconst QMARK_LITERAL = '\\\\?';\nconst SLASH_LITERAL = '\\\\/';\nconst ONE_CHAR = '(?=.)';\nconst QMARK = '[^/]';\nconst END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;\nconst START_ANCHOR = `(?:^|${SLASH_LITERAL})`;\nconst DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;\nconst NO_DOT = `(?!${DOT_LITERAL})`;\nconst NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;\nconst NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;\nconst NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;\nconst QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;\nconst STAR = `${QMARK}*?`;\n\nconst POSIX_CHARS = {\n  DOT_LITERAL,\n  PLUS_LITERAL,\n  QMARK_LITERAL,\n  SLASH_LITERAL,\n  ONE_CHAR,\n  QMARK,\n  END_ANCHOR,\n  DOTS_SLASH,\n  NO_DOT,\n  NO_DOTS,\n  NO_DOT_SLASH,\n  NO_DOTS_SLASH,\n  QMARK_NO_DOT,\n  STAR,\n  START_ANCHOR\n};\n\n/**\n * Windows glob regex\n */\n\nconst WINDOWS_CHARS = {\n  ...POSIX_CHARS,\n\n  SLASH_LITERAL: `[${WIN_SLASH}]`,\n  QMARK: WIN_NO_SLASH,\n  STAR: `${WIN_NO_SLASH}*?`,\n  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,\n  NO_DOT: `(?!${DOT_LITERAL})`,\n  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,\n  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,\n  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,\n  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`\n};\n\n/**\n * POSIX Bracket Regex\n */\n\nconst POSIX_REGEX_SOURCE = {\n  alnum: 'a-zA-Z0-9',\n  alpha: 'a-zA-Z',\n  ascii: '\\\\x00-\\\\x7F',\n  blank: ' \\\\t',\n  cntrl: '\\\\x00-\\\\x1F\\\\x7F',\n  digit: '0-9',\n  graph: '\\\\x21-\\\\x7E',\n  lower: 'a-z',\n  print: '\\\\x20-\\\\x7E ',\n  punct: '\\\\-!\"#$%&\\'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~',\n  space: ' \\\\t\\\\r\\\\n\\\\v\\\\f',\n  upper: 'A-Z',\n  word: 'A-Za-z0-9_',\n  xdigit: 'A-Fa-f0-9'\n};\n\nmodule.exports = {\n  MAX_LENGTH: 1024 * 64,\n  POSIX_REGEX_SOURCE,\n\n  // regular expressions\n  REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\n  REGEX_NON_SPECIAL_CHARS: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\n  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\n  REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\n  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\n  REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\n\n  // Replace globs with equivalent patterns to reduce parsing time.\n  REPLACEMENTS: {\n    '***': '*',\n    '**/**': '**',\n    '**/**/**': '**'\n  },\n\n  // Digits\n  CHAR_0: 48, /* 0 */\n  CHAR_9: 57, /* 9 */\n\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 65, /* A */\n  CHAR_LOWERCASE_A: 97, /* a */\n  CHAR_UPPERCASE_Z: 90, /* Z */\n  CHAR_LOWERCASE_Z: 122, /* z */\n\n  CHAR_LEFT_PARENTHESES: 40, /* ( */\n  CHAR_RIGHT_PARENTHESES: 41, /* ) */\n\n  CHAR_ASTERISK: 42, /* * */\n\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: 38, /* & */\n  CHAR_AT: 64, /* @ */\n  CHAR_BACKWARD_SLASH: 92, /* \\ */\n  CHAR_CARRIAGE_RETURN: 13, /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */\n  CHAR_COLON: 58, /* : */\n  CHAR_COMMA: 44, /* , */\n  CHAR_DOT: 46, /* . */\n  CHAR_DOUBLE_QUOTE: 34, /* \" */\n  CHAR_EQUAL: 61, /* = */\n  CHAR_EXCLAMATION_MARK: 33, /* ! */\n  CHAR_FORM_FEED: 12, /* \\f */\n  CHAR_FORWARD_SLASH: 47, /* / */\n  CHAR_GRAVE_ACCENT: 96, /* ` */\n  CHAR_HASH: 35, /* # */\n  CHAR_HYPHEN_MINUS: 45, /* - */\n  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */\n  CHAR_LEFT_CURLY_BRACE: 123, /* { */\n  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */\n  CHAR_LINE_FEED: 10, /* \\n */\n  CHAR_NO_BREAK_SPACE: 160, /* \\u00A0 */\n  CHAR_PERCENT: 37, /* % */\n  CHAR_PLUS: 43, /* + */\n  CHAR_QUESTION_MARK: 63, /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */\n  CHAR_RIGHT_CURLY_BRACE: 125, /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */\n  CHAR_SEMICOLON: 59, /* ; */\n  CHAR_SINGLE_QUOTE: 39, /* ' */\n  CHAR_SPACE: 32, /*   */\n  CHAR_TAB: 9, /* \\t */\n  CHAR_UNDERSCORE: 95, /* _ */\n  CHAR_VERTICAL_LINE: 124, /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \\uFEFF */\n\n  SEP: path.sep,\n\n  /**\n   * Create EXTGLOB_CHARS\n   */\n\n  extglobChars(chars) {\n    return {\n      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },\n      '?': { type: 'qmark', open: '(?:', close: ')?' },\n      '+': { type: 'plus', open: '(?:', close: ')+' },\n      '*': { type: 'star', open: '(?:', close: ')*' },\n      '@': { type: 'at', open: '(?:', close: ')' }\n    };\n  },\n\n  /**\n   * Create GLOB_CHARS\n   */\n\n  globChars(win32) {\n    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;\n  }\n};\n","'use strict';\n\nconst path = require('path');\nconst win32 = process.platform === 'win32';\nconst {\n  REGEX_BACKSLASH,\n  REGEX_REMOVE_BACKSLASH,\n  REGEX_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_GLOBAL\n} = require('./constants');\n\nexports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\nexports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);\nexports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);\nexports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\\\$1');\nexports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');\n\nexports.removeBackslashes = str => {\n  return str.replace(REGEX_REMOVE_BACKSLASH, match => {\n    return match === '\\\\' ? '' : match;\n  });\n};\n\nexports.supportsLookbehinds = () => {\n  const segs = process.version.slice(1).split('.').map(Number);\n  if (segs.length === 3 && segs[0] >= 9 || (segs[0] === 8 && segs[1] >= 10)) {\n    return true;\n  }\n  return false;\n};\n\nexports.isWindows = options => {\n  if (options && typeof options.windows === 'boolean') {\n    return options.windows;\n  }\n  return win32 === true || path.sep === '\\\\';\n};\n\nexports.escapeLast = (input, char, lastIdx) => {\n  const idx = input.lastIndexOf(char, lastIdx);\n  if (idx === -1) return input;\n  if (input[idx - 1] === '\\\\') return exports.escapeLast(input, char, idx - 1);\n  return `${input.slice(0, idx)}\\\\${input.slice(idx)}`;\n};\n\nexports.removePrefix = (input, state = {}) => {\n  let output = input;\n  if (output.startsWith('./')) {\n    output = output.slice(2);\n    state.prefix = './';\n  }\n  return output;\n};\n\nexports.wrapOutput = (input, state = {}, options = {}) => {\n  const prepend = options.contains ? '' : '^';\n  const append = options.contains ? '' : '$';\n\n  let output = `${prepend}(?:${input})${append}`;\n  if (state.negated === true) {\n    output = `(?:^(?!${output}).*$)`;\n  }\n  return output;\n};\n","'use strict';\n\nconst utils = require('./utils');\nconst {\n  CHAR_ASTERISK,             /* * */\n  CHAR_AT,                   /* @ */\n  CHAR_BACKWARD_SLASH,       /* \\ */\n  CHAR_COMMA,                /* , */\n  CHAR_DOT,                  /* . */\n  CHAR_EXCLAMATION_MARK,     /* ! */\n  CHAR_FORWARD_SLASH,        /* / */\n  CHAR_LEFT_CURLY_BRACE,     /* { */\n  CHAR_LEFT_PARENTHESES,     /* ( */\n  CHAR_LEFT_SQUARE_BRACKET,  /* [ */\n  CHAR_PLUS,                 /* + */\n  CHAR_QUESTION_MARK,        /* ? */\n  CHAR_RIGHT_CURLY_BRACE,    /* } */\n  CHAR_RIGHT_PARENTHESES,    /* ) */\n  CHAR_RIGHT_SQUARE_BRACKET  /* ] */\n} = require('./constants');\n\nconst isPathSeparator = code => {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n};\n\nconst depth = token => {\n  if (token.isPrefix !== true) {\n    token.depth = token.isGlobstar ? Infinity : 1;\n  }\n};\n\n/**\n * Quickly scans a glob pattern and returns an object with a handful of\n * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),\n * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not\n * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).\n *\n * ```js\n * const pm = require('picomatch');\n * console.log(pm.scan('foo/bar/*.js'));\n * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object} Returns an object with tokens and regex source string.\n * @api public\n */\n\nconst scan = (input, options) => {\n  const opts = options || {};\n\n  const length = input.length - 1;\n  const scanToEnd = opts.parts === true || opts.scanToEnd === true;\n  const slashes = [];\n  const tokens = [];\n  const parts = [];\n\n  let str = input;\n  let index = -1;\n  let start = 0;\n  let lastIndex = 0;\n  let isBrace = false;\n  let isBracket = false;\n  let isGlob = false;\n  let isExtglob = false;\n  let isGlobstar = false;\n  let braceEscaped = false;\n  let backslashes = false;\n  let negated = false;\n  let negatedExtglob = false;\n  let finished = false;\n  let braces = 0;\n  let prev;\n  let code;\n  let token = { value: '', depth: 0, isGlob: false };\n\n  const eos = () => index >= length;\n  const peek = () => str.charCodeAt(index + 1);\n  const advance = () => {\n    prev = code;\n    return str.charCodeAt(++index);\n  };\n\n  while (index < length) {\n    code = advance();\n    let next;\n\n    if (code === CHAR_BACKWARD_SLASH) {\n      backslashes = token.backslashes = true;\n      code = advance();\n\n      if (code === CHAR_LEFT_CURLY_BRACE) {\n        braceEscaped = true;\n      }\n      continue;\n    }\n\n    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {\n      braces++;\n\n      while (eos() !== true && (code = advance())) {\n        if (code === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n\n        if (code === CHAR_LEFT_CURLY_BRACE) {\n          braces++;\n          continue;\n        }\n\n        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n\n        if (braceEscaped !== true && code === CHAR_COMMA) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n\n        if (code === CHAR_RIGHT_CURLY_BRACE) {\n          braces--;\n\n          if (braces === 0) {\n            braceEscaped = false;\n            isBrace = token.isBrace = true;\n            finished = true;\n            break;\n          }\n        }\n      }\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n\n    if (code === CHAR_FORWARD_SLASH) {\n      slashes.push(index);\n      tokens.push(token);\n      token = { value: '', depth: 0, isGlob: false };\n\n      if (finished === true) continue;\n      if (prev === CHAR_DOT && index === (start + 1)) {\n        start += 2;\n        continue;\n      }\n\n      lastIndex = index + 1;\n      continue;\n    }\n\n    if (opts.noext !== true) {\n      const isExtglobChar = code === CHAR_PLUS\n        || code === CHAR_AT\n        || code === CHAR_ASTERISK\n        || code === CHAR_QUESTION_MARK\n        || code === CHAR_EXCLAMATION_MARK;\n\n      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {\n        isGlob = token.isGlob = true;\n        isExtglob = token.isExtglob = true;\n        finished = true;\n        if (code === CHAR_EXCLAMATION_MARK && index === start) {\n          negatedExtglob = true;\n        }\n\n        if (scanToEnd === true) {\n          while (eos() !== true && (code = advance())) {\n            if (code === CHAR_BACKWARD_SLASH) {\n              backslashes = token.backslashes = true;\n              code = advance();\n              continue;\n            }\n\n            if (code === CHAR_RIGHT_PARENTHESES) {\n              isGlob = token.isGlob = true;\n              finished = true;\n              break;\n            }\n          }\n          continue;\n        }\n        break;\n      }\n    }\n\n    if (code === CHAR_ASTERISK) {\n      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;\n      isGlob = token.isGlob = true;\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n\n    if (code === CHAR_QUESTION_MARK) {\n      isGlob = token.isGlob = true;\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n\n    if (code === CHAR_LEFT_SQUARE_BRACKET) {\n      while (eos() !== true && (next = advance())) {\n        if (next === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          isBracket = token.isBracket = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n          break;\n        }\n      }\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n\n    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {\n      negated = token.negated = true;\n      start++;\n      continue;\n    }\n\n    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {\n      isGlob = token.isGlob = true;\n\n      if (scanToEnd === true) {\n        while (eos() !== true && (code = advance())) {\n          if (code === CHAR_LEFT_PARENTHESES) {\n            backslashes = token.backslashes = true;\n            code = advance();\n            continue;\n          }\n\n          if (code === CHAR_RIGHT_PARENTHESES) {\n            finished = true;\n            break;\n          }\n        }\n        continue;\n      }\n      break;\n    }\n\n    if (isGlob === true) {\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n  }\n\n  if (opts.noext === true) {\n    isExtglob = false;\n    isGlob = false;\n  }\n\n  let base = str;\n  let prefix = '';\n  let glob = '';\n\n  if (start > 0) {\n    prefix = str.slice(0, start);\n    str = str.slice(start);\n    lastIndex -= start;\n  }\n\n  if (base && isGlob === true && lastIndex > 0) {\n    base = str.slice(0, lastIndex);\n    glob = str.slice(lastIndex);\n  } else if (isGlob === true) {\n    base = '';\n    glob = str;\n  } else {\n    base = str;\n  }\n\n  if (base && base !== '' && base !== '/' && base !== str) {\n    if (isPathSeparator(base.charCodeAt(base.length - 1))) {\n      base = base.slice(0, -1);\n    }\n  }\n\n  if (opts.unescape === true) {\n    if (glob) glob = utils.removeBackslashes(glob);\n\n    if (base && backslashes === true) {\n      base = utils.removeBackslashes(base);\n    }\n  }\n\n  const state = {\n    prefix,\n    input,\n    start,\n    base,\n    glob,\n    isBrace,\n    isBracket,\n    isGlob,\n    isExtglob,\n    isGlobstar,\n    negated,\n    negatedExtglob\n  };\n\n  if (opts.tokens === true) {\n    state.maxDepth = 0;\n    if (!isPathSeparator(code)) {\n      tokens.push(token);\n    }\n    state.tokens = tokens;\n  }\n\n  if (opts.parts === true || opts.tokens === true) {\n    let prevIndex;\n\n    for (let idx = 0; idx < slashes.length; idx++) {\n      const n = prevIndex ? prevIndex + 1 : start;\n      const i = slashes[idx];\n      const value = input.slice(n, i);\n      if (opts.tokens) {\n        if (idx === 0 && start !== 0) {\n          tokens[idx].isPrefix = true;\n          tokens[idx].value = prefix;\n        } else {\n          tokens[idx].value = value;\n        }\n        depth(tokens[idx]);\n        state.maxDepth += tokens[idx].depth;\n      }\n      if (idx !== 0 || value !== '') {\n        parts.push(value);\n      }\n      prevIndex = i;\n    }\n\n    if (prevIndex && prevIndex + 1 < input.length) {\n      const value = input.slice(prevIndex + 1);\n      parts.push(value);\n\n      if (opts.tokens) {\n        tokens[tokens.length - 1].value = value;\n        depth(tokens[tokens.length - 1]);\n        state.maxDepth += tokens[tokens.length - 1].depth;\n      }\n    }\n\n    state.slashes = slashes;\n    state.parts = parts;\n  }\n\n  return state;\n};\n\nmodule.exports = scan;\n","'use strict';\n\nconst constants = require('./constants');\nconst utils = require('./utils');\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  POSIX_REGEX_SOURCE,\n  REGEX_NON_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_BACKREF,\n  REPLACEMENTS\n} = constants;\n\n/**\n * Helpers\n */\n\nconst expandRange = (args, options) => {\n  if (typeof options.expandRange === 'function') {\n    return options.expandRange(...args, options);\n  }\n\n  args.sort();\n  const value = `[${args.join('-')}]`;\n\n  try {\n    /* eslint-disable-next-line no-new */\n    new RegExp(value);\n  } catch (ex) {\n    return args.map(v => utils.escapeRegex(v)).join('..');\n  }\n\n  return value;\n};\n\n/**\n * Create the message for a syntax error\n */\n\nconst syntaxError = (type, char) => {\n  return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n};\n\n/**\n * Parse the given input string.\n * @param {String} input\n * @param {Object} options\n * @return {Object}\n */\n\nconst parse = (input, options) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  input = REPLACEMENTS[input] || input;\n\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n\n  let len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  const bos = { type: 'bos', value: '', output: opts.prepend || '' };\n  const tokens = [bos];\n\n  const capture = opts.capture ? '' : '?:';\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const PLATFORM_CHARS = constants.globChars(win32);\n  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\n\n  const {\n    DOT_LITERAL,\n    PLUS_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOT_SLASH,\n    NO_DOTS_SLASH,\n    QMARK,\n    QMARK_NO_DOT,\n    STAR,\n    START_ANCHOR\n  } = PLATFORM_CHARS;\n\n  const globstar = opts => {\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const nodot = opts.dot ? '' : NO_DOT;\n  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n  let star = opts.bash === true ? globstar(opts) : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  // minimatch options support\n  if (typeof opts.noext === 'boolean') {\n    opts.noextglob = opts.noext;\n  }\n\n  const state = {\n    input,\n    index: -1,\n    start: 0,\n    dot: opts.dot === true,\n    consumed: '',\n    output: '',\n    prefix: '',\n    backtrack: false,\n    negated: false,\n    brackets: 0,\n    braces: 0,\n    parens: 0,\n    quotes: 0,\n    globstar: false,\n    tokens\n  };\n\n  input = utils.removePrefix(input, state);\n  len = input.length;\n\n  const extglobs = [];\n  const braces = [];\n  const stack = [];\n  let prev = bos;\n  let value;\n\n  /**\n   * Tokenizing helpers\n   */\n\n  const eos = () => state.index === len - 1;\n  const peek = state.peek = (n = 1) => input[state.index + n];\n  const advance = state.advance = () => input[++state.index] || '';\n  const remaining = () => input.slice(state.index + 1);\n  const consume = (value = '', num = 0) => {\n    state.consumed += value;\n    state.index += num;\n  };\n\n  const append = token => {\n    state.output += token.output != null ? token.output : token.value;\n    consume(token.value);\n  };\n\n  const negate = () => {\n    let count = 1;\n\n    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {\n      advance();\n      state.start++;\n      count++;\n    }\n\n    if (count % 2 === 0) {\n      return false;\n    }\n\n    state.negated = true;\n    state.start++;\n    return true;\n  };\n\n  const increment = type => {\n    state[type]++;\n    stack.push(type);\n  };\n\n  const decrement = type => {\n    state[type]--;\n    stack.pop();\n  };\n\n  /**\n   * Push tokens onto the tokens array. This helper speeds up\n   * tokenizing by 1) helping us avoid backtracking as much as possible,\n   * and 2) helping us avoid creating extra tokens when consecutive\n   * characters are plain text. This improves performance and simplifies\n   * lookbehinds.\n   */\n\n  const push = tok => {\n    if (prev.type === 'globstar') {\n      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));\n\n      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n        state.output = state.output.slice(0, -prev.output.length);\n        prev.type = 'star';\n        prev.value = '*';\n        prev.output = star;\n        state.output += prev.output;\n      }\n    }\n\n    if (extglobs.length && tok.type !== 'paren') {\n      extglobs[extglobs.length - 1].inner += tok.value;\n    }\n\n    if (tok.value || tok.output) append(tok);\n    if (prev && prev.type === 'text' && tok.type === 'text') {\n      prev.value += tok.value;\n      prev.output = (prev.output || '') + tok.value;\n      return;\n    }\n\n    tok.prev = prev;\n    tokens.push(tok);\n    prev = tok;\n  };\n\n  const extglobOpen = (type, value) => {\n    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };\n\n    token.prev = prev;\n    token.parens = state.parens;\n    token.output = state.output;\n    const output = (opts.capture ? '(' : '') + token.open;\n\n    increment('parens');\n    push({ type, value, output: state.output ? '' : ONE_CHAR });\n    push({ type: 'paren', extglob: true, value: advance(), output });\n    extglobs.push(token);\n  };\n\n  const extglobClose = token => {\n    let output = token.close + (opts.capture ? ')' : '');\n    let rest;\n\n    if (token.type === 'negate') {\n      let extglobStar = star;\n\n      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n        extglobStar = globstar(opts);\n      }\n\n      if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\n        output = token.close = `)$))${extglobStar}`;\n      }\n\n      if (token.inner.includes('*') && (rest = remaining()) && /^\\.[^\\\\/.]+$/.test(rest)) {\n        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.\n        // In this case, we need to parse the string and use it in the output of the original pattern.\n        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.\n        //\n        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.\n        const expression = parse(rest, { ...options, fastpaths: false }).output;\n\n        output = token.close = `)${expression})${extglobStar})`;\n      }\n\n      if (token.prev.type === 'bos') {\n        state.negatedExtglob = true;\n      }\n    }\n\n    push({ type: 'paren', extglob: true, value, output });\n    decrement('parens');\n  };\n\n  /**\n   * Fast paths\n   */\n\n  if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\n    let backslashes = false;\n\n    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n      if (first === '\\\\') {\n        backslashes = true;\n        return m;\n      }\n\n      if (first === '?') {\n        if (esc) {\n          return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        if (index === 0) {\n          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        return QMARK.repeat(chars.length);\n      }\n\n      if (first === '.') {\n        return DOT_LITERAL.repeat(chars.length);\n      }\n\n      if (first === '*') {\n        if (esc) {\n          return esc + first + (rest ? star : '');\n        }\n        return star;\n      }\n      return esc ? m : `\\\\${m}`;\n    });\n\n    if (backslashes === true) {\n      if (opts.unescape === true) {\n        output = output.replace(/\\\\/g, '');\n      } else {\n        output = output.replace(/\\\\+/g, m => {\n          return m.length % 2 === 0 ? '\\\\\\\\' : (m ? '\\\\' : '');\n        });\n      }\n    }\n\n    if (output === input && opts.contains === true) {\n      state.output = input;\n      return state;\n    }\n\n    state.output = utils.wrapOutput(output, state, options);\n    return state;\n  }\n\n  /**\n   * Tokenize input until we reach end-of-string\n   */\n\n  while (!eos()) {\n    value = advance();\n\n    if (value === '\\u0000') {\n      continue;\n    }\n\n    /**\n     * Escaped characters\n     */\n\n    if (value === '\\\\') {\n      const next = peek();\n\n      if (next === '/' && opts.bash !== true) {\n        continue;\n      }\n\n      if (next === '.' || next === ';') {\n        continue;\n      }\n\n      if (!next) {\n        value += '\\\\';\n        push({ type: 'text', value });\n        continue;\n      }\n\n      // collapse slashes to reduce potential for exploits\n      const match = /^\\\\+/.exec(remaining());\n      let slashes = 0;\n\n      if (match && match[0].length > 2) {\n        slashes = match[0].length;\n        state.index += slashes;\n        if (slashes % 2 !== 0) {\n          value += '\\\\';\n        }\n      }\n\n      if (opts.unescape === true) {\n        value = advance();\n      } else {\n        value += advance();\n      }\n\n      if (state.brackets === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n    }\n\n    /**\n     * If we're inside a regex character class, continue\n     * until we reach the closing bracket.\n     */\n\n    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n      if (opts.posix !== false && value === ':') {\n        const inner = prev.value.slice(1);\n        if (inner.includes('[')) {\n          prev.posix = true;\n\n          if (inner.includes(':')) {\n            const idx = prev.value.lastIndexOf('[');\n            const pre = prev.value.slice(0, idx);\n            const rest = prev.value.slice(idx + 2);\n            const posix = POSIX_REGEX_SOURCE[rest];\n            if (posix) {\n              prev.value = pre + posix;\n              state.backtrack = true;\n              advance();\n\n              if (!bos.output && tokens.indexOf(prev) === 1) {\n                bos.output = ONE_CHAR;\n              }\n              continue;\n            }\n          }\n        }\n      }\n\n      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {\n        value = `\\\\${value}`;\n      }\n\n      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n        value = `\\\\${value}`;\n      }\n\n      if (opts.posix === true && value === '!' && prev.value === '[') {\n        value = '^';\n      }\n\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * If we're inside a quoted string, continue\n     * until we reach the closing double quote.\n     */\n\n    if (state.quotes === 1 && value !== '\"') {\n      value = utils.escapeRegex(value);\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * Double quotes\n     */\n\n    if (value === '\"') {\n      state.quotes = state.quotes === 1 ? 0 : 1;\n      if (opts.keepQuotes === true) {\n        push({ type: 'text', value });\n      }\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === '(') {\n      increment('parens');\n      push({ type: 'paren', value });\n      continue;\n    }\n\n    if (value === ')') {\n      if (state.parens === 0 && opts.strictBrackets === true) {\n        throw new SyntaxError(syntaxError('opening', '('));\n      }\n\n      const extglob = extglobs[extglobs.length - 1];\n      if (extglob && state.parens === extglob.parens + 1) {\n        extglobClose(extglobs.pop());\n        continue;\n      }\n\n      push({ type: 'paren', value, output: state.parens ? ')' : '\\\\)' });\n      decrement('parens');\n      continue;\n    }\n\n    /**\n     * Square brackets\n     */\n\n    if (value === '[') {\n      if (opts.nobracket === true || !remaining().includes(']')) {\n        if (opts.nobracket !== true && opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('closing', ']'));\n        }\n\n        value = `\\\\${value}`;\n      } else {\n        increment('brackets');\n      }\n\n      push({ type: 'bracket', value });\n      continue;\n    }\n\n    if (value === ']') {\n      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      if (state.brackets === 0) {\n        if (opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('opening', '['));\n        }\n\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      decrement('brackets');\n\n      const prevValue = prev.value.slice(1);\n      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n        value = `/${value}`;\n      }\n\n      prev.value += value;\n      append({ value });\n\n      // when literal brackets are explicitly disabled\n      // assume we should match with a regex character class\n      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\n        continue;\n      }\n\n      const escaped = utils.escapeRegex(prev.value);\n      state.output = state.output.slice(0, -prev.value.length);\n\n      // when literal brackets are explicitly enabled\n      // assume we should escape the brackets to match literal characters\n      if (opts.literalBrackets === true) {\n        state.output += escaped;\n        prev.value = escaped;\n        continue;\n      }\n\n      // when the user specifies nothing, try to match both\n      prev.value = `(${capture}${escaped}|${prev.value})`;\n      state.output += prev.value;\n      continue;\n    }\n\n    /**\n     * Braces\n     */\n\n    if (value === '{' && opts.nobrace !== true) {\n      increment('braces');\n\n      const open = {\n        type: 'brace',\n        value,\n        output: '(',\n        outputIndex: state.output.length,\n        tokensIndex: state.tokens.length\n      };\n\n      braces.push(open);\n      push(open);\n      continue;\n    }\n\n    if (value === '}') {\n      const brace = braces[braces.length - 1];\n\n      if (opts.nobrace === true || !brace) {\n        push({ type: 'text', value, output: value });\n        continue;\n      }\n\n      let output = ')';\n\n      if (brace.dots === true) {\n        const arr = tokens.slice();\n        const range = [];\n\n        for (let i = arr.length - 1; i >= 0; i--) {\n          tokens.pop();\n          if (arr[i].type === 'brace') {\n            break;\n          }\n          if (arr[i].type !== 'dots') {\n            range.unshift(arr[i].value);\n          }\n        }\n\n        output = expandRange(range, opts);\n        state.backtrack = true;\n      }\n\n      if (brace.comma !== true && brace.dots !== true) {\n        const out = state.output.slice(0, brace.outputIndex);\n        const toks = state.tokens.slice(brace.tokensIndex);\n        brace.value = brace.output = '\\\\{';\n        value = output = '\\\\}';\n        state.output = out;\n        for (const t of toks) {\n          state.output += (t.output || t.value);\n        }\n      }\n\n      push({ type: 'brace', value, output });\n      decrement('braces');\n      braces.pop();\n      continue;\n    }\n\n    /**\n     * Pipes\n     */\n\n    if (value === '|') {\n      if (extglobs.length > 0) {\n        extglobs[extglobs.length - 1].conditions++;\n      }\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Commas\n     */\n\n    if (value === ',') {\n      let output = value;\n\n      const brace = braces[braces.length - 1];\n      if (brace && stack[stack.length - 1] === 'braces') {\n        brace.comma = true;\n        output = '|';\n      }\n\n      push({ type: 'comma', value, output });\n      continue;\n    }\n\n    /**\n     * Slashes\n     */\n\n    if (value === '/') {\n      // if the beginning of the glob is \"./\", advance the start\n      // to the current index, and don't add the \"./\" characters\n      // to the state. This greatly simplifies lookbehinds when\n      // checking for BOS characters like \"!\" and \".\" (not \"./\")\n      if (prev.type === 'dot' && state.index === state.start + 1) {\n        state.start = state.index + 1;\n        state.consumed = '';\n        state.output = '';\n        tokens.pop();\n        prev = bos; // reset \"prev\" to the first token\n        continue;\n      }\n\n      push({ type: 'slash', value, output: SLASH_LITERAL });\n      continue;\n    }\n\n    /**\n     * Dots\n     */\n\n    if (value === '.') {\n      if (state.braces > 0 && prev.type === 'dot') {\n        if (prev.value === '.') prev.output = DOT_LITERAL;\n        const brace = braces[braces.length - 1];\n        prev.type = 'dots';\n        prev.output += value;\n        prev.value += value;\n        brace.dots = true;\n        continue;\n      }\n\n      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {\n        push({ type: 'text', value, output: DOT_LITERAL });\n        continue;\n      }\n\n      push({ type: 'dot', value, output: DOT_LITERAL });\n      continue;\n    }\n\n    /**\n     * Question marks\n     */\n\n    if (value === '?') {\n      const isGroup = prev && prev.value === '(';\n      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('qmark', value);\n        continue;\n      }\n\n      if (prev && prev.type === 'paren') {\n        const next = peek();\n        let output = value;\n\n        if (next === '<' && !utils.supportsLookbehinds()) {\n          throw new Error('Node.js v10 or higher is required for regex lookbehinds');\n        }\n\n        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\\w+>)/.test(remaining()))) {\n          output = `\\\\${value}`;\n        }\n\n        push({ type: 'text', value, output });\n        continue;\n      }\n\n      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n        push({ type: 'qmark', value, output: QMARK_NO_DOT });\n        continue;\n      }\n\n      push({ type: 'qmark', value, output: QMARK });\n      continue;\n    }\n\n    /**\n     * Exclamation\n     */\n\n    if (value === '!') {\n      if (opts.noextglob !== true && peek() === '(') {\n        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n          extglobOpen('negate', value);\n          continue;\n        }\n      }\n\n      if (opts.nonegate !== true && state.index === 0) {\n        negate();\n        continue;\n      }\n    }\n\n    /**\n     * Plus\n     */\n\n    if (value === '+') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('plus', value);\n        continue;\n      }\n\n      if ((prev && prev.value === '(') || opts.regex === false) {\n        push({ type: 'plus', value, output: PLUS_LITERAL });\n        continue;\n      }\n\n      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {\n        push({ type: 'plus', value });\n        continue;\n      }\n\n      push({ type: 'plus', value: PLUS_LITERAL });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value === '@') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        push({ type: 'at', extglob: true, value, output: '' });\n        continue;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value !== '*') {\n      if (value === '$' || value === '^') {\n        value = `\\\\${value}`;\n      }\n\n      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\n      if (match) {\n        value += match[0];\n        state.index += match[0].length;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Stars\n     */\n\n    if (prev && (prev.type === 'globstar' || prev.star === true)) {\n      prev.type = 'star';\n      prev.star = true;\n      prev.value += value;\n      prev.output = star;\n      state.backtrack = true;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    let rest = remaining();\n    if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\n      extglobOpen('star', value);\n      continue;\n    }\n\n    if (prev.type === 'star') {\n      if (opts.noglobstar === true) {\n        consume(value);\n        continue;\n      }\n\n      const prior = prev.prev;\n      const before = prior.prev;\n      const isStart = prior.type === 'slash' || prior.type === 'bos';\n      const afterStar = before && (before.type === 'star' || before.type === 'globstar');\n\n      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      // strip consecutive `/**/`\n      while (rest.slice(0, 3) === '/**') {\n        const after = input[state.index + 4];\n        if (after && after !== '/') {\n          break;\n        }\n        rest = rest.slice(3);\n        consume('/**', 3);\n      }\n\n      if (prior.type === 'bos' && eos()) {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = globstar(opts);\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');\n        prev.value += value;\n        state.globstar = true;\n        state.output += prior.output + prev.output;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {\n        const end = rest[1] !== void 0 ? '|$' : '';\n\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n        prev.value += value;\n\n        state.output += prior.output + prev.output;\n        state.globstar = true;\n\n        consume(value + advance());\n\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      if (prior.type === 'bos' && rest[0] === '/') {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value + advance());\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      // remove single star from output\n      state.output = state.output.slice(0, -prev.output.length);\n\n      // reset previous token to globstar\n      prev.type = 'globstar';\n      prev.output = globstar(opts);\n      prev.value += value;\n\n      // reset output with globstar\n      state.output += prev.output;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    const token = { type: 'star', value, output: star };\n\n    if (opts.bash === true) {\n      token.output = '.*?';\n      if (prev.type === 'bos' || prev.type === 'slash') {\n        token.output = nodot + token.output;\n      }\n      push(token);\n      continue;\n    }\n\n    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n      token.output = value;\n      push(token);\n      continue;\n    }\n\n    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n      if (prev.type === 'dot') {\n        state.output += NO_DOT_SLASH;\n        prev.output += NO_DOT_SLASH;\n\n      } else if (opts.dot === true) {\n        state.output += NO_DOTS_SLASH;\n        prev.output += NO_DOTS_SLASH;\n\n      } else {\n        state.output += nodot;\n        prev.output += nodot;\n      }\n\n      if (peek() !== '*') {\n        state.output += ONE_CHAR;\n        prev.output += ONE_CHAR;\n      }\n    }\n\n    push(token);\n  }\n\n  while (state.brackets > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\n    state.output = utils.escapeLast(state.output, '[');\n    decrement('brackets');\n  }\n\n  while (state.parens > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\n    state.output = utils.escapeLast(state.output, '(');\n    decrement('parens');\n  }\n\n  while (state.braces > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\n    state.output = utils.escapeLast(state.output, '{');\n    decrement('braces');\n  }\n\n  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });\n  }\n\n  // rebuild the output if we had to backtrack at any point\n  if (state.backtrack === true) {\n    state.output = '';\n\n    for (const token of state.tokens) {\n      state.output += token.output != null ? token.output : token.value;\n\n      if (token.suffix) {\n        state.output += token.suffix;\n      }\n    }\n  }\n\n  return state;\n};\n\n/**\n * Fast paths for creating regular expressions for common glob patterns.\n * This can significantly speed up processing and has very little downside\n * impact when none of the fast paths match.\n */\n\nparse.fastpaths = (input, options) => {\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  const len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  input = REPLACEMENTS[input] || input;\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const {\n    DOT_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOTS,\n    NO_DOTS_SLASH,\n    STAR,\n    START_ANCHOR\n  } = constants.globChars(win32);\n\n  const nodot = opts.dot ? NO_DOTS : NO_DOT;\n  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n  const capture = opts.capture ? '' : '?:';\n  const state = { negated: false, prefix: '' };\n  let star = opts.bash === true ? '.*?' : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  const globstar = opts => {\n    if (opts.noglobstar === true) return star;\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const create = str => {\n    switch (str) {\n      case '*':\n        return `${nodot}${ONE_CHAR}${star}`;\n\n      case '.*':\n        return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*.*':\n        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*/*':\n        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n\n      case '**':\n        return nodot + globstar(opts);\n\n      case '**/*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n\n      case '**/*.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '**/.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      default: {\n        const match = /^(.*?)\\.(\\w+)$/.exec(str);\n        if (!match) return;\n\n        const source = create(match[1]);\n        if (!source) return;\n\n        return source + DOT_LITERAL + match[2];\n      }\n    }\n  };\n\n  const output = utils.removePrefix(input, state);\n  let source = create(output);\n\n  if (source && opts.strictSlashes !== true) {\n    source += `${SLASH_LITERAL}?`;\n  }\n\n  return source;\n};\n\nmodule.exports = parse;\n","'use strict';\n\nconst path = require('path');\nconst scan = require('./scan');\nconst parse = require('./parse');\nconst utils = require('./utils');\nconst constants = require('./constants');\nconst isObject = val => val && typeof val === 'object' && !Array.isArray(val);\n\n/**\n * Creates a matcher function from one or more glob patterns. The\n * returned function takes a string to match as its first argument,\n * and returns true if the string is a match. The returned matcher\n * function also takes a boolean as the second argument that, when true,\n * returns an object with additional information.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch(glob[, options]);\n *\n * const isMatch = picomatch('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @name picomatch\n * @param {String|Array} `globs` One or more glob patterns.\n * @param {Object=} `options`\n * @return {Function=} Returns a matcher function.\n * @api public\n */\n\nconst picomatch = (glob, options, returnState = false) => {\n  if (Array.isArray(glob)) {\n    const fns = glob.map(input => picomatch(input, options, returnState));\n    const arrayMatcher = str => {\n      for (const isMatch of fns) {\n        const state = isMatch(str);\n        if (state) return state;\n      }\n      return false;\n    };\n    return arrayMatcher;\n  }\n\n  const isState = isObject(glob) && glob.tokens && glob.input;\n\n  if (glob === '' || (typeof glob !== 'string' && !isState)) {\n    throw new TypeError('Expected pattern to be a non-empty string');\n  }\n\n  const opts = options || {};\n  const posix = utils.isWindows(options);\n  const regex = isState\n    ? picomatch.compileRe(glob, options)\n    : picomatch.makeRe(glob, options, false, true);\n\n  const state = regex.state;\n  delete regex.state;\n\n  let isIgnored = () => false;\n  if (opts.ignore) {\n    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };\n    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\n  }\n\n  const matcher = (input, returnObject = false) => {\n    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });\n    const result = { glob, state, regex, posix, input, output, match, isMatch };\n\n    if (typeof opts.onResult === 'function') {\n      opts.onResult(result);\n    }\n\n    if (isMatch === false) {\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (isIgnored(input)) {\n      if (typeof opts.onIgnore === 'function') {\n        opts.onIgnore(result);\n      }\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (typeof opts.onMatch === 'function') {\n      opts.onMatch(result);\n    }\n    return returnObject ? result : true;\n  };\n\n  if (returnState) {\n    matcher.state = state;\n  }\n\n  return matcher;\n};\n\n/**\n * Test `input` with the given `regex`. This is used by the main\n * `picomatch()` function to test the input string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.test(input, regex[, options]);\n *\n * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\\/([^/]*?))$/));\n * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp} `regex`\n * @return {Object} Returns an object with matching info.\n * @api public\n */\n\npicomatch.test = (input, regex, options, { glob, posix } = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected input to be a string');\n  }\n\n  if (input === '') {\n    return { isMatch: false, output: '' };\n  }\n\n  const opts = options || {};\n  const format = opts.format || (posix ? utils.toPosixSlashes : null);\n  let match = input === glob;\n  let output = (match && format) ? format(input) : input;\n\n  if (match === false) {\n    output = format ? format(input) : input;\n    match = output === glob;\n  }\n\n  if (match === false || opts.capture === true) {\n    if (opts.matchBase === true || opts.basename === true) {\n      match = picomatch.matchBase(input, regex, options, posix);\n    } else {\n      match = regex.exec(output);\n    }\n  }\n\n  return { isMatch: Boolean(match), match, output };\n};\n\n/**\n * Match the basename of a filepath.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.matchBase(input, glob[, options]);\n * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).\n * @return {Boolean}\n * @api public\n */\n\npicomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {\n  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\n  return regex.test(path.basename(input));\n};\n\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.isMatch(string, patterns[, options]);\n *\n * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String|Array} str The string to test.\n * @param {String|Array} patterns One or more glob patterns to use for matching.\n * @param {Object} [options] See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\npicomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const result = picomatch.parse(pattern[, options]);\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as a regex source string.\n * @api public\n */\n\npicomatch.parse = (pattern, options) => {\n  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));\n  return parse(pattern, { ...options, fastpaths: false });\n};\n\n/**\n * Scan a glob pattern to separate the pattern into segments.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.scan(input[, options]);\n *\n * const result = picomatch.scan('!./foo/*.js');\n * console.log(result);\n * { prefix: '!./',\n *   input: '!./foo/*.js',\n *   start: 3,\n *   base: 'foo',\n *   glob: '*.js',\n *   isBrace: false,\n *   isBracket: false,\n *   isGlob: true,\n *   isExtglob: false,\n *   isGlobstar: false,\n *   negated: true }\n * ```\n * @param {String} `input` Glob pattern to scan.\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\n\npicomatch.scan = (input, options) => scan(input, options);\n\n/**\n * Compile a regular expression from the `state` object returned by the\n * [parse()](#parse) method.\n *\n * @param {Object} `state`\n * @param {Object} `options`\n * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.\n * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.\n * @return {RegExp}\n * @api public\n */\n\npicomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {\n  if (returnOutput === true) {\n    return state.output;\n  }\n\n  const opts = options || {};\n  const prepend = opts.contains ? '' : '^';\n  const append = opts.contains ? '' : '$';\n\n  let source = `${prepend}(?:${state.output})${append}`;\n  if (state && state.negated === true) {\n    source = `^(?!${source}).*$`;\n  }\n\n  const regex = picomatch.toRegex(source, options);\n  if (returnState === true) {\n    regex.state = state;\n  }\n\n  return regex;\n};\n\n/**\n * Create a regular expression from a parsed glob pattern.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const state = picomatch.parse('*.js');\n * // picomatch.compileRe(state[, options]);\n *\n * console.log(picomatch.compileRe(state));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `state` The object returned from the `.parse` method.\n * @param {Object} `options`\n * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.\n * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\npicomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {\n  if (!input || typeof input !== 'string') {\n    throw new TypeError('Expected a non-empty string');\n  }\n\n  let parsed = { negated: false, fastpaths: true };\n\n  if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {\n    parsed.output = parse.fastpaths(input, options);\n  }\n\n  if (!parsed.output) {\n    parsed = parse(input, options);\n  }\n\n  return picomatch.compileRe(parsed, options, returnOutput, returnState);\n};\n\n/**\n * Create a regular expression from the given regex source string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.toRegex(source[, options]);\n *\n * const { output } = picomatch.parse('*.js');\n * console.log(picomatch.toRegex(output));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `source` Regular expression source string.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\n\npicomatch.toRegex = (source, options) => {\n  try {\n    const opts = options || {};\n    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));\n  } catch (err) {\n    if (options && options.debug === true) throw err;\n    return /$^/;\n  }\n};\n\n/**\n * Picomatch constants.\n * @return {Object}\n */\n\npicomatch.constants = constants;\n\n/**\n * Expose \"picomatch\"\n */\n\nmodule.exports = picomatch;\n","'use strict';\n\nmodule.exports = require('./lib/picomatch');\n","'use strict';\n\nconst fs = require('fs');\nconst { Readable } = require('stream');\nconst sysPath = require('path');\nconst { promisify } = require('util');\nconst picomatch = require('picomatch');\n\nconst readdir = promisify(fs.readdir);\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\nconst realpath = promisify(fs.realpath);\n\n/**\n * @typedef {Object} EntryInfo\n * @property {String} path\n * @property {String} fullPath\n * @property {fs.Stats=} stats\n * @property {fs.Dirent=} dirent\n * @property {String} basename\n */\n\nconst BANG = '!';\nconst RECURSIVE_ERROR_CODE = 'READDIRP_RECURSIVE_ERROR';\nconst NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP', RECURSIVE_ERROR_CODE]);\nconst FILE_TYPE = 'files';\nconst DIR_TYPE = 'directories';\nconst FILE_DIR_TYPE = 'files_directories';\nconst EVERYTHING_TYPE = 'all';\nconst ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];\n\nconst isNormalFlowError = error => NORMAL_FLOW_ERRORS.has(error.code);\nconst [maj, min] = process.versions.node.split('.').slice(0, 2).map(n => Number.parseInt(n, 10));\nconst wantBigintFsStats = process.platform === 'win32' && (maj > 10 || (maj === 10 && min >= 5));\n\nconst normalizeFilter = filter => {\n  if (filter === undefined) return;\n  if (typeof filter === 'function') return filter;\n\n  if (typeof filter === 'string') {\n    const glob = picomatch(filter.trim());\n    return entry => glob(entry.basename);\n  }\n\n  if (Array.isArray(filter)) {\n    const positive = [];\n    const negative = [];\n    for (const item of filter) {\n      const trimmed = item.trim();\n      if (trimmed.charAt(0) === BANG) {\n        negative.push(picomatch(trimmed.slice(1)));\n      } else {\n        positive.push(picomatch(trimmed));\n      }\n    }\n\n    if (negative.length > 0) {\n      if (positive.length > 0) {\n        return entry =>\n          positive.some(f => f(entry.basename)) && !negative.some(f => f(entry.basename));\n      }\n      return entry => !negative.some(f => f(entry.basename));\n    }\n    return entry => positive.some(f => f(entry.basename));\n  }\n};\n\nclass ReaddirpStream extends Readable {\n  static get defaultOptions() {\n    return {\n      root: '.',\n      /* eslint-disable no-unused-vars */\n      fileFilter: (path) => true,\n      directoryFilter: (path) => true,\n      /* eslint-enable no-unused-vars */\n      type: FILE_TYPE,\n      lstat: false,\n      depth: 2147483648,\n      alwaysStat: false\n    };\n  }\n\n  constructor(options = {}) {\n    super({\n      objectMode: true,\n      autoDestroy: true,\n      highWaterMark: options.highWaterMark || 4096\n    });\n    const opts = { ...ReaddirpStream.defaultOptions, ...options };\n    const { root, type } = opts;\n\n    this._fileFilter = normalizeFilter(opts.fileFilter);\n    this._directoryFilter = normalizeFilter(opts.directoryFilter);\n\n    const statMethod = opts.lstat ? lstat : stat;\n    // Use bigint stats if it's windows and stat() supports options (node 10+).\n    if (wantBigintFsStats) {\n      this._stat = path => statMethod(path, { bigint: true });\n    } else {\n      this._stat = statMethod;\n    }\n\n    this._maxDepth = opts.depth;\n    this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsEverything = type === EVERYTHING_TYPE;\n    this._root = sysPath.resolve(root);\n    this._isDirent = ('Dirent' in fs) && !opts.alwaysStat;\n    this._statsProp = this._isDirent ? 'dirent' : 'stats';\n    this._rdOptions = { encoding: 'utf8', withFileTypes: this._isDirent };\n\n    // Launch stream with one parent, the root dir.\n    this.parents = [this._exploreDir(root, 1)];\n    this.reading = false;\n    this.parent = undefined;\n  }\n\n  async _read(batch) {\n    if (this.reading) return;\n    this.reading = true;\n\n    try {\n      while (!this.destroyed && batch > 0) {\n        const { path, depth, files = [] } = this.parent || {};\n\n        if (files.length > 0) {\n          const slice = files.splice(0, batch).map(dirent => this._formatEntry(dirent, path));\n          for (const entry of await Promise.all(slice)) {\n            if (this.destroyed) return;\n\n            const entryType = await this._getEntryType(entry);\n            if (entryType === 'directory' && this._directoryFilter(entry)) {\n              if (depth <= this._maxDepth) {\n                this.parents.push(this._exploreDir(entry.fullPath, depth + 1));\n              }\n\n              if (this._wantsDir) {\n                this.push(entry);\n                batch--;\n              }\n            } else if ((entryType === 'file' || this._includeAsFile(entry)) && this._fileFilter(entry)) {\n              if (this._wantsFile) {\n                this.push(entry);\n                batch--;\n              }\n            }\n          }\n        } else {\n          const parent = this.parents.pop();\n          if (!parent) {\n            this.push(null);\n            break;\n          }\n          this.parent = await parent;\n          if (this.destroyed) return;\n        }\n      }\n    } catch (error) {\n      this.destroy(error);\n    } finally {\n      this.reading = false;\n    }\n  }\n\n  async _exploreDir(path, depth) {\n    let files;\n    try {\n      files = await readdir(path, this._rdOptions);\n    } catch (error) {\n      this._onError(error);\n    }\n    return { files, depth, path };\n  }\n\n  async _formatEntry(dirent, path) {\n    let entry;\n    try {\n      const basename = this._isDirent ? dirent.name : dirent;\n      const fullPath = sysPath.resolve(sysPath.join(path, basename));\n      entry = { path: sysPath.relative(this._root, fullPath), fullPath, basename };\n      entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);\n    } catch (err) {\n      this._onError(err);\n    }\n    return entry;\n  }\n\n  _onError(err) {\n    if (isNormalFlowError(err) && !this.destroyed) {\n      this.emit('warn', err);\n    } else {\n      this.destroy(err);\n    }\n  }\n\n  async _getEntryType(entry) {\n    // entry may be undefined, because a warning or an error were emitted\n    // and the statsProp is undefined\n    const stats = entry && entry[this._statsProp];\n    if (!stats) {\n      return;\n    }\n    if (stats.isFile()) {\n      return 'file';\n    }\n    if (stats.isDirectory()) {\n      return 'directory';\n    }\n    if (stats && stats.isSymbolicLink()) {\n      const full = entry.fullPath;\n      try {\n        const entryRealPath = await realpath(full);\n        const entryRealPathStats = await lstat(entryRealPath);\n        if (entryRealPathStats.isFile()) {\n          return 'file';\n        }\n        if (entryRealPathStats.isDirectory()) {\n          const len = entryRealPath.length;\n          if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath.sep) {\n            const recursiveError = new Error(\n              `Circular symlink detected: \"${full}\" points to \"${entryRealPath}\"`\n            );\n            recursiveError.code = RECURSIVE_ERROR_CODE;\n            return this._onError(recursiveError);\n          }\n          return 'directory';\n        }\n      } catch (error) {\n        this._onError(error);\n      }\n    }\n  }\n\n  _includeAsFile(entry) {\n    const stats = entry && entry[this._statsProp];\n\n    return stats && this._wantsEverything && !stats.isDirectory();\n  }\n}\n\n/**\n * @typedef {Object} ReaddirpArguments\n * @property {Function=} fileFilter\n * @property {Function=} directoryFilter\n * @property {String=} type\n * @property {Number=} depth\n * @property {String=} root\n * @property {Boolean=} lstat\n * @property {Boolean=} bigint\n */\n\n/**\n * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.\n * @param {String} root Root directory\n * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth\n */\nconst readdirp = (root, options = {}) => {\n  let type = options.entryType || options.type;\n  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility\n  if (type) options.type = type;\n  if (!root) {\n    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');\n  } else if (typeof root !== 'string') {\n    throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');\n  } else if (type && !ALL_TYPES.includes(type)) {\n    throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);\n  }\n\n  options.root = root;\n  return new ReaddirpStream(options);\n};\n\nconst readdirpPromise = (root, options = {}) => {\n  return new Promise((resolve, reject) => {\n    const files = [];\n    readdirp(root, options)\n      .on('data', entry => files.push(entry))\n      .on('end', () => resolve(files))\n      .on('error', error => reject(error));\n  });\n};\n\nreaddirp.promise = readdirpPromise;\nreaddirp.ReaddirpStream = ReaddirpStream;\nreaddirp.default = readdirp;\n\nmodule.exports = readdirp;\n","/*!\n * normalize-path <https://github.com/jonschlinkert/normalize-path>\n *\n * Copyright (c) 2014-2018, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nmodule.exports = function(path, stripTrailing) {\n  if (typeof path !== 'string') {\n    throw new TypeError('expected path to be a string');\n  }\n\n  if (path === '\\\\' || path === '/') return '/';\n\n  var len = path.length;\n  if (len <= 1) return path;\n\n  // ensure that win32 namespaces has two leading slashes, so that the path is\n  // handled properly by the win32 version of path.parse() after being normalized\n  // https://msdn.microsoft.com/library/windows/desktop/aa365247(v=vs.85).aspx#namespaces\n  var prefix = '';\n  if (len > 4 && path[3] === '\\\\') {\n    var ch = path[2];\n    if ((ch === '?' || ch === '.') && path.slice(0, 2) === '\\\\\\\\') {\n      path = path.slice(2);\n      prefix = '//';\n    }\n  }\n\n  var segs = path.split(/[/\\\\]+/);\n  if (stripTrailing !== false && segs[segs.length - 1] === '') {\n    segs.pop();\n  }\n  return prefix + segs.join('/');\n};\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nconst picomatch = require('picomatch');\nconst normalizePath = require('normalize-path');\n\n/**\n * @typedef {(testString: string) => boolean} AnymatchFn\n * @typedef {string|RegExp|AnymatchFn} AnymatchPattern\n * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher\n */\nconst BANG = '!';\nconst DEFAULT_OPTIONS = {returnIndex: false};\nconst arrify = (item) => Array.isArray(item) ? item : [item];\n\n/**\n * @param {AnymatchPattern} matcher\n * @param {object} options\n * @returns {AnymatchFn}\n */\nconst createPattern = (matcher, options) => {\n  if (typeof matcher === 'function') {\n    return matcher;\n  }\n  if (typeof matcher === 'string') {\n    const glob = picomatch(matcher, options);\n    return (string) => matcher === string || glob(string);\n  }\n  if (matcher instanceof RegExp) {\n    return (string) => matcher.test(string);\n  }\n  return (string) => false;\n};\n\n/**\n * @param {Array<Function>} patterns\n * @param {Array<Function>} negPatterns\n * @param {String|Array} args\n * @param {Boolean} returnIndex\n * @returns {boolean|number}\n */\nconst matchPatterns = (patterns, negPatterns, args, returnIndex) => {\n  const isList = Array.isArray(args);\n  const _path = isList ? args[0] : args;\n  if (!isList && typeof _path !== 'string') {\n    throw new TypeError('anymatch: second argument must be a string: got ' +\n      Object.prototype.toString.call(_path))\n  }\n  const path = normalizePath(_path, false);\n\n  for (let index = 0; index < negPatterns.length; index++) {\n    const nglob = negPatterns[index];\n    if (nglob(path)) {\n      return returnIndex ? -1 : false;\n    }\n  }\n\n  const applied = isList && [path].concat(args.slice(1));\n  for (let index = 0; index < patterns.length; index++) {\n    const pattern = patterns[index];\n    if (isList ? pattern(...applied) : pattern(path)) {\n      return returnIndex ? index : true;\n    }\n  }\n\n  return returnIndex ? -1 : false;\n};\n\n/**\n * @param {AnymatchMatcher} matchers\n * @param {Array|string} testString\n * @param {object} options\n * @returns {boolean|number|Function}\n */\nconst anymatch = (matchers, testString, options = DEFAULT_OPTIONS) => {\n  if (matchers == null) {\n    throw new TypeError('anymatch: specify first argument');\n  }\n  const opts = typeof options === 'boolean' ? {returnIndex: options} : options;\n  const returnIndex = opts.returnIndex || false;\n\n  // Early cache for matchers.\n  const mtchers = arrify(matchers);\n  const negatedGlobs = mtchers\n    .filter(item => typeof item === 'string' && item.charAt(0) === BANG)\n    .map(item => item.slice(1))\n    .map(item => picomatch(item, opts));\n  const patterns = mtchers\n    .filter(item => typeof item !== 'string' || (typeof item === 'string' && item.charAt(0) !== BANG))\n    .map(matcher => createPattern(matcher, opts));\n\n  if (testString == null) {\n    return (testString, ri = false) => {\n      const returnIndex = typeof ri === 'boolean' ? ri : false;\n      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n    }\n  }\n\n  return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n};\n\nanymatch.default = anymatch;\nmodule.exports = anymatch;\n","/*!\n * is-extglob <https://github.com/jonschlinkert/is-extglob>\n *\n * Copyright (c) 2014-2016, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nmodule.exports = function isExtglob(str) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  var match;\n  while ((match = /(\\\\).|([@?!+*]\\(.*\\))/g.exec(str))) {\n    if (match[2]) return true;\n    str = str.slice(match.index + match[0].length);\n  }\n\n  return false;\n};\n","/*!\n * is-glob <https://github.com/jonschlinkert/is-glob>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar isExtglob = require('is-extglob');\nvar chars = { '{': '}', '(': ')', '[': ']'};\nvar strictCheck = function(str) {\n  if (str[0] === '!') {\n    return true;\n  }\n  var index = 0;\n  var pipeIndex = -2;\n  var closeSquareIndex = -2;\n  var closeCurlyIndex = -2;\n  var closeParenIndex = -2;\n  var backSlashIndex = -2;\n  while (index < str.length) {\n    if (str[index] === '*') {\n      return true;\n    }\n\n    if (str[index + 1] === '?' && /[\\].+)]/.test(str[index])) {\n      return true;\n    }\n\n    if (closeSquareIndex !== -1 && str[index] === '[' && str[index + 1] !== ']') {\n      if (closeSquareIndex < index) {\n        closeSquareIndex = str.indexOf(']', index);\n      }\n      if (closeSquareIndex > index) {\n        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {\n          return true;\n        }\n        backSlashIndex = str.indexOf('\\\\', index);\n        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {\n          return true;\n        }\n      }\n    }\n\n    if (closeCurlyIndex !== -1 && str[index] === '{' && str[index + 1] !== '}') {\n      closeCurlyIndex = str.indexOf('}', index);\n      if (closeCurlyIndex > index) {\n        backSlashIndex = str.indexOf('\\\\', index);\n        if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {\n          return true;\n        }\n      }\n    }\n\n    if (closeParenIndex !== -1 && str[index] === '(' && str[index + 1] === '?' && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ')') {\n      closeParenIndex = str.indexOf(')', index);\n      if (closeParenIndex > index) {\n        backSlashIndex = str.indexOf('\\\\', index);\n        if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {\n          return true;\n        }\n      }\n    }\n\n    if (pipeIndex !== -1 && str[index] === '(' && str[index + 1] !== '|') {\n      if (pipeIndex < index) {\n        pipeIndex = str.indexOf('|', index);\n      }\n      if (pipeIndex !== -1 && str[pipeIndex + 1] !== ')') {\n        closeParenIndex = str.indexOf(')', pipeIndex);\n        if (closeParenIndex > pipeIndex) {\n          backSlashIndex = str.indexOf('\\\\', pipeIndex);\n          if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {\n            return true;\n          }\n        }\n      }\n    }\n\n    if (str[index] === '\\\\') {\n      var open = str[index + 1];\n      index += 2;\n      var close = chars[open];\n\n      if (close) {\n        var n = str.indexOf(close, index);\n        if (n !== -1) {\n          index = n + 1;\n        }\n      }\n\n      if (str[index] === '!') {\n        return true;\n      }\n    } else {\n      index++;\n    }\n  }\n  return false;\n};\n\nvar relaxedCheck = function(str) {\n  if (str[0] === '!') {\n    return true;\n  }\n  var index = 0;\n  while (index < str.length) {\n    if (/[*?{}()[\\]]/.test(str[index])) {\n      return true;\n    }\n\n    if (str[index] === '\\\\') {\n      var open = str[index + 1];\n      index += 2;\n      var close = chars[open];\n\n      if (close) {\n        var n = str.indexOf(close, index);\n        if (n !== -1) {\n          index = n + 1;\n        }\n      }\n\n      if (str[index] === '!') {\n        return true;\n      }\n    } else {\n      index++;\n    }\n  }\n  return false;\n};\n\nmodule.exports = function isGlob(str, options) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  if (isExtglob(str)) {\n    return true;\n  }\n\n  var check = strictCheck;\n\n  // optionally relax check\n  if (options && options.strict === false) {\n    check = relaxedCheck;\n  }\n\n  return check(str);\n};\n","'use strict';\n\nvar isGlob = require('is-glob');\nvar pathPosixDirname = require('path').posix.dirname;\nvar isWin32 = require('os').platform() === 'win32';\n\nvar slash = '/';\nvar backslash = /\\\\/g;\nvar enclosure = /[\\{\\[].*[\\}\\]]$/;\nvar globby = /(^|[^\\\\])([\\{\\[]|\\([^\\)]+$)/;\nvar escaped = /\\\\([\\!\\*\\?\\|\\[\\]\\(\\)\\{\\}])/g;\n\n/**\n * @param {string} str\n * @param {Object} opts\n * @param {boolean} [opts.flipBackslashes=true]\n * @returns {string}\n */\nmodule.exports = function globParent(str, opts) {\n  var options = Object.assign({ flipBackslashes: true }, opts);\n\n  // flip windows path separators\n  if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {\n    str = str.replace(backslash, slash);\n  }\n\n  // special case for strings ending in enclosure containing path separator\n  if (enclosure.test(str)) {\n    str += slash;\n  }\n\n  // preserves full path in case of trailing path separator\n  str += 'a';\n\n  // remove path parts that are globby\n  do {\n    str = pathPosixDirname(str);\n  } while (isGlob(str) || globby.test(str));\n\n  // remove escape chars and return result\n  return str.replace(escaped, '$1');\n};\n","'use strict';\n\nexports.isInteger = num => {\n  if (typeof num === 'number') {\n    return Number.isInteger(num);\n  }\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isInteger(Number(num));\n  }\n  return false;\n};\n\n/**\n * Find a node of the given type\n */\n\nexports.find = (node, type) => node.nodes.find(node => node.type === type);\n\n/**\n * Find a node of the given type\n */\n\nexports.exceedsLimit = (min, max, step = 1, limit) => {\n  if (limit === false) return false;\n  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;\n  return ((Number(max) - Number(min)) / Number(step)) >= limit;\n};\n\n/**\n * Escape the given node with '\\\\' before node.value\n */\n\nexports.escapeNode = (block, n = 0, type) => {\n  const node = block.nodes[n];\n  if (!node) return;\n\n  if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {\n    if (node.escaped !== true) {\n      node.value = '\\\\' + node.value;\n      node.escaped = true;\n    }\n  }\n};\n\n/**\n * Returns true if the given brace node should be enclosed in literal braces\n */\n\nexports.encloseBrace = node => {\n  if (node.type !== 'brace') return false;\n  if ((node.commas >> 0 + node.ranges >> 0) === 0) {\n    node.invalid = true;\n    return true;\n  }\n  return false;\n};\n\n/**\n * Returns true if a brace node is invalid.\n */\n\nexports.isInvalidBrace = block => {\n  if (block.type !== 'brace') return false;\n  if (block.invalid === true || block.dollar) return true;\n  if ((block.commas >> 0 + block.ranges >> 0) === 0) {\n    block.invalid = true;\n    return true;\n  }\n  if (block.open !== true || block.close !== true) {\n    block.invalid = true;\n    return true;\n  }\n  return false;\n};\n\n/**\n * Returns true if a node is an open or close node\n */\n\nexports.isOpenOrClose = node => {\n  if (node.type === 'open' || node.type === 'close') {\n    return true;\n  }\n  return node.open === true || node.close === true;\n};\n\n/**\n * Reduce an array of text nodes.\n */\n\nexports.reduce = nodes => nodes.reduce((acc, node) => {\n  if (node.type === 'text') acc.push(node.value);\n  if (node.type === 'range') node.type = 'text';\n  return acc;\n}, []);\n\n/**\n * Flatten an array\n */\n\nexports.flatten = (...args) => {\n  const result = [];\n\n  const flat = arr => {\n    for (let i = 0; i < arr.length; i++) {\n      const ele = arr[i];\n\n      if (Array.isArray(ele)) {\n        flat(ele);\n        continue;\n      }\n\n      if (ele !== undefined) {\n        result.push(ele);\n      }\n    }\n    return result;\n  };\n\n  flat(args);\n  return result;\n};\n","'use strict';\n\nconst utils = require('./utils');\n\nmodule.exports = (ast, options = {}) => {\n  const stringify = (node, parent = {}) => {\n    const invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);\n    const invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let output = '';\n\n    if (node.value) {\n      if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {\n        return '\\\\' + node.value;\n      }\n      return node.value;\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes) {\n      for (const child of node.nodes) {\n        output += stringify(child);\n      }\n    }\n    return output;\n  };\n\n  return stringify(ast);\n};\n\n","/*!\n * is-number <https://github.com/jonschlinkert/is-number>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nmodule.exports = function(num) {\n  if (typeof num === 'number') {\n    return num - num === 0;\n  }\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);\n  }\n  return false;\n};\n","/*!\n * to-regex-range <https://github.com/micromatch/to-regex-range>\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nconst isNumber = require('is-number');\n\nconst toRegexRange = (min, max, options) => {\n  if (isNumber(min) === false) {\n    throw new TypeError('toRegexRange: expected the first argument to be a number');\n  }\n\n  if (max === void 0 || min === max) {\n    return String(min);\n  }\n\n  if (isNumber(max) === false) {\n    throw new TypeError('toRegexRange: expected the second argument to be a number.');\n  }\n\n  let opts = { relaxZeros: true, ...options };\n  if (typeof opts.strictZeros === 'boolean') {\n    opts.relaxZeros = opts.strictZeros === false;\n  }\n\n  let relax = String(opts.relaxZeros);\n  let shorthand = String(opts.shorthand);\n  let capture = String(opts.capture);\n  let wrap = String(opts.wrap);\n  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;\n\n  if (toRegexRange.cache.hasOwnProperty(cacheKey)) {\n    return toRegexRange.cache[cacheKey].result;\n  }\n\n  let a = Math.min(min, max);\n  let b = Math.max(min, max);\n\n  if (Math.abs(a - b) === 1) {\n    let result = min + '|' + max;\n    if (opts.capture) {\n      return `(${result})`;\n    }\n    if (opts.wrap === false) {\n      return result;\n    }\n    return `(?:${result})`;\n  }\n\n  let isPadded = hasPadding(min) || hasPadding(max);\n  let state = { min, max, a, b };\n  let positives = [];\n  let negatives = [];\n\n  if (isPadded) {\n    state.isPadded = isPadded;\n    state.maxLen = String(state.max).length;\n  }\n\n  if (a < 0) {\n    let newMin = b < 0 ? Math.abs(b) : 1;\n    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);\n    a = state.a = 0;\n  }\n\n  if (b >= 0) {\n    positives = splitToPatterns(a, b, state, opts);\n  }\n\n  state.negatives = negatives;\n  state.positives = positives;\n  state.result = collatePatterns(negatives, positives, opts);\n\n  if (opts.capture === true) {\n    state.result = `(${state.result})`;\n  } else if (opts.wrap !== false && (positives.length + negatives.length) > 1) {\n    state.result = `(?:${state.result})`;\n  }\n\n  toRegexRange.cache[cacheKey] = state;\n  return state.result;\n};\n\nfunction collatePatterns(neg, pos, options) {\n  let onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];\n  let onlyPositive = filterPatterns(pos, neg, '', false, options) || [];\n  let intersected = filterPatterns(neg, pos, '-?', true, options) || [];\n  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\n  return subpatterns.join('|');\n}\n\nfunction splitToRanges(min, max) {\n  let nines = 1;\n  let zeros = 1;\n\n  let stop = countNines(min, nines);\n  let stops = new Set([max]);\n\n  while (min <= stop && stop <= max) {\n    stops.add(stop);\n    nines += 1;\n    stop = countNines(min, nines);\n  }\n\n  stop = countZeros(max + 1, zeros) - 1;\n\n  while (min < stop && stop <= max) {\n    stops.add(stop);\n    zeros += 1;\n    stop = countZeros(max + 1, zeros) - 1;\n  }\n\n  stops = [...stops];\n  stops.sort(compare);\n  return stops;\n}\n\n/**\n * Convert a range to a regex pattern\n * @param {Number} `start`\n * @param {Number} `stop`\n * @return {String}\n */\n\nfunction rangeToPattern(start, stop, options) {\n  if (start === stop) {\n    return { pattern: start, count: [], digits: 0 };\n  }\n\n  let zipped = zip(start, stop);\n  let digits = zipped.length;\n  let pattern = '';\n  let count = 0;\n\n  for (let i = 0; i < digits; i++) {\n    let [startDigit, stopDigit] = zipped[i];\n\n    if (startDigit === stopDigit) {\n      pattern += startDigit;\n\n    } else if (startDigit !== '0' || stopDigit !== '9') {\n      pattern += toCharacterClass(startDigit, stopDigit, options);\n\n    } else {\n      count++;\n    }\n  }\n\n  if (count) {\n    pattern += options.shorthand === true ? '\\\\d' : '[0-9]';\n  }\n\n  return { pattern, count: [count], digits };\n}\n\nfunction splitToPatterns(min, max, tok, options) {\n  let ranges = splitToRanges(min, max);\n  let tokens = [];\n  let start = min;\n  let prev;\n\n  for (let i = 0; i < ranges.length; i++) {\n    let max = ranges[i];\n    let obj = rangeToPattern(String(start), String(max), options);\n    let zeros = '';\n\n    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {\n      if (prev.count.length > 1) {\n        prev.count.pop();\n      }\n\n      prev.count.push(obj.count[0]);\n      prev.string = prev.pattern + toQuantifier(prev.count);\n      start = max + 1;\n      continue;\n    }\n\n    if (tok.isPadded) {\n      zeros = padZeros(max, tok, options);\n    }\n\n    obj.string = zeros + obj.pattern + toQuantifier(obj.count);\n    tokens.push(obj);\n    start = max + 1;\n    prev = obj;\n  }\n\n  return tokens;\n}\n\nfunction filterPatterns(arr, comparison, prefix, intersection, options) {\n  let result = [];\n\n  for (let ele of arr) {\n    let { string } = ele;\n\n    // only push if _both_ are negative...\n    if (!intersection && !contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n\n    // or _both_ are positive\n    if (intersection && contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n  }\n  return result;\n}\n\n/**\n * Zip strings\n */\n\nfunction zip(a, b) {\n  let arr = [];\n  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);\n  return arr;\n}\n\nfunction compare(a, b) {\n  return a > b ? 1 : b > a ? -1 : 0;\n}\n\nfunction contains(arr, key, val) {\n  return arr.some(ele => ele[key] === val);\n}\n\nfunction countNines(min, len) {\n  return Number(String(min).slice(0, -len) + '9'.repeat(len));\n}\n\nfunction countZeros(integer, zeros) {\n  return integer - (integer % Math.pow(10, zeros));\n}\n\nfunction toQuantifier(digits) {\n  let [start = 0, stop = ''] = digits;\n  if (stop || start > 1) {\n    return `{${start + (stop ? ',' + stop : '')}}`;\n  }\n  return '';\n}\n\nfunction toCharacterClass(a, b, options) {\n  return `[${a}${(b - a === 1) ? '' : '-'}${b}]`;\n}\n\nfunction hasPadding(str) {\n  return /^-?(0+)\\d/.test(str);\n}\n\nfunction padZeros(value, tok, options) {\n  if (!tok.isPadded) {\n    return value;\n  }\n\n  let diff = Math.abs(tok.maxLen - String(value).length);\n  let relax = options.relaxZeros !== false;\n\n  switch (diff) {\n    case 0:\n      return '';\n    case 1:\n      return relax ? '0?' : '0';\n    case 2:\n      return relax ? '0{0,2}' : '00';\n    default: {\n      return relax ? `0{0,${diff}}` : `0{${diff}}`;\n    }\n  }\n}\n\n/**\n * Cache\n */\n\ntoRegexRange.cache = {};\ntoRegexRange.clearCache = () => (toRegexRange.cache = {});\n\n/**\n * Expose `toRegexRange`\n */\n\nmodule.exports = toRegexRange;\n","/*!\n * fill-range <https://github.com/jonschlinkert/fill-range>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\nconst util = require('util');\nconst toRegexRange = require('to-regex-range');\n\nconst isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\n\nconst transform = toNumber => {\n  return value => toNumber === true ? Number(value) : String(value);\n};\n\nconst isValidValue = value => {\n  return typeof value === 'number' || (typeof value === 'string' && value !== '');\n};\n\nconst isNumber = num => Number.isInteger(+num);\n\nconst zeros = input => {\n  let value = `${input}`;\n  let index = -1;\n  if (value[0] === '-') value = value.slice(1);\n  if (value === '0') return false;\n  while (value[++index] === '0');\n  return index > 0;\n};\n\nconst stringify = (start, end, options) => {\n  if (typeof start === 'string' || typeof end === 'string') {\n    return true;\n  }\n  return options.stringify === true;\n};\n\nconst pad = (input, maxLength, toNumber) => {\n  if (maxLength > 0) {\n    let dash = input[0] === '-' ? '-' : '';\n    if (dash) input = input.slice(1);\n    input = (dash + input.padStart(dash ? maxLength - 1 : maxLength, '0'));\n  }\n  if (toNumber === false) {\n    return String(input);\n  }\n  return input;\n};\n\nconst toMaxLen = (input, maxLength) => {\n  let negative = input[0] === '-' ? '-' : '';\n  if (negative) {\n    input = input.slice(1);\n    maxLength--;\n  }\n  while (input.length < maxLength) input = '0' + input;\n  return negative ? ('-' + input) : input;\n};\n\nconst toSequence = (parts, options, maxLen) => {\n  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n\n  let prefix = options.capture ? '' : '?:';\n  let positives = '';\n  let negatives = '';\n  let result;\n\n  if (parts.positives.length) {\n    positives = parts.positives.map(v => toMaxLen(String(v), maxLen)).join('|');\n  }\n\n  if (parts.negatives.length) {\n    negatives = `-(${prefix}${parts.negatives.map(v => toMaxLen(String(v), maxLen)).join('|')})`;\n  }\n\n  if (positives && negatives) {\n    result = `${positives}|${negatives}`;\n  } else {\n    result = positives || negatives;\n  }\n\n  if (options.wrap) {\n    return `(${prefix}${result})`;\n  }\n\n  return result;\n};\n\nconst toRange = (a, b, isNumbers, options) => {\n  if (isNumbers) {\n    return toRegexRange(a, b, { wrap: false, ...options });\n  }\n\n  let start = String.fromCharCode(a);\n  if (a === b) return start;\n\n  let stop = String.fromCharCode(b);\n  return `[${start}-${stop}]`;\n};\n\nconst toRegex = (start, end, options) => {\n  if (Array.isArray(start)) {\n    let wrap = options.wrap === true;\n    let prefix = options.capture ? '' : '?:';\n    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');\n  }\n  return toRegexRange(start, end, options);\n};\n\nconst rangeError = (...args) => {\n  return new RangeError('Invalid range arguments: ' + util.inspect(...args));\n};\n\nconst invalidRange = (start, end, options) => {\n  if (options.strictRanges === true) throw rangeError([start, end]);\n  return [];\n};\n\nconst invalidStep = (step, options) => {\n  if (options.strictRanges === true) {\n    throw new TypeError(`Expected step \"${step}\" to be a number`);\n  }\n  return [];\n};\n\nconst fillNumbers = (start, end, step = 1, options = {}) => {\n  let a = Number(start);\n  let b = Number(end);\n\n  if (!Number.isInteger(a) || !Number.isInteger(b)) {\n    if (options.strictRanges === true) throw rangeError([start, end]);\n    return [];\n  }\n\n  // fix negative zero\n  if (a === 0) a = 0;\n  if (b === 0) b = 0;\n\n  let descending = a > b;\n  let startString = String(start);\n  let endString = String(end);\n  let stepString = String(step);\n  step = Math.max(Math.abs(step), 1);\n\n  let padded = zeros(startString) || zeros(endString) || zeros(stepString);\n  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;\n  let toNumber = padded === false && stringify(start, end, options) === false;\n  let format = options.transform || transform(toNumber);\n\n  if (options.toRegex && step === 1) {\n    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);\n  }\n\n  let parts = { negatives: [], positives: [] };\n  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    if (options.toRegex === true && step > 1) {\n      push(a);\n    } else {\n      range.push(pad(format(a, index), maxLen, toNumber));\n    }\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return step > 1\n      ? toSequence(parts, options, maxLen)\n      : toRegex(range, null, { wrap: false, ...options });\n  }\n\n  return range;\n};\n\nconst fillLetters = (start, end, step = 1, options = {}) => {\n  if ((!isNumber(start) && start.length > 1) || (!isNumber(end) && end.length > 1)) {\n    return invalidRange(start, end, options);\n  }\n\n  let format = options.transform || (val => String.fromCharCode(val));\n  let a = `${start}`.charCodeAt(0);\n  let b = `${end}`.charCodeAt(0);\n\n  let descending = a > b;\n  let min = Math.min(a, b);\n  let max = Math.max(a, b);\n\n  if (options.toRegex && step === 1) {\n    return toRange(min, max, false, options);\n  }\n\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    range.push(format(a, index));\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return toRegex(range, null, { wrap: false, options });\n  }\n\n  return range;\n};\n\nconst fill = (start, end, step, options = {}) => {\n  if (end == null && isValidValue(start)) {\n    return [start];\n  }\n\n  if (!isValidValue(start) || !isValidValue(end)) {\n    return invalidRange(start, end, options);\n  }\n\n  if (typeof step === 'function') {\n    return fill(start, end, 1, { transform: step });\n  }\n\n  if (isObject(step)) {\n    return fill(start, end, 0, step);\n  }\n\n  let opts = { ...options };\n  if (opts.capture === true) opts.wrap = true;\n  step = step || opts.step || 1;\n\n  if (!isNumber(step)) {\n    if (step != null && !isObject(step)) return invalidStep(step, opts);\n    return fill(start, end, 1, step);\n  }\n\n  if (isNumber(start) && isNumber(end)) {\n    return fillNumbers(start, end, step, opts);\n  }\n\n  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);\n};\n\nmodule.exports = fill;\n","'use strict';\n\nconst fill = require('fill-range');\nconst utils = require('./utils');\n\nconst compile = (ast, options = {}) => {\n  const walk = (node, parent = {}) => {\n    const invalidBlock = utils.isInvalidBrace(parent);\n    const invalidNode = node.invalid === true && options.escapeInvalid === true;\n    const invalid = invalidBlock === true || invalidNode === true;\n    const prefix = options.escapeInvalid === true ? '\\\\' : '';\n    let output = '';\n\n    if (node.isOpen === true) {\n      return prefix + node.value;\n    }\n\n    if (node.isClose === true) {\n      console.log('node.isClose', prefix, node.value);\n      return prefix + node.value;\n    }\n\n    if (node.type === 'open') {\n      return invalid ? prefix + node.value : '(';\n    }\n\n    if (node.type === 'close') {\n      return invalid ? prefix + node.value : ')';\n    }\n\n    if (node.type === 'comma') {\n      return node.prev.type === 'comma' ? '' : invalid ? node.value : '|';\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      const args = utils.reduce(node.nodes);\n      const range = fill(...args, { ...options, wrap: false, toRegex: true, strictZeros: true });\n\n      if (range.length !== 0) {\n        return args.length > 1 && range.length > 1 ? `(${range})` : range;\n      }\n    }\n\n    if (node.nodes) {\n      for (const child of node.nodes) {\n        output += walk(child, node);\n      }\n    }\n\n    return output;\n  };\n\n  return walk(ast);\n};\n\nmodule.exports = compile;\n","'use strict';\n\nconst fill = require('fill-range');\nconst stringify = require('./stringify');\nconst utils = require('./utils');\n\nconst append = (queue = '', stash = '', enclose = false) => {\n  const result = [];\n\n  queue = [].concat(queue);\n  stash = [].concat(stash);\n\n  if (!stash.length) return queue;\n  if (!queue.length) {\n    return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;\n  }\n\n  for (const item of queue) {\n    if (Array.isArray(item)) {\n      for (const value of item) {\n        result.push(append(value, stash, enclose));\n      }\n    } else {\n      for (let ele of stash) {\n        if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;\n        result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);\n      }\n    }\n  }\n  return utils.flatten(result);\n};\n\nconst expand = (ast, options = {}) => {\n  const rangeLimit = options.rangeLimit === undefined ? 1000 : options.rangeLimit;\n\n  const walk = (node, parent = {}) => {\n    node.queue = [];\n\n    let p = parent;\n    let q = parent.queue;\n\n    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {\n      p = p.parent;\n      q = p.queue;\n    }\n\n    if (node.invalid || node.dollar) {\n      q.push(append(q.pop(), stringify(node, options)));\n      return;\n    }\n\n    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {\n      q.push(append(q.pop(), ['{}']));\n      return;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      const args = utils.reduce(node.nodes);\n\n      if (utils.exceedsLimit(...args, options.step, rangeLimit)) {\n        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');\n      }\n\n      let range = fill(...args, options);\n      if (range.length === 0) {\n        range = stringify(node, options);\n      }\n\n      q.push(append(q.pop(), range));\n      node.nodes = [];\n      return;\n    }\n\n    const enclose = utils.encloseBrace(node);\n    let queue = node.queue;\n    let block = node;\n\n    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {\n      block = block.parent;\n      queue = block.queue;\n    }\n\n    for (let i = 0; i < node.nodes.length; i++) {\n      const child = node.nodes[i];\n\n      if (child.type === 'comma' && node.type === 'brace') {\n        if (i === 1) queue.push('');\n        queue.push('');\n        continue;\n      }\n\n      if (child.type === 'close') {\n        q.push(append(q.pop(), queue, enclose));\n        continue;\n      }\n\n      if (child.value && child.type !== 'open') {\n        queue.push(append(queue.pop(), child.value));\n        continue;\n      }\n\n      if (child.nodes) {\n        walk(child, node);\n      }\n    }\n\n    return queue;\n  };\n\n  return utils.flatten(walk(ast));\n};\n\nmodule.exports = expand;\n","'use strict';\n\nmodule.exports = {\n  MAX_LENGTH: 10000,\n\n  // Digits\n  CHAR_0: '0', /* 0 */\n  CHAR_9: '9', /* 9 */\n\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 'A', /* A */\n  CHAR_LOWERCASE_A: 'a', /* a */\n  CHAR_UPPERCASE_Z: 'Z', /* Z */\n  CHAR_LOWERCASE_Z: 'z', /* z */\n\n  CHAR_LEFT_PARENTHESES: '(', /* ( */\n  CHAR_RIGHT_PARENTHESES: ')', /* ) */\n\n  CHAR_ASTERISK: '*', /* * */\n\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: '&', /* & */\n  CHAR_AT: '@', /* @ */\n  CHAR_BACKSLASH: '\\\\', /* \\ */\n  CHAR_BACKTICK: '`', /* ` */\n  CHAR_CARRIAGE_RETURN: '\\r', /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: '^', /* ^ */\n  CHAR_COLON: ':', /* : */\n  CHAR_COMMA: ',', /* , */\n  CHAR_DOLLAR: '$', /* . */\n  CHAR_DOT: '.', /* . */\n  CHAR_DOUBLE_QUOTE: '\"', /* \" */\n  CHAR_EQUAL: '=', /* = */\n  CHAR_EXCLAMATION_MARK: '!', /* ! */\n  CHAR_FORM_FEED: '\\f', /* \\f */\n  CHAR_FORWARD_SLASH: '/', /* / */\n  CHAR_HASH: '#', /* # */\n  CHAR_HYPHEN_MINUS: '-', /* - */\n  CHAR_LEFT_ANGLE_BRACKET: '<', /* < */\n  CHAR_LEFT_CURLY_BRACE: '{', /* { */\n  CHAR_LEFT_SQUARE_BRACKET: '[', /* [ */\n  CHAR_LINE_FEED: '\\n', /* \\n */\n  CHAR_NO_BREAK_SPACE: '\\u00A0', /* \\u00A0 */\n  CHAR_PERCENT: '%', /* % */\n  CHAR_PLUS: '+', /* + */\n  CHAR_QUESTION_MARK: '?', /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: '>', /* > */\n  CHAR_RIGHT_CURLY_BRACE: '}', /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: ']', /* ] */\n  CHAR_SEMICOLON: ';', /* ; */\n  CHAR_SINGLE_QUOTE: '\\'', /* ' */\n  CHAR_SPACE: ' ', /*   */\n  CHAR_TAB: '\\t', /* \\t */\n  CHAR_UNDERSCORE: '_', /* _ */\n  CHAR_VERTICAL_LINE: '|', /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\\uFEFF' /* \\uFEFF */\n};\n","'use strict';\n\nconst stringify = require('./stringify');\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  CHAR_BACKSLASH, /* \\ */\n  CHAR_BACKTICK, /* ` */\n  CHAR_COMMA, /* , */\n  CHAR_DOT, /* . */\n  CHAR_LEFT_PARENTHESES, /* ( */\n  CHAR_RIGHT_PARENTHESES, /* ) */\n  CHAR_LEFT_CURLY_BRACE, /* { */\n  CHAR_RIGHT_CURLY_BRACE, /* } */\n  CHAR_LEFT_SQUARE_BRACKET, /* [ */\n  CHAR_RIGHT_SQUARE_BRACKET, /* ] */\n  CHAR_DOUBLE_QUOTE, /* \" */\n  CHAR_SINGLE_QUOTE, /* ' */\n  CHAR_NO_BREAK_SPACE,\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE\n} = require('./constants');\n\n/**\n * parse\n */\n\nconst parse = (input, options = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  const opts = options || {};\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  if (input.length > max) {\n    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);\n  }\n\n  const ast = { type: 'root', input, nodes: [] };\n  const stack = [ast];\n  let block = ast;\n  let prev = ast;\n  let brackets = 0;\n  const length = input.length;\n  let index = 0;\n  let depth = 0;\n  let value;\n\n  /**\n   * Helpers\n   */\n\n  const advance = () => input[index++];\n  const push = node => {\n    if (node.type === 'text' && prev.type === 'dot') {\n      prev.type = 'text';\n    }\n\n    if (prev && prev.type === 'text' && node.type === 'text') {\n      prev.value += node.value;\n      return;\n    }\n\n    block.nodes.push(node);\n    node.parent = block;\n    node.prev = prev;\n    prev = node;\n    return node;\n  };\n\n  push({ type: 'bos' });\n\n  while (index < length) {\n    block = stack[stack.length - 1];\n    value = advance();\n\n    /**\n     * Invalid chars\n     */\n\n    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {\n      continue;\n    }\n\n    /**\n     * Escaped chars\n     */\n\n    if (value === CHAR_BACKSLASH) {\n      push({ type: 'text', value: (options.keepEscaping ? value : '') + advance() });\n      continue;\n    }\n\n    /**\n     * Right square bracket (literal): ']'\n     */\n\n    if (value === CHAR_RIGHT_SQUARE_BRACKET) {\n      push({ type: 'text', value: '\\\\' + value });\n      continue;\n    }\n\n    /**\n     * Left square bracket: '['\n     */\n\n    if (value === CHAR_LEFT_SQUARE_BRACKET) {\n      brackets++;\n\n      let next;\n\n      while (index < length && (next = advance())) {\n        value += next;\n\n        if (next === CHAR_LEFT_SQUARE_BRACKET) {\n          brackets++;\n          continue;\n        }\n\n        if (next === CHAR_BACKSLASH) {\n          value += advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          brackets--;\n\n          if (brackets === 0) {\n            break;\n          }\n        }\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === CHAR_LEFT_PARENTHESES) {\n      block = push({ type: 'paren', nodes: [] });\n      stack.push(block);\n      push({ type: 'text', value });\n      continue;\n    }\n\n    if (value === CHAR_RIGHT_PARENTHESES) {\n      if (block.type !== 'paren') {\n        push({ type: 'text', value });\n        continue;\n      }\n      block = stack.pop();\n      push({ type: 'text', value });\n      block = stack[stack.length - 1];\n      continue;\n    }\n\n    /**\n     * Quotes: '|\"|`\n     */\n\n    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {\n      const open = value;\n      let next;\n\n      if (options.keepQuotes !== true) {\n        value = '';\n      }\n\n      while (index < length && (next = advance())) {\n        if (next === CHAR_BACKSLASH) {\n          value += next + advance();\n          continue;\n        }\n\n        if (next === open) {\n          if (options.keepQuotes === true) value += next;\n          break;\n        }\n\n        value += next;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Left curly brace: '{'\n     */\n\n    if (value === CHAR_LEFT_CURLY_BRACE) {\n      depth++;\n\n      const dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;\n      const brace = {\n        type: 'brace',\n        open: true,\n        close: false,\n        dollar,\n        depth,\n        commas: 0,\n        ranges: 0,\n        nodes: []\n      };\n\n      block = push(brace);\n      stack.push(block);\n      push({ type: 'open', value });\n      continue;\n    }\n\n    /**\n     * Right curly brace: '}'\n     */\n\n    if (value === CHAR_RIGHT_CURLY_BRACE) {\n      if (block.type !== 'brace') {\n        push({ type: 'text', value });\n        continue;\n      }\n\n      const type = 'close';\n      block = stack.pop();\n      block.close = true;\n\n      push({ type, value });\n      depth--;\n\n      block = stack[stack.length - 1];\n      continue;\n    }\n\n    /**\n     * Comma: ','\n     */\n\n    if (value === CHAR_COMMA && depth > 0) {\n      if (block.ranges > 0) {\n        block.ranges = 0;\n        const open = block.nodes.shift();\n        block.nodes = [open, { type: 'text', value: stringify(block) }];\n      }\n\n      push({ type: 'comma', value });\n      block.commas++;\n      continue;\n    }\n\n    /**\n     * Dot: '.'\n     */\n\n    if (value === CHAR_DOT && depth > 0 && block.commas === 0) {\n      const siblings = block.nodes;\n\n      if (depth === 0 || siblings.length === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n\n      if (prev.type === 'dot') {\n        block.range = [];\n        prev.value += value;\n        prev.type = 'range';\n\n        if (block.nodes.length !== 3 && block.nodes.length !== 5) {\n          block.invalid = true;\n          block.ranges = 0;\n          prev.type = 'text';\n          continue;\n        }\n\n        block.ranges++;\n        block.args = [];\n        continue;\n      }\n\n      if (prev.type === 'range') {\n        siblings.pop();\n\n        const before = siblings[siblings.length - 1];\n        before.value += prev.value + value;\n        prev = before;\n        block.ranges--;\n        continue;\n      }\n\n      push({ type: 'dot', value });\n      continue;\n    }\n\n    /**\n     * Text\n     */\n\n    push({ type: 'text', value });\n  }\n\n  // Mark imbalanced braces and brackets as invalid\n  do {\n    block = stack.pop();\n\n    if (block.type !== 'root') {\n      block.nodes.forEach(node => {\n        if (!node.nodes) {\n          if (node.type === 'open') node.isOpen = true;\n          if (node.type === 'close') node.isClose = true;\n          if (!node.nodes) node.type = 'text';\n          node.invalid = true;\n        }\n      });\n\n      // get the location of the block on parent.nodes (block's siblings)\n      const parent = stack[stack.length - 1];\n      const index = parent.nodes.indexOf(block);\n      // replace the (invalid) block with it's nodes\n      parent.nodes.splice(index, 1, ...block.nodes);\n    }\n  } while (stack.length > 0);\n\n  push({ type: 'eos' });\n  return ast;\n};\n\nmodule.exports = parse;\n","'use strict';\n\nconst stringify = require('./lib/stringify');\nconst compile = require('./lib/compile');\nconst expand = require('./lib/expand');\nconst parse = require('./lib/parse');\n\n/**\n * Expand the given pattern or create a regex-compatible string.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']\n * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {String}\n * @api public\n */\n\nconst braces = (input, options = {}) => {\n  let output = [];\n\n  if (Array.isArray(input)) {\n    for (const pattern of input) {\n      const result = braces.create(pattern, options);\n      if (Array.isArray(result)) {\n        output.push(...result);\n      } else {\n        output.push(result);\n      }\n    }\n  } else {\n    output = [].concat(braces.create(input, options));\n  }\n\n  if (options && options.expand === true && options.nodupes === true) {\n    output = [...new Set(output)];\n  }\n  return output;\n};\n\n/**\n * Parse the given `str` with the given `options`.\n *\n * ```js\n * // braces.parse(pattern, [, options]);\n * const ast = braces.parse('a/{b,c}/d');\n * console.log(ast);\n * ```\n * @param {String} pattern Brace pattern to parse\n * @param {Object} options\n * @return {Object} Returns an AST\n * @api public\n */\n\nbraces.parse = (input, options = {}) => parse(input, options);\n\n/**\n * Creates a braces string from an AST, or an AST node.\n *\n * ```js\n * const braces = require('braces');\n * let ast = braces.parse('foo/{a,b}/bar');\n * console.log(stringify(ast.nodes[2])); //=> '{a,b}'\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.stringify = (input, options = {}) => {\n  if (typeof input === 'string') {\n    return stringify(braces.parse(input, options), options);\n  }\n  return stringify(input, options);\n};\n\n/**\n * Compiles a brace pattern into a regex-compatible, optimized string.\n * This method is called by the main [braces](#braces) function by default.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.compile('a/{b,c}/d'));\n * //=> ['a/(b|c)/d']\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.compile = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces.parse(input, options);\n  }\n  return compile(input, options);\n};\n\n/**\n * Expands a brace pattern into an array. This method is called by the\n * main [braces](#braces) function when `options.expand` is true. Before\n * using this method it's recommended that you read the [performance notes](#performance))\n * and advantages of using [.compile](#compile) instead.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.expand('a/{b,c}/d'));\n * //=> ['a/b/d', 'a/c/d'];\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.expand = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces.parse(input, options);\n  }\n\n  let result = expand(input, options);\n\n  // filter out empty strings if specified\n  if (options.noempty === true) {\n    result = result.filter(Boolean);\n  }\n\n  // filter out duplicates if specified\n  if (options.nodupes === true) {\n    result = [...new Set(result)];\n  }\n\n  return result;\n};\n\n/**\n * Processes a brace pattern and returns either an expanded array\n * (if `options.expand` is true), a highly optimized regex-compatible string.\n * This method is called by the main [braces](#braces) function.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))\n * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.create = (input, options = {}) => {\n  if (input === '' || input.length < 3) {\n    return [input];\n  }\n\n  return options.expand !== true\n    ? braces.compile(input, options)\n    : braces.expand(input, options);\n};\n\n/**\n * Expose \"braces\"\n */\n\nmodule.exports = braces;\n","module.exports = require('./binary-extensions.json');\n","'use strict';\nconst path = require('path');\nconst binaryExtensions = require('binary-extensions');\n\nconst extensions = new Set(binaryExtensions);\n\nmodule.exports = filePath => extensions.has(path.extname(filePath).slice(1).toLowerCase());\n","'use strict';\n\nconst {sep} = require('path');\nconst {platform} = process;\nconst os = require('os');\n\nexports.EV_ALL = 'all';\nexports.EV_READY = 'ready';\nexports.EV_ADD = 'add';\nexports.EV_CHANGE = 'change';\nexports.EV_ADD_DIR = 'addDir';\nexports.EV_UNLINK = 'unlink';\nexports.EV_UNLINK_DIR = 'unlinkDir';\nexports.EV_RAW = 'raw';\nexports.EV_ERROR = 'error';\n\nexports.STR_DATA = 'data';\nexports.STR_END = 'end';\nexports.STR_CLOSE = 'close';\n\nexports.FSEVENT_CREATED = 'created';\nexports.FSEVENT_MODIFIED = 'modified';\nexports.FSEVENT_DELETED = 'deleted';\nexports.FSEVENT_MOVED = 'moved';\nexports.FSEVENT_CLONED = 'cloned';\nexports.FSEVENT_UNKNOWN = 'unknown';\nexports.FSEVENT_FLAG_MUST_SCAN_SUBDIRS = 1;\nexports.FSEVENT_TYPE_FILE = 'file';\nexports.FSEVENT_TYPE_DIRECTORY = 'directory';\nexports.FSEVENT_TYPE_SYMLINK = 'symlink';\n\nexports.KEY_LISTENERS = 'listeners';\nexports.KEY_ERR = 'errHandlers';\nexports.KEY_RAW = 'rawEmitters';\nexports.HANDLER_KEYS = [exports.KEY_LISTENERS, exports.KEY_ERR, exports.KEY_RAW];\n\nexports.DOT_SLASH = `.${sep}`;\n\nexports.BACK_SLASH_RE = /\\\\/g;\nexports.DOUBLE_SLASH_RE = /\\/\\//;\nexports.SLASH_OR_BACK_SLASH_RE = /[/\\\\]/;\nexports.DOT_RE = /\\..*\\.(sw[px])$|~$|\\.subl.*\\.tmp/;\nexports.REPLACER_RE = /^\\.[/\\\\]/;\n\nexports.SLASH = '/';\nexports.SLASH_SLASH = '//';\nexports.BRACE_START = '{';\nexports.BANG = '!';\nexports.ONE_DOT = '.';\nexports.TWO_DOTS = '..';\nexports.STAR = '*';\nexports.GLOBSTAR = '**';\nexports.ROOT_GLOBSTAR = '/**/*';\nexports.SLASH_GLOBSTAR = '/**';\nexports.DIR_SUFFIX = 'Dir';\nexports.ANYMATCH_OPTS = {dot: true};\nexports.STRING_TYPE = 'string';\nexports.FUNCTION_TYPE = 'function';\nexports.EMPTY_STR = '';\nexports.EMPTY_FN = () => {};\nexports.IDENTITY_FN = val => val;\n\nexports.isWindows = platform === 'win32';\nexports.isMacos = platform === 'darwin';\nexports.isLinux = platform === 'linux';\nexports.isIBMi = os.type() === 'OS400';\n","'use strict';\n\nconst fs = require('fs');\nconst sysPath = require('path');\nconst { promisify } = require('util');\nconst isBinaryPath = require('is-binary-path');\nconst {\n  isWindows,\n  isLinux,\n  EMPTY_FN,\n  EMPTY_STR,\n  KEY_LISTENERS,\n  KEY_ERR,\n  KEY_RAW,\n  HANDLER_KEYS,\n  EV_CHANGE,\n  EV_ADD,\n  EV_ADD_DIR,\n  EV_ERROR,\n  STR_DATA,\n  STR_END,\n  BRACE_START,\n  STAR\n} = require('./constants');\n\nconst THROTTLE_MODE_WATCH = 'watch';\n\nconst open = promisify(fs.open);\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\nconst close = promisify(fs.close);\nconst fsrealpath = promisify(fs.realpath);\n\nconst statMethods = { lstat, stat };\n\n// TODO: emit errors properly. Example: EMFILE on Macos.\nconst foreach = (val, fn) => {\n  if (val instanceof Set) {\n    val.forEach(fn);\n  } else {\n    fn(val);\n  }\n};\n\nconst addAndConvert = (main, prop, item) => {\n  let container = main[prop];\n  if (!(container instanceof Set)) {\n    main[prop] = container = new Set([container]);\n  }\n  container.add(item);\n};\n\nconst clearItem = cont => key => {\n  const set = cont[key];\n  if (set instanceof Set) {\n    set.clear();\n  } else {\n    delete cont[key];\n  }\n};\n\nconst delFromSet = (main, prop, item) => {\n  const container = main[prop];\n  if (container instanceof Set) {\n    container.delete(item);\n  } else if (container === item) {\n    delete main[prop];\n  }\n};\n\nconst isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;\n\n/**\n * @typedef {String} Path\n */\n\n// fs_watch helpers\n\n// object to hold per-process fs_watch instances\n// (may be shared across chokidar FSWatcher instances)\n\n/**\n * @typedef {Object} FsWatchContainer\n * @property {Set} listeners\n * @property {Set} errHandlers\n * @property {Set} rawEmitters\n * @property {fs.FSWatcher=} watcher\n * @property {Boolean=} watcherUnusable\n */\n\n/**\n * @type {Map<String,FsWatchContainer>}\n */\nconst FsWatchInstances = new Map();\n\n/**\n * Instantiates the fs_watch interface\n * @param {String} path to be watched\n * @param {Object} options to be passed to fs_watch\n * @param {Function} listener main event handler\n * @param {Function} errHandler emits info about errors\n * @param {Function} emitRaw emits raw event data\n * @returns {fs.FSWatcher} new fsevents instance\n */\nfunction createFsWatchInstance(path, options, listener, errHandler, emitRaw) {\n  const handleEvent = (rawEvent, evPath) => {\n    listener(path);\n    emitRaw(rawEvent, evPath, {watchedPath: path});\n\n    // emit based on events occurring for files from a directory's watcher in\n    // case the file's watcher misses it (and rely on throttling to de-dupe)\n    if (evPath && path !== evPath) {\n      fsWatchBroadcast(\n        sysPath.resolve(path, evPath), KEY_LISTENERS, sysPath.join(path, evPath)\n      );\n    }\n  };\n  try {\n    return fs.watch(path, options, handleEvent);\n  } catch (error) {\n    errHandler(error);\n  }\n}\n\n/**\n * Helper for passing fs_watch event data to a collection of listeners\n * @param {Path} fullPath absolute path bound to fs_watch instance\n * @param {String} type listener type\n * @param {*=} val1 arguments to be passed to listeners\n * @param {*=} val2\n * @param {*=} val3\n */\nconst fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {\n  const cont = FsWatchInstances.get(fullPath);\n  if (!cont) return;\n  foreach(cont[type], (listener) => {\n    listener(val1, val2, val3);\n  });\n};\n\n/**\n * Instantiates the fs_watch interface or binds listeners\n * to an existing one covering the same file system entry\n * @param {String} path\n * @param {String} fullPath absolute path\n * @param {Object} options to be passed to fs_watch\n * @param {Object} handlers container for event listener functions\n */\nconst setFsWatchListener = (path, fullPath, options, handlers) => {\n  const {listener, errHandler, rawEmitter} = handlers;\n  let cont = FsWatchInstances.get(fullPath);\n\n  /** @type {fs.FSWatcher=} */\n  let watcher;\n  if (!options.persistent) {\n    watcher = createFsWatchInstance(\n      path, options, listener, errHandler, rawEmitter\n    );\n    return watcher.close.bind(watcher);\n  }\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_ERR, errHandler);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    watcher = createFsWatchInstance(\n      path,\n      options,\n      fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS),\n      errHandler, // no need to use broadcast here\n      fsWatchBroadcast.bind(null, fullPath, KEY_RAW)\n    );\n    if (!watcher) return;\n    watcher.on(EV_ERROR, async (error) => {\n      const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);\n      cont.watcherUnusable = true; // documented since Node 10.4.1\n      // Workaround for https://github.com/joyent/node/issues/4337\n      if (isWindows && error.code === 'EPERM') {\n        try {\n          const fd = await open(path, 'r');\n          await close(fd);\n          broadcastErr(error);\n        } catch (err) {}\n      } else {\n        broadcastErr(error);\n      }\n    });\n    cont = {\n      listeners: listener,\n      errHandlers: errHandler,\n      rawEmitters: rawEmitter,\n      watcher\n    };\n    FsWatchInstances.set(fullPath, cont);\n  }\n  // const index = cont.listeners.indexOf(listener);\n\n  // removes this instance's listeners and closes the underlying fs_watch\n  // instance if there are no more listeners left\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_ERR, errHandler);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n    if (isEmptySet(cont.listeners)) {\n      // Check to protect against issue gh-730.\n      // if (cont.watcherUnusable) {\n      cont.watcher.close();\n      // }\n      FsWatchInstances.delete(fullPath);\n      HANDLER_KEYS.forEach(clearItem(cont));\n      cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n};\n\n// fs_watchFile helpers\n\n// object to hold per-process fs_watchFile instances\n// (may be shared across chokidar FSWatcher instances)\nconst FsWatchFileInstances = new Map();\n\n/**\n * Instantiates the fs_watchFile interface or binds listeners\n * to an existing one covering the same file system entry\n * @param {String} path to be watched\n * @param {String} fullPath absolute path\n * @param {Object} options options to be passed to fs_watchFile\n * @param {Object} handlers container for event listener functions\n * @returns {Function} closer\n */\nconst setFsWatchFileListener = (path, fullPath, options, handlers) => {\n  const {listener, rawEmitter} = handlers;\n  let cont = FsWatchFileInstances.get(fullPath);\n\n  /* eslint-disable no-unused-vars, prefer-destructuring */\n  let listeners = new Set();\n  let rawEmitters = new Set();\n\n  const copts = cont && cont.options;\n  if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {\n    // \"Upgrade\" the watcher to persistence or a quicker interval.\n    // This creates some unlikely edge case issues if the user mixes\n    // settings in a very weird way, but solving for those cases\n    // doesn't seem worthwhile for the added complexity.\n    listeners = cont.listeners;\n    rawEmitters = cont.rawEmitters;\n    fs.unwatchFile(fullPath);\n    cont = undefined;\n  }\n\n  /* eslint-enable no-unused-vars, prefer-destructuring */\n\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    // TODO\n    // listeners.add(listener);\n    // rawEmitters.add(rawEmitter);\n    cont = {\n      listeners: listener,\n      rawEmitters: rawEmitter,\n      options,\n      watcher: fs.watchFile(fullPath, options, (curr, prev) => {\n        foreach(cont.rawEmitters, (rawEmitter) => {\n          rawEmitter(EV_CHANGE, fullPath, {curr, prev});\n        });\n        const currmtime = curr.mtimeMs;\n        if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {\n          foreach(cont.listeners, (listener) => listener(path, curr));\n        }\n      })\n    };\n    FsWatchFileInstances.set(fullPath, cont);\n  }\n  // const index = cont.listeners.indexOf(listener);\n\n  // Removes this instance's listeners and closes the underlying fs_watchFile\n  // instance if there are no more listeners left.\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n    if (isEmptySet(cont.listeners)) {\n      FsWatchFileInstances.delete(fullPath);\n      fs.unwatchFile(fullPath);\n      cont.options = cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n};\n\n/**\n * @mixin\n */\nclass NodeFsHandler {\n\n/**\n * @param {import(\"../index\").FSWatcher} fsW\n */\nconstructor(fsW) {\n  this.fsw = fsW;\n  this._boundHandleError = (error) => fsW._handleError(error);\n}\n\n/**\n * Watch file for changes with fs_watchFile or fs_watch.\n * @param {String} path to file or dir\n * @param {Function} listener on fs change\n * @returns {Function} closer for the watcher instance\n */\n_watchWithNodeFs(path, listener) {\n  const opts = this.fsw.options;\n  const directory = sysPath.dirname(path);\n  const basename = sysPath.basename(path);\n  const parent = this.fsw._getWatchedDir(directory);\n  parent.add(basename);\n  const absolutePath = sysPath.resolve(path);\n  const options = {persistent: opts.persistent};\n  if (!listener) listener = EMPTY_FN;\n\n  let closer;\n  if (opts.usePolling) {\n    options.interval = opts.enableBinaryInterval && isBinaryPath(basename) ?\n      opts.binaryInterval : opts.interval;\n    closer = setFsWatchFileListener(path, absolutePath, options, {\n      listener,\n      rawEmitter: this.fsw._emitRaw\n    });\n  } else {\n    closer = setFsWatchListener(path, absolutePath, options, {\n      listener,\n      errHandler: this._boundHandleError,\n      rawEmitter: this.fsw._emitRaw\n    });\n  }\n  return closer;\n}\n\n/**\n * Watch a file and emit add event if warranted.\n * @param {Path} file Path\n * @param {fs.Stats} stats result of fs_stat\n * @param {Boolean} initialAdd was the file added at watch instantiation?\n * @returns {Function} closer for the watcher instance\n */\n_handleFile(file, stats, initialAdd) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const dirname = sysPath.dirname(file);\n  const basename = sysPath.basename(file);\n  const parent = this.fsw._getWatchedDir(dirname);\n  // stats is always present\n  let prevStats = stats;\n\n  // if the file is already being watched, do nothing\n  if (parent.has(basename)) return;\n\n  const listener = async (path, newStats) => {\n    if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) return;\n    if (!newStats || newStats.mtimeMs === 0) {\n      try {\n        const newStats = await stat(file);\n        if (this.fsw.closed) return;\n        // Check that change event was not fired because of changed only accessTime.\n        const at = newStats.atimeMs;\n        const mt = newStats.mtimeMs;\n        if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n          this.fsw._emit(EV_CHANGE, file, newStats);\n        }\n        if (isLinux && prevStats.ino !== newStats.ino) {\n          this.fsw._closeFile(path)\n          prevStats = newStats;\n          this.fsw._addPathCloser(path, this._watchWithNodeFs(file, listener));\n        } else {\n          prevStats = newStats;\n        }\n      } catch (error) {\n        // Fix issues where mtime is null but file is still present\n        this.fsw._remove(dirname, basename);\n      }\n      // add is about to be emitted if file not already tracked in parent\n    } else if (parent.has(basename)) {\n      // Check that change event was not fired because of changed only accessTime.\n      const at = newStats.atimeMs;\n      const mt = newStats.mtimeMs;\n      if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n        this.fsw._emit(EV_CHANGE, file, newStats);\n      }\n      prevStats = newStats;\n    }\n  }\n  // kick off the watcher\n  const closer = this._watchWithNodeFs(file, listener);\n\n  // emit an add event if we're supposed to\n  if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {\n    if (!this.fsw._throttle(EV_ADD, file, 0)) return;\n    this.fsw._emit(EV_ADD, file, stats);\n  }\n\n  return closer;\n}\n\n/**\n * Handle symlinks encountered while reading a dir.\n * @param {Object} entry returned by readdirp\n * @param {String} directory path of dir being read\n * @param {String} path of this item\n * @param {String} item basename of this item\n * @returns {Promise<Boolean>} true if no more processing is needed for this entry.\n */\nasync _handleSymlink(entry, directory, path, item) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const full = entry.fullPath;\n  const dir = this.fsw._getWatchedDir(directory);\n\n  if (!this.fsw.options.followSymlinks) {\n    // watch symlink directly (don't follow) and detect changes\n    this.fsw._incrReadyCount();\n\n    let linkPath;\n    try {\n      linkPath = await fsrealpath(path);\n    } catch (e) {\n      this.fsw._emitReady();\n      return true;\n    }\n\n    if (this.fsw.closed) return;\n    if (dir.has(item)) {\n      if (this.fsw._symlinkPaths.get(full) !== linkPath) {\n        this.fsw._symlinkPaths.set(full, linkPath);\n        this.fsw._emit(EV_CHANGE, path, entry.stats);\n      }\n    } else {\n      dir.add(item);\n      this.fsw._symlinkPaths.set(full, linkPath);\n      this.fsw._emit(EV_ADD, path, entry.stats);\n    }\n    this.fsw._emitReady();\n    return true;\n  }\n\n  // don't follow the same symlink more than once\n  if (this.fsw._symlinkPaths.has(full)) {\n    return true;\n  }\n\n  this.fsw._symlinkPaths.set(full, true);\n}\n\n_handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {\n  // Normalize the directory name on Windows\n  directory = sysPath.join(directory, EMPTY_STR);\n\n  if (!wh.hasGlob) {\n    throttler = this.fsw._throttle('readdir', directory, 1000);\n    if (!throttler) return;\n  }\n\n  const previous = this.fsw._getWatchedDir(wh.path);\n  const current = new Set();\n\n  let stream = this.fsw._readdirp(directory, {\n    fileFilter: entry => wh.filterPath(entry),\n    directoryFilter: entry => wh.filterDir(entry),\n    depth: 0\n  }).on(STR_DATA, async (entry) => {\n    if (this.fsw.closed) {\n      stream = undefined;\n      return;\n    }\n    const item = entry.path;\n    let path = sysPath.join(directory, item);\n    current.add(item);\n\n    if (entry.stats.isSymbolicLink() && await this._handleSymlink(entry, directory, path, item)) {\n      return;\n    }\n\n    if (this.fsw.closed) {\n      stream = undefined;\n      return;\n    }\n    // Files that present in current directory snapshot\n    // but absent in previous are added to watch list and\n    // emit `add` event.\n    if (item === target || !target && !previous.has(item)) {\n      this.fsw._incrReadyCount();\n\n      // ensure relativeness of path is preserved in case of watcher reuse\n      path = sysPath.join(dir, sysPath.relative(dir, path));\n\n      this._addToNodeFs(path, initialAdd, wh, depth + 1);\n    }\n  }).on(EV_ERROR, this._boundHandleError);\n\n  return new Promise(resolve =>\n    stream.once(STR_END, () => {\n      if (this.fsw.closed) {\n        stream = undefined;\n        return;\n      }\n      const wasThrottled = throttler ? throttler.clear() : false;\n\n      resolve();\n\n      // Files that absent in current directory snapshot\n      // but present in previous emit `remove` event\n      // and are removed from @watched[directory].\n      previous.getChildren().filter((item) => {\n        return item !== directory &&\n          !current.has(item) &&\n          // in case of intersecting globs;\n          // a path may have been filtered out of this readdir, but\n          // shouldn't be removed because it matches a different glob\n          (!wh.hasGlob || wh.filterPath({\n            fullPath: sysPath.resolve(directory, item)\n          }));\n      }).forEach((item) => {\n        this.fsw._remove(directory, item);\n      });\n\n      stream = undefined;\n\n      // one more time for any missed in case changes came in extremely quickly\n      if (wasThrottled) this._handleRead(directory, false, wh, target, dir, depth, throttler);\n    })\n  );\n}\n\n/**\n * Read directory to add / remove files from `@watched` list and re-read it on change.\n * @param {String} dir fs path\n * @param {fs.Stats} stats\n * @param {Boolean} initialAdd\n * @param {Number} depth relative to user-supplied path\n * @param {String} target child path targeted for watch\n * @param {Object} wh Common watch helpers for this path\n * @param {String} realpath\n * @returns {Promise<Function>} closer for the watcher instance.\n */\nasync _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {\n  const parentDir = this.fsw._getWatchedDir(sysPath.dirname(dir));\n  const tracked = parentDir.has(sysPath.basename(dir));\n  if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {\n    if (!wh.hasGlob || wh.globFilter(dir)) this.fsw._emit(EV_ADD_DIR, dir, stats);\n  }\n\n  // ensure dir is tracked (harmless if redundant)\n  parentDir.add(sysPath.basename(dir));\n  this.fsw._getWatchedDir(dir);\n  let throttler;\n  let closer;\n\n  const oDepth = this.fsw.options.depth;\n  if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {\n    if (!target) {\n      await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);\n      if (this.fsw.closed) return;\n    }\n\n    closer = this._watchWithNodeFs(dir, (dirPath, stats) => {\n      // if current directory is removed, do nothing\n      if (stats && stats.mtimeMs === 0) return;\n\n      this._handleRead(dirPath, false, wh, target, dir, depth, throttler);\n    });\n  }\n  return closer;\n}\n\n/**\n * Handle added file, directory, or glob pattern.\n * Delegates call to _handleFile / _handleDir after checks.\n * @param {String} path to file or ir\n * @param {Boolean} initialAdd was the file added at watch instantiation?\n * @param {Object} priorWh depth relative to user-supplied path\n * @param {Number} depth Child path actually targeted for watch\n * @param {String=} target Child path actually targeted for watch\n * @returns {Promise}\n */\nasync _addToNodeFs(path, initialAdd, priorWh, depth, target) {\n  const ready = this.fsw._emitReady;\n  if (this.fsw._isIgnored(path) || this.fsw.closed) {\n    ready();\n    return false;\n  }\n\n  const wh = this.fsw._getWatchHelpers(path, depth);\n  if (!wh.hasGlob && priorWh) {\n    wh.hasGlob = priorWh.hasGlob;\n    wh.globFilter = priorWh.globFilter;\n    wh.filterPath = entry => priorWh.filterPath(entry);\n    wh.filterDir = entry => priorWh.filterDir(entry);\n  }\n\n  // evaluate what is at the path we're being asked to watch\n  try {\n    const stats = await statMethods[wh.statMethod](wh.watchPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(wh.watchPath, stats)) {\n      ready();\n      return false;\n    }\n\n    const follow = this.fsw.options.followSymlinks && !path.includes(STAR) && !path.includes(BRACE_START);\n    let closer;\n    if (stats.isDirectory()) {\n      const absPath = sysPath.resolve(path);\n      const targetPath = follow ? await fsrealpath(path) : path;\n      if (this.fsw.closed) return;\n      closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);\n      if (this.fsw.closed) return;\n      // preserve this symlink's target path\n      if (absPath !== targetPath && targetPath !== undefined) {\n        this.fsw._symlinkPaths.set(absPath, targetPath);\n      }\n    } else if (stats.isSymbolicLink()) {\n      const targetPath = follow ? await fsrealpath(path) : path;\n      if (this.fsw.closed) return;\n      const parent = sysPath.dirname(wh.watchPath);\n      this.fsw._getWatchedDir(parent).add(wh.watchPath);\n      this.fsw._emit(EV_ADD, wh.watchPath, stats);\n      closer = await this._handleDir(parent, stats, initialAdd, depth, path, wh, targetPath);\n      if (this.fsw.closed) return;\n\n      // preserve this symlink's target path\n      if (targetPath !== undefined) {\n        this.fsw._symlinkPaths.set(sysPath.resolve(path), targetPath);\n      }\n    } else {\n      closer = this._handleFile(wh.watchPath, stats, initialAdd);\n    }\n    ready();\n\n    this.fsw._addPathCloser(path, closer);\n    return false;\n\n  } catch (error) {\n    if (this.fsw._handleError(error)) {\n      ready();\n      return path;\n    }\n  }\n}\n\n}\n\nmodule.exports = NodeFsHandler;\n","export default require(__VITE_NODE_ASSET__gnboD8LC__)","/*\n **  2020 by Philipp Dunkel, Ben Noordhuis, Elan Shankar, Paul Miller\n ** Licensed under MIT License.\n */\n\n/* jshint node:true */\n\"use strict\";\n\nif (process.platform !== \"darwin\") {\n  throw new Error(`Module 'fsevents' is not compatible with platform '${process.platform}'`);\n}\n\nconst Native = require(\"./fsevents.node\");\nconst events = Native.constants;\n\nfunction watch(path, since, handler) {\n  if (typeof path !== \"string\") {\n    throw new TypeError(`fsevents argument 1 must be a string and not a ${typeof path}`);\n  }\n  if (\"function\" === typeof since && \"undefined\" === typeof handler) {\n    handler = since;\n    since = Native.flags.SinceNow;\n  }\n  if (typeof since !== \"number\") {\n    throw new TypeError(`fsevents argument 2 must be a number and not a ${typeof since}`);\n  }\n  if (typeof handler !== \"function\") {\n    throw new TypeError(`fsevents argument 3 must be a function and not a ${typeof handler}`);\n  }\n\n  let instance = Native.start(Native.global, path, since, handler);\n  if (!instance) throw new Error(`could not watch: ${path}`);\n  return () => {\n    const result = instance ? Promise.resolve(instance).then(Native.stop) : Promise.resolve(undefined);\n    instance = undefined;\n    return result;\n  };\n}\n\nfunction getInfo(path, flags) {\n  return {\n    path,\n    flags,\n    event: getEventType(flags),\n    type: getFileType(flags),\n    changes: getFileChanges(flags),\n  };\n}\n\nfunction getFileType(flags) {\n  if (events.ItemIsFile & flags) return \"file\";\n  if (events.ItemIsDir & flags) return \"directory\";\n  if (events.MustScanSubDirs & flags) return \"directory\"; \n  if (events.ItemIsSymlink & flags) return \"symlink\";\n}\nfunction anyIsTrue(obj) {\n  for (let key in obj) {\n    if (obj[key]) return true;\n  }\n  return false;\n}\nfunction getEventType(flags) {\n  if (events.ItemRemoved & flags) return \"deleted\";\n  if (events.ItemRenamed & flags) return \"moved\";\n  if (events.ItemCreated & flags) return \"created\";\n  if (events.ItemModified & flags) return \"modified\";\n  if (events.RootChanged & flags) return \"root-changed\";\n  if (events.ItemCloned & flags) return \"cloned\";\n  if (anyIsTrue(flags)) return \"modified\";\n  return \"unknown\";\n}\nfunction getFileChanges(flags) {\n  return {\n    inode: !!(events.ItemInodeMetaMod & flags),\n    finder: !!(events.ItemFinderInfoMod & flags),\n    access: !!(events.ItemChangeOwner & flags),\n    xattrs: !!(events.ItemXattrMod & flags),\n  };\n}\n\nexports.watch = watch;\nexports.getInfo = getInfo;\nexports.constants = events;\n","'use strict';\n\nconst fs = require('fs');\nconst sysPath = require('path');\nconst { promisify } = require('util');\n\nlet fsevents;\ntry {\n  fsevents = require('fsevents');\n} catch (error) {\n  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);\n}\n\nif (fsevents) {\n  // TODO: real check\n  const mtch = process.version.match(/v(\\d+)\\.(\\d+)/);\n  if (mtch && mtch[1] && mtch[2]) {\n    const maj = Number.parseInt(mtch[1], 10);\n    const min = Number.parseInt(mtch[2], 10);\n    if (maj === 8 && min < 16) {\n      fsevents = undefined;\n    }\n  }\n}\n\nconst {\n  EV_ADD,\n  EV_CHANGE,\n  EV_ADD_DIR,\n  EV_UNLINK,\n  EV_ERROR,\n  STR_DATA,\n  STR_END,\n  FSEVENT_CREATED,\n  FSEVENT_MODIFIED,\n  FSEVENT_DELETED,\n  FSEVENT_MOVED,\n  // FSEVENT_CLONED,\n  FSEVENT_UNKNOWN,\n  FSEVENT_FLAG_MUST_SCAN_SUBDIRS,\n  FSEVENT_TYPE_FILE,\n  FSEVENT_TYPE_DIRECTORY,\n  FSEVENT_TYPE_SYMLINK,\n\n  ROOT_GLOBSTAR,\n  DIR_SUFFIX,\n  DOT_SLASH,\n  FUNCTION_TYPE,\n  EMPTY_FN,\n  IDENTITY_FN\n} = require('./constants');\n\nconst Depth = (value) => isNaN(value) ? {} : {depth: value};\n\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\nconst realpath = promisify(fs.realpath);\n\nconst statMethods = { stat, lstat };\n\n/**\n * @typedef {String} Path\n */\n\n/**\n * @typedef {Object} FsEventsWatchContainer\n * @property {Set<Function>} listeners\n * @property {Function} rawEmitter\n * @property {{stop: Function}} watcher\n */\n\n// fsevents instance helper functions\n/**\n * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)\n * @type {Map<Path,FsEventsWatchContainer>}\n */\nconst FSEventsWatchers = new Map();\n\n// Threshold of duplicate path prefixes at which to start\n// consolidating going forward\nconst consolidateThreshhold = 10;\n\nconst wrongEventFlags = new Set([\n  69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912\n]);\n\n/**\n * Instantiates the fsevents interface\n * @param {Path} path path to be watched\n * @param {Function} callback called when fsevents is bound and ready\n * @returns {{stop: Function}} new fsevents instance\n */\nconst createFSEventsInstance = (path, callback) => {\n  const stop = fsevents.watch(path, callback);\n  return {stop};\n};\n\n/**\n * Instantiates the fsevents interface or binds listeners to an existing one covering\n * the same file tree.\n * @param {Path} path           - to be watched\n * @param {Path} realPath       - real path for symlinks\n * @param {Function} listener   - called when fsevents emits events\n * @param {Function} rawEmitter - passes data to listeners of the 'raw' event\n * @returns {Function} closer\n */\nfunction setFSEventsListener(path, realPath, listener, rawEmitter) {\n  let watchPath = sysPath.extname(realPath) ? sysPath.dirname(realPath) : realPath;\n\n  const parentPath = sysPath.dirname(watchPath);\n  let cont = FSEventsWatchers.get(watchPath);\n\n  // If we've accumulated a substantial number of paths that\n  // could have been consolidated by watching one directory\n  // above the current one, create a watcher on the parent\n  // path instead, so that we do consolidate going forward.\n  if (couldConsolidate(parentPath)) {\n    watchPath = parentPath;\n  }\n\n  const resolvedPath = sysPath.resolve(path);\n  const hasSymlink = resolvedPath !== realPath;\n\n  const filteredListener = (fullPath, flags, info) => {\n    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);\n    if (\n      fullPath === resolvedPath ||\n      !fullPath.indexOf(resolvedPath + sysPath.sep)\n    ) listener(fullPath, flags, info);\n  };\n\n  // check if there is already a watcher on a parent path\n  // modifies `watchPath` to the parent path when it finds a match\n  let watchedParent = false;\n  for (const watchedPath of FSEventsWatchers.keys()) {\n    if (realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep) === 0) {\n      watchPath = watchedPath;\n      cont = FSEventsWatchers.get(watchPath);\n      watchedParent = true;\n      break;\n    }\n  }\n\n  if (cont || watchedParent) {\n    cont.listeners.add(filteredListener);\n  } else {\n    cont = {\n      listeners: new Set([filteredListener]),\n      rawEmitter,\n      watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {\n        if (!cont.listeners.size) return;\n        if (flags & FSEVENT_FLAG_MUST_SCAN_SUBDIRS) return;\n        const info = fsevents.getInfo(fullPath, flags);\n        cont.listeners.forEach(list => {\n          list(fullPath, flags, info);\n        });\n\n        cont.rawEmitter(info.event, fullPath, info);\n      })\n    };\n    FSEventsWatchers.set(watchPath, cont);\n  }\n\n  // removes this instance's listeners and closes the underlying fsevents\n  // instance if there are no more listeners left\n  return () => {\n    const lst = cont.listeners;\n\n    lst.delete(filteredListener);\n    if (!lst.size) {\n      FSEventsWatchers.delete(watchPath);\n      if (cont.watcher) return cont.watcher.stop().then(() => {\n        cont.rawEmitter = cont.watcher = undefined;\n        Object.freeze(cont);\n      });\n    }\n  };\n}\n\n// Decide whether or not we should start a new higher-level\n// parent watcher\nconst couldConsolidate = (path) => {\n  let count = 0;\n  for (const watchPath of FSEventsWatchers.keys()) {\n    if (watchPath.indexOf(path) === 0) {\n      count++;\n      if (count >= consolidateThreshhold) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\n// returns boolean indicating whether fsevents can be used\nconst canUse = () => fsevents && FSEventsWatchers.size < 128;\n\n// determines subdirectory traversal levels from root to path\nconst calcDepth = (path, root) => {\n  let i = 0;\n  while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root) i++;\n  return i;\n};\n\n// returns boolean indicating whether the fsevents' event info has the same type\n// as the one returned by fs.stat\nconst sameTypes = (info, stats) => (\n  info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() ||\n  info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() ||\n  info.type === FSEVENT_TYPE_FILE && stats.isFile()\n)\n\n/**\n * @mixin\n */\nclass FsEventsHandler {\n\n/**\n * @param {import('../index').FSWatcher} fsw\n */\nconstructor(fsw) {\n  this.fsw = fsw;\n}\ncheckIgnored(path, stats) {\n  const ipaths = this.fsw._ignoredPaths;\n  if (this.fsw._isIgnored(path, stats)) {\n    ipaths.add(path);\n    if (stats && stats.isDirectory()) {\n      ipaths.add(path + ROOT_GLOBSTAR);\n    }\n    return true;\n  }\n\n  ipaths.delete(path);\n  ipaths.delete(path + ROOT_GLOBSTAR);\n}\n\naddOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  const event = watchedDir.has(item) ? EV_CHANGE : EV_ADD;\n  this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n}\n\nasync checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  try {\n    const stats = await stat(path)\n    if (this.fsw.closed) return;\n    if (sameTypes(info, stats)) {\n      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    } else {\n      this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    }\n  } catch (error) {\n    if (error.code === 'EACCES') {\n      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    } else {\n      this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    }\n  }\n}\n\nhandleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  if (this.fsw.closed || this.checkIgnored(path)) return;\n\n  if (event === EV_UNLINK) {\n    const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY\n    // suppress unlink events on never before seen files\n    if (isDirectory || watchedDir.has(item)) {\n      this.fsw._remove(parent, item, isDirectory);\n    }\n  } else {\n    if (event === EV_ADD) {\n      // track new directories\n      if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path);\n\n      if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {\n        // push symlinks back to the top of the stack to get handled\n        const curDepth = opts.depth === undefined ?\n          undefined : calcDepth(fullPath, realPath) + 1;\n        return this._addToFsEvents(path, false, true, curDepth);\n      }\n\n      // track new paths\n      // (other than symlinks being followed, which will be tracked soon)\n      this.fsw._getWatchedDir(parent).add(item);\n    }\n    /**\n     * @type {'add'|'addDir'|'unlink'|'unlinkDir'}\n     */\n    const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;\n    this.fsw._emit(eventName, path);\n    if (eventName === EV_ADD_DIR) this._addToFsEvents(path, false, true);\n  }\n}\n\n/**\n * Handle symlinks encountered during directory scan\n * @param {String} watchPath  - file/dir path to be watched with fsevents\n * @param {String} realPath   - real path (in case of symlinks)\n * @param {Function} transform  - path transformer\n * @param {Function} globFilter - path filter in case a glob pattern was provided\n * @returns {Function} closer for the watcher instance\n*/\n_watchWithFsEvents(watchPath, realPath, transform, globFilter) {\n  if (this.fsw.closed || this.fsw._isIgnored(watchPath)) return;\n  const opts = this.fsw.options;\n  const watchCallback = async (fullPath, flags, info) => {\n    if (this.fsw.closed) return;\n    if (\n      opts.depth !== undefined &&\n      calcDepth(fullPath, realPath) > opts.depth\n    ) return;\n    const path = transform(sysPath.join(\n      watchPath, sysPath.relative(watchPath, fullPath)\n    ));\n    if (globFilter && !globFilter(path)) return;\n    // ensure directories are tracked\n    const parent = sysPath.dirname(path);\n    const item = sysPath.basename(path);\n    const watchedDir = this.fsw._getWatchedDir(\n      info.type === FSEVENT_TYPE_DIRECTORY ? path : parent\n    );\n\n    // correct for wrong events emitted\n    if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {\n      if (typeof opts.ignored === FUNCTION_TYPE) {\n        let stats;\n        try {\n          stats = await stat(path);\n        } catch (error) {}\n        if (this.fsw.closed) return;\n        if (this.checkIgnored(path, stats)) return;\n        if (sameTypes(info, stats)) {\n          this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        } else {\n          this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        }\n      } else {\n        this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    } else {\n      switch (info.event) {\n      case FSEVENT_CREATED:\n      case FSEVENT_MODIFIED:\n        return this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      case FSEVENT_DELETED:\n      case FSEVENT_MOVED:\n        return this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    }\n  };\n\n  const closer = setFSEventsListener(\n    watchPath,\n    realPath,\n    watchCallback,\n    this.fsw._emitRaw\n  );\n\n  this.fsw._emitReady();\n  return closer;\n}\n\n/**\n * Handle symlinks encountered during directory scan\n * @param {String} linkPath path to symlink\n * @param {String} fullPath absolute path to the symlink\n * @param {Function} transform pre-existing path transformer\n * @param {Number} curDepth level of subdirectories traversed to where symlink is\n * @returns {Promise<void>}\n */\nasync _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {\n  // don't follow the same symlink more than once\n  if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath)) return;\n\n  this.fsw._symlinkPaths.set(fullPath, true);\n  this.fsw._incrReadyCount();\n\n  try {\n    const linkTarget = await realpath(linkPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(linkTarget)) {\n      return this.fsw._emitReady();\n    }\n\n    this.fsw._incrReadyCount();\n\n    // add the linkTarget for watching with a wrapper for transform\n    // that causes emitted paths to incorporate the link's path\n    this._addToFsEvents(linkTarget || linkPath, (path) => {\n      let aliasedPath = linkPath;\n      if (linkTarget && linkTarget !== DOT_SLASH) {\n        aliasedPath = path.replace(linkTarget, linkPath);\n      } else if (path !== DOT_SLASH) {\n        aliasedPath = sysPath.join(linkPath, path);\n      }\n      return transform(aliasedPath);\n    }, false, curDepth);\n  } catch(error) {\n    if (this.fsw._handleError(error)) {\n      return this.fsw._emitReady();\n    }\n  }\n}\n\n/**\n *\n * @param {Path} newPath\n * @param {fs.Stats} stats\n */\nemitAdd(newPath, stats, processPath, opts, forceAdd) {\n  const pp = processPath(newPath);\n  const isDir = stats.isDirectory();\n  const dirObj = this.fsw._getWatchedDir(sysPath.dirname(pp));\n  const base = sysPath.basename(pp);\n\n  // ensure empty dirs get tracked\n  if (isDir) this.fsw._getWatchedDir(pp);\n  if (dirObj.has(base)) return;\n  dirObj.add(base);\n\n  if (!opts.ignoreInitial || forceAdd === true) {\n    this.fsw._emit(isDir ? EV_ADD_DIR : EV_ADD, pp, stats);\n  }\n}\n\ninitWatch(realPath, path, wh, processPath) {\n  if (this.fsw.closed) return;\n  const closer = this._watchWithFsEvents(\n    wh.watchPath,\n    sysPath.resolve(realPath || wh.watchPath),\n    processPath,\n    wh.globFilter\n  );\n  this.fsw._addPathCloser(path, closer);\n}\n\n/**\n * Handle added path with fsevents\n * @param {String} path file/dir path or glob pattern\n * @param {Function|Boolean=} transform converts working path to what the user expects\n * @param {Boolean=} forceAdd ensure add is emitted\n * @param {Number=} priorDepth Level of subdirectories already traversed.\n * @returns {Promise<void>}\n */\nasync _addToFsEvents(path, transform, forceAdd, priorDepth) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const opts = this.fsw.options;\n  const processPath = typeof transform === FUNCTION_TYPE ? transform : IDENTITY_FN;\n\n  const wh = this.fsw._getWatchHelpers(path);\n\n  // evaluate what is at the path we're being asked to watch\n  try {\n    const stats = await statMethods[wh.statMethod](wh.watchPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(wh.watchPath, stats)) {\n      throw null;\n    }\n    if (stats.isDirectory()) {\n      // emit addDir unless this is a glob parent\n      if (!wh.globFilter) this.emitAdd(processPath(path), stats, processPath, opts, forceAdd);\n\n      // don't recurse further if it would exceed depth setting\n      if (priorDepth && priorDepth > opts.depth) return;\n\n      // scan the contents of the dir\n      this.fsw._readdirp(wh.watchPath, {\n        fileFilter: entry => wh.filterPath(entry),\n        directoryFilter: entry => wh.filterDir(entry),\n        ...Depth(opts.depth - (priorDepth || 0))\n      }).on(STR_DATA, (entry) => {\n        // need to check filterPath on dirs b/c filterDir is less restrictive\n        if (this.fsw.closed) {\n          return;\n        }\n        if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;\n\n        const joinedPath = sysPath.join(wh.watchPath, entry.path);\n        const {fullPath} = entry;\n\n        if (wh.followSymlinks && entry.stats.isSymbolicLink()) {\n          // preserve the current depth here since it can't be derived from\n          // real paths past the symlink\n          const curDepth = opts.depth === undefined ?\n            undefined : calcDepth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;\n\n          this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);\n        } else {\n          this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);\n        }\n      }).on(EV_ERROR, EMPTY_FN).on(STR_END, () => {\n        this.fsw._emitReady();\n      });\n    } else {\n      this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);\n      this.fsw._emitReady();\n    }\n  } catch (error) {\n    if (!error || this.fsw._handleError(error)) {\n      // TODO: Strange thing: \"should not choke on an ignored watch path\" will be failed without 2 ready calls -__-\n      this.fsw._emitReady();\n      this.fsw._emitReady();\n    }\n  }\n\n  if (opts.persistent && forceAdd !== true) {\n    if (typeof transform === FUNCTION_TYPE) {\n      // realpath has already been resolved\n      this.initWatch(undefined, path, wh, processPath);\n    } else {\n      let realPath;\n      try {\n        realPath = await realpath(wh.watchPath);\n      } catch (e) {}\n      this.initWatch(realPath, path, wh, processPath);\n    }\n  }\n}\n\n}\n\nmodule.exports = FsEventsHandler;\nmodule.exports.canUse = canUse;\n","'use strict';\n\nconst { EventEmitter } = require('events');\nconst fs = require('fs');\nconst sysPath = require('path');\nconst { promisify } = require('util');\nconst readdirp = require('readdirp');\nconst anymatch = require('anymatch').default;\nconst globParent = require('glob-parent');\nconst isGlob = require('is-glob');\nconst braces = require('braces');\nconst normalizePath = require('normalize-path');\n\nconst NodeFsHandler = require('./lib/nodefs-handler');\nconst FsEventsHandler = require('./lib/fsevents-handler');\nconst {\n  EV_ALL,\n  EV_READY,\n  EV_ADD,\n  EV_CHANGE,\n  EV_UNLINK,\n  EV_ADD_DIR,\n  EV_UNLINK_DIR,\n  EV_RAW,\n  EV_ERROR,\n\n  STR_CLOSE,\n  STR_END,\n\n  BACK_SLASH_RE,\n  DOUBLE_SLASH_RE,\n  SLASH_OR_BACK_SLASH_RE,\n  DOT_RE,\n  REPLACER_RE,\n\n  SLASH,\n  SLASH_SLASH,\n  BRACE_START,\n  BANG,\n  ONE_DOT,\n  TWO_DOTS,\n  GLOBSTAR,\n  SLASH_GLOBSTAR,\n  ANYMATCH_OPTS,\n  STRING_TYPE,\n  FUNCTION_TYPE,\n  EMPTY_STR,\n  EMPTY_FN,\n\n  isWindows,\n  isMacos,\n  isIBMi\n} = require('./lib/constants');\n\nconst stat = promisify(fs.stat);\nconst readdir = promisify(fs.readdir);\n\n/**\n * @typedef {String} Path\n * @typedef {'all'|'add'|'addDir'|'change'|'unlink'|'unlinkDir'|'raw'|'error'|'ready'} EventName\n * @typedef {'readdir'|'watch'|'add'|'remove'|'change'} ThrottleType\n */\n\n/**\n *\n * @typedef {Object} WatchHelpers\n * @property {Boolean} followSymlinks\n * @property {'stat'|'lstat'} statMethod\n * @property {Path} path\n * @property {Path} watchPath\n * @property {Function} entryPath\n * @property {Boolean} hasGlob\n * @property {Object} globFilter\n * @property {Function} filterPath\n * @property {Function} filterDir\n */\n\nconst arrify = (value = []) => Array.isArray(value) ? value : [value];\nconst flatten = (list, result = []) => {\n  list.forEach(item => {\n    if (Array.isArray(item)) {\n      flatten(item, result);\n    } else {\n      result.push(item);\n    }\n  });\n  return result;\n};\n\nconst unifyPaths = (paths_) => {\n  /**\n   * @type {Array<String>}\n   */\n  const paths = flatten(arrify(paths_));\n  if (!paths.every(p => typeof p === STRING_TYPE)) {\n    throw new TypeError(`Non-string provided as watch path: ${paths}`);\n  }\n  return paths.map(normalizePathToUnix);\n};\n\n// If SLASH_SLASH occurs at the beginning of path, it is not replaced\n//     because \"//StoragePC/DrivePool/Movies\" is a valid network path\nconst toUnix = (string) => {\n  let str = string.replace(BACK_SLASH_RE, SLASH);\n  let prepend = false;\n  if (str.startsWith(SLASH_SLASH)) {\n    prepend = true;\n  }\n  while (str.match(DOUBLE_SLASH_RE)) {\n    str = str.replace(DOUBLE_SLASH_RE, SLASH);\n  }\n  if (prepend) {\n    str = SLASH + str;\n  }\n  return str;\n};\n\n// Our version of upath.normalize\n// TODO: this is not equal to path-normalize module - investigate why\nconst normalizePathToUnix = (path) => toUnix(sysPath.normalize(toUnix(path)));\n\nconst normalizeIgnored = (cwd = EMPTY_STR) => (path) => {\n  if (typeof path !== STRING_TYPE) return path;\n  return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));\n};\n\nconst getAbsolutePath = (path, cwd) => {\n  if (sysPath.isAbsolute(path)) {\n    return path;\n  }\n  if (path.startsWith(BANG)) {\n    return BANG + sysPath.join(cwd, path.slice(1));\n  }\n  return sysPath.join(cwd, path);\n};\n\nconst undef = (opts, key) => opts[key] === undefined;\n\n/**\n * Directory entry.\n * @property {Path} path\n * @property {Set<Path>} items\n */\nclass DirEntry {\n  /**\n   * @param {Path} dir\n   * @param {Function} removeWatcher\n   */\n  constructor(dir, removeWatcher) {\n    this.path = dir;\n    this._removeWatcher = removeWatcher;\n    /** @type {Set<Path>} */\n    this.items = new Set();\n  }\n\n  add(item) {\n    const {items} = this;\n    if (!items) return;\n    if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);\n  }\n\n  async remove(item) {\n    const {items} = this;\n    if (!items) return;\n    items.delete(item);\n    if (items.size > 0) return;\n\n    const dir = this.path;\n    try {\n      await readdir(dir);\n    } catch (err) {\n      if (this._removeWatcher) {\n        this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));\n      }\n    }\n  }\n\n  has(item) {\n    const {items} = this;\n    if (!items) return;\n    return items.has(item);\n  }\n\n  /**\n   * @returns {Array<String>}\n   */\n  getChildren() {\n    const {items} = this;\n    if (!items) return;\n    return [...items.values()];\n  }\n\n  dispose() {\n    this.items.clear();\n    delete this.path;\n    delete this._removeWatcher;\n    delete this.items;\n    Object.freeze(this);\n  }\n}\n\nconst STAT_METHOD_F = 'stat';\nconst STAT_METHOD_L = 'lstat';\nclass WatchHelper {\n  constructor(path, watchPath, follow, fsw) {\n    this.fsw = fsw;\n    this.path = path = path.replace(REPLACER_RE, EMPTY_STR);\n    this.watchPath = watchPath;\n    this.fullWatchPath = sysPath.resolve(watchPath);\n    this.hasGlob = watchPath !== path;\n    /** @type {object|boolean} */\n    if (path === EMPTY_STR) this.hasGlob = false;\n    this.globSymlink = this.hasGlob && follow ? undefined : false;\n    this.globFilter = this.hasGlob ? anymatch(path, undefined, ANYMATCH_OPTS) : false;\n    this.dirParts = this.getDirParts(path);\n    this.dirParts.forEach((parts) => {\n      if (parts.length > 1) parts.pop();\n    });\n    this.followSymlinks = follow;\n    this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;\n  }\n\n  checkGlobSymlink(entry) {\n    // only need to resolve once\n    // first entry should always have entry.parentDir === EMPTY_STR\n    if (this.globSymlink === undefined) {\n      this.globSymlink = entry.fullParentDir === this.fullWatchPath ?\n        false : {realPath: entry.fullParentDir, linkPath: this.fullWatchPath};\n    }\n\n    if (this.globSymlink) {\n      return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);\n    }\n\n    return entry.fullPath;\n  }\n\n  entryPath(entry) {\n    return sysPath.join(this.watchPath,\n      sysPath.relative(this.watchPath, this.checkGlobSymlink(entry))\n    );\n  }\n\n  filterPath(entry) {\n    const {stats} = entry;\n    if (stats && stats.isSymbolicLink()) return this.filterDir(entry);\n    const resolvedPath = this.entryPath(entry);\n    const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ?\n      this.globFilter(resolvedPath) : true;\n    return matchesGlob &&\n      this.fsw._isntIgnored(resolvedPath, stats) &&\n      this.fsw._hasReadPermissions(stats);\n  }\n\n  getDirParts(path) {\n    if (!this.hasGlob) return [];\n    const parts = [];\n    const expandedPath = path.includes(BRACE_START) ? braces.expand(path) : [path];\n    expandedPath.forEach((path) => {\n      parts.push(sysPath.relative(this.watchPath, path).split(SLASH_OR_BACK_SLASH_RE));\n    });\n    return parts;\n  }\n\n  filterDir(entry) {\n    if (this.hasGlob) {\n      const entryParts = this.getDirParts(this.checkGlobSymlink(entry));\n      let globstar = false;\n      this.unmatchedGlob = !this.dirParts.some((parts) => {\n        return parts.every((part, i) => {\n          if (part === GLOBSTAR) globstar = true;\n          return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);\n        });\n      });\n    }\n    return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);\n  }\n}\n\n/**\n * Watches files & directories for changes. Emitted events:\n * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`\n *\n *     new FSWatcher()\n *       .add(directories)\n *       .on('add', path => log('File', path, 'was added'))\n */\nclass FSWatcher extends EventEmitter {\n// Not indenting methods for history sake; for now.\nconstructor(_opts) {\n  super();\n\n  const opts = {};\n  if (_opts) Object.assign(opts, _opts); // for frozen objects\n\n  /** @type {Map<String, DirEntry>} */\n  this._watched = new Map();\n  /** @type {Map<String, Array>} */\n  this._closers = new Map();\n  /** @type {Set<String>} */\n  this._ignoredPaths = new Set();\n\n  /** @type {Map<ThrottleType, Map>} */\n  this._throttled = new Map();\n\n  /** @type {Map<Path, String|Boolean>} */\n  this._symlinkPaths = new Map();\n\n  this._streams = new Set();\n  this.closed = false;\n\n  // Set up default options.\n  if (undef(opts, 'persistent')) opts.persistent = true;\n  if (undef(opts, 'ignoreInitial')) opts.ignoreInitial = false;\n  if (undef(opts, 'ignorePermissionErrors')) opts.ignorePermissionErrors = false;\n  if (undef(opts, 'interval')) opts.interval = 100;\n  if (undef(opts, 'binaryInterval')) opts.binaryInterval = 300;\n  if (undef(opts, 'disableGlobbing')) opts.disableGlobbing = false;\n  opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;\n\n  // Enable fsevents on OS X when polling isn't explicitly enabled.\n  if (undef(opts, 'useFsEvents')) opts.useFsEvents = !opts.usePolling;\n\n  // If we can't use fsevents, ensure the options reflect it's disabled.\n  const canUseFsEvents = FsEventsHandler.canUse();\n  if (!canUseFsEvents) opts.useFsEvents = false;\n\n  // Use polling on Mac if not using fsevents.\n  // Other platforms use non-polling fs_watch.\n  if (undef(opts, 'usePolling') && !opts.useFsEvents) {\n    opts.usePolling = isMacos;\n  }\n\n  // Always default to polling on IBM i because fs.watch() is not available on IBM i.\n  if(isIBMi) {\n    opts.usePolling = true;\n  }\n\n  // Global override (useful for end-developers that need to force polling for all\n  // instances of chokidar, regardless of usage/dependency depth)\n  const envPoll = process.env.CHOKIDAR_USEPOLLING;\n  if (envPoll !== undefined) {\n    const envLower = envPoll.toLowerCase();\n\n    if (envLower === 'false' || envLower === '0') {\n      opts.usePolling = false;\n    } else if (envLower === 'true' || envLower === '1') {\n      opts.usePolling = true;\n    } else {\n      opts.usePolling = !!envLower;\n    }\n  }\n  const envInterval = process.env.CHOKIDAR_INTERVAL;\n  if (envInterval) {\n    opts.interval = Number.parseInt(envInterval, 10);\n  }\n\n  // Editor atomic write normalization enabled by default with fs.watch\n  if (undef(opts, 'atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;\n  if (opts.atomic) this._pendingUnlinks = new Map();\n\n  if (undef(opts, 'followSymlinks')) opts.followSymlinks = true;\n\n  if (undef(opts, 'awaitWriteFinish')) opts.awaitWriteFinish = false;\n  if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};\n  const awf = opts.awaitWriteFinish;\n  if (awf) {\n    if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;\n    if (!awf.pollInterval) awf.pollInterval = 100;\n    this._pendingWrites = new Map();\n  }\n  if (opts.ignored) opts.ignored = arrify(opts.ignored);\n\n  let readyCalls = 0;\n  this._emitReady = () => {\n    readyCalls++;\n    if (readyCalls >= this._readyCount) {\n      this._emitReady = EMPTY_FN;\n      this._readyEmitted = true;\n      // use process.nextTick to allow time for listener to be bound\n      process.nextTick(() => this.emit(EV_READY));\n    }\n  };\n  this._emitRaw = (...args) => this.emit(EV_RAW, ...args);\n  this._readyEmitted = false;\n  this.options = opts;\n\n  // Initialize with proper watcher.\n  if (opts.useFsEvents) {\n    this._fsEventsHandler = new FsEventsHandler(this);\n  } else {\n    this._nodeFsHandler = new NodeFsHandler(this);\n  }\n\n  // Youre frozen when your hearts not open.\n  Object.freeze(opts);\n}\n\n// Public methods\n\n/**\n * Adds paths to be watched on an existing FSWatcher instance\n * @param {Path|Array<Path>} paths_\n * @param {String=} _origAdd private; for handling non-existent paths to be watched\n * @param {Boolean=} _internal private; indicates a non-user add\n * @returns {FSWatcher} for chaining\n */\nadd(paths_, _origAdd, _internal) {\n  const {cwd, disableGlobbing} = this.options;\n  this.closed = false;\n  let paths = unifyPaths(paths_);\n  if (cwd) {\n    paths = paths.map((path) => {\n      const absPath = getAbsolutePath(path, cwd);\n\n      // Check `path` instead of `absPath` because the cwd portion can't be a glob\n      if (disableGlobbing || !isGlob(path)) {\n        return absPath;\n      }\n      return normalizePath(absPath);\n    });\n  }\n\n  // set aside negated glob strings\n  paths = paths.filter((path) => {\n    if (path.startsWith(BANG)) {\n      this._ignoredPaths.add(path.slice(1));\n      return false;\n    }\n\n    // if a path is being added that was previously ignored, stop ignoring it\n    this._ignoredPaths.delete(path);\n    this._ignoredPaths.delete(path + SLASH_GLOBSTAR);\n\n    // reset the cached userIgnored anymatch fn\n    // to make ignoredPaths changes effective\n    this._userIgnored = undefined;\n\n    return true;\n  });\n\n  if (this.options.useFsEvents && this._fsEventsHandler) {\n    if (!this._readyCount) this._readyCount = paths.length;\n    if (this.options.persistent) this._readyCount += paths.length;\n    paths.forEach((path) => this._fsEventsHandler._addToFsEvents(path));\n  } else {\n    if (!this._readyCount) this._readyCount = 0;\n    this._readyCount += paths.length;\n    Promise.all(\n      paths.map(async path => {\n        const res = await this._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd);\n        if (res) this._emitReady();\n        return res;\n      })\n    ).then(results => {\n      if (this.closed) return;\n      results.filter(item => item).forEach(item => {\n        this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));\n      });\n    });\n  }\n\n  return this;\n}\n\n/**\n * Close watchers or start ignoring events from specified paths.\n * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs\n * @returns {FSWatcher} for chaining\n*/\nunwatch(paths_) {\n  if (this.closed) return this;\n  const paths = unifyPaths(paths_);\n  const {cwd} = this.options;\n\n  paths.forEach((path) => {\n    // convert to absolute path unless relative path already matches\n    if (!sysPath.isAbsolute(path) && !this._closers.has(path)) {\n      if (cwd) path = sysPath.join(cwd, path);\n      path = sysPath.resolve(path);\n    }\n\n    this._closePath(path);\n\n    this._ignoredPaths.add(path);\n    if (this._watched.has(path)) {\n      this._ignoredPaths.add(path + SLASH_GLOBSTAR);\n    }\n\n    // reset the cached userIgnored anymatch fn\n    // to make ignoredPaths changes effective\n    this._userIgnored = undefined;\n  });\n\n  return this;\n}\n\n/**\n * Close watchers and remove all listeners from watched paths.\n * @returns {Promise<void>}.\n*/\nclose() {\n  if (this.closed) return this._closePromise;\n  this.closed = true;\n\n  // Memory management.\n  this.removeAllListeners();\n  const closers = [];\n  this._closers.forEach(closerList => closerList.forEach(closer => {\n    const promise = closer();\n    if (promise instanceof Promise) closers.push(promise);\n  }));\n  this._streams.forEach(stream => stream.destroy());\n  this._userIgnored = undefined;\n  this._readyCount = 0;\n  this._readyEmitted = false;\n  this._watched.forEach(dirent => dirent.dispose());\n  ['closers', 'watched', 'streams', 'symlinkPaths', 'throttled'].forEach(key => {\n    this[`_${key}`].clear();\n  });\n\n  this._closePromise = closers.length ? Promise.all(closers).then(() => undefined) : Promise.resolve();\n  return this._closePromise;\n}\n\n/**\n * Expose list of watched paths\n * @returns {Object} for chaining\n*/\ngetWatched() {\n  const watchList = {};\n  this._watched.forEach((entry, dir) => {\n    const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;\n    watchList[key || ONE_DOT] = entry.getChildren().sort();\n  });\n  return watchList;\n}\n\nemitWithAll(event, args) {\n  this.emit(...args);\n  if (event !== EV_ERROR) this.emit(EV_ALL, ...args);\n}\n\n// Common helpers\n// --------------\n\n/**\n * Normalize and emit events.\n * Calling _emit DOES NOT MEAN emit() would be called!\n * @param {EventName} event Type of event\n * @param {Path} path File or directory path\n * @param {*=} val1 arguments to be passed with event\n * @param {*=} val2\n * @param {*=} val3\n * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n */\nasync _emit(event, path, val1, val2, val3) {\n  if (this.closed) return;\n\n  const opts = this.options;\n  if (isWindows) path = sysPath.normalize(path);\n  if (opts.cwd) path = sysPath.relative(opts.cwd, path);\n  /** @type Array<any> */\n  const args = [event, path];\n  if (val3 !== undefined) args.push(val1, val2, val3);\n  else if (val2 !== undefined) args.push(val1, val2);\n  else if (val1 !== undefined) args.push(val1);\n\n  const awf = opts.awaitWriteFinish;\n  let pw;\n  if (awf && (pw = this._pendingWrites.get(path))) {\n    pw.lastChange = new Date();\n    return this;\n  }\n\n  if (opts.atomic) {\n    if (event === EV_UNLINK) {\n      this._pendingUnlinks.set(path, args);\n      setTimeout(() => {\n        this._pendingUnlinks.forEach((entry, path) => {\n          this.emit(...entry);\n          this.emit(EV_ALL, ...entry);\n          this._pendingUnlinks.delete(path);\n        });\n      }, typeof opts.atomic === 'number' ? opts.atomic : 100);\n      return this;\n    }\n    if (event === EV_ADD && this._pendingUnlinks.has(path)) {\n      event = args[0] = EV_CHANGE;\n      this._pendingUnlinks.delete(path);\n    }\n  }\n\n  if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {\n    const awfEmit = (err, stats) => {\n      if (err) {\n        event = args[0] = EV_ERROR;\n        args[1] = err;\n        this.emitWithAll(event, args);\n      } else if (stats) {\n        // if stats doesn't exist the file must have been deleted\n        if (args.length > 2) {\n          args[2] = stats;\n        } else {\n          args.push(stats);\n        }\n        this.emitWithAll(event, args);\n      }\n    };\n\n    this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);\n    return this;\n  }\n\n  if (event === EV_CHANGE) {\n    const isThrottled = !this._throttle(EV_CHANGE, path, 50);\n    if (isThrottled) return this;\n  }\n\n  if (opts.alwaysStat && val1 === undefined &&\n    (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)\n  ) {\n    const fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;\n    let stats;\n    try {\n      stats = await stat(fullPath);\n    } catch (err) {}\n    // Suppress event when fs_stat fails, to avoid sending undefined 'stat'\n    if (!stats || this.closed) return;\n    args.push(stats);\n  }\n  this.emitWithAll(event, args);\n\n  return this;\n}\n\n/**\n * Common handler for errors\n * @param {Error} error\n * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n */\n_handleError(error) {\n  const code = error && error.code;\n  if (error && code !== 'ENOENT' && code !== 'ENOTDIR' &&\n    (!this.options.ignorePermissionErrors || (code !== 'EPERM' && code !== 'EACCES'))\n  ) {\n    this.emit(EV_ERROR, error);\n  }\n  return error || this.closed;\n}\n\n/**\n * Helper utility for throttling\n * @param {ThrottleType} actionType type being throttled\n * @param {Path} path being acted upon\n * @param {Number} timeout duration of time to suppress duplicate actions\n * @returns {Object|false} tracking object or false if action should be suppressed\n */\n_throttle(actionType, path, timeout) {\n  if (!this._throttled.has(actionType)) {\n    this._throttled.set(actionType, new Map());\n  }\n\n  /** @type {Map<Path, Object>} */\n  const action = this._throttled.get(actionType);\n  /** @type {Object} */\n  const actionPath = action.get(path);\n\n  if (actionPath) {\n    actionPath.count++;\n    return false;\n  }\n\n  let timeoutObject;\n  const clear = () => {\n    const item = action.get(path);\n    const count = item ? item.count : 0;\n    action.delete(path);\n    clearTimeout(timeoutObject);\n    if (item) clearTimeout(item.timeoutObject);\n    return count;\n  };\n  timeoutObject = setTimeout(clear, timeout);\n  const thr = {timeoutObject, clear, count: 0};\n  action.set(path, thr);\n  return thr;\n}\n\n_incrReadyCount() {\n  return this._readyCount++;\n}\n\n/**\n * Awaits write operation to finish.\n * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.\n * @param {Path} path being acted upon\n * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished\n * @param {EventName} event\n * @param {Function} awfEmit Callback to be called when ready for event to be emitted.\n */\n_awaitWriteFinish(path, threshold, event, awfEmit) {\n  let timeoutHandler;\n\n  let fullPath = path;\n  if (this.options.cwd && !sysPath.isAbsolute(path)) {\n    fullPath = sysPath.join(this.options.cwd, path);\n  }\n\n  const now = new Date();\n\n  const awaitWriteFinish = (prevStat) => {\n    fs.stat(fullPath, (err, curStat) => {\n      if (err || !this._pendingWrites.has(path)) {\n        if (err && err.code !== 'ENOENT') awfEmit(err);\n        return;\n      }\n\n      const now = Number(new Date());\n\n      if (prevStat && curStat.size !== prevStat.size) {\n        this._pendingWrites.get(path).lastChange = now;\n      }\n      const pw = this._pendingWrites.get(path);\n      const df = now - pw.lastChange;\n\n      if (df >= threshold) {\n        this._pendingWrites.delete(path);\n        awfEmit(undefined, curStat);\n      } else {\n        timeoutHandler = setTimeout(\n          awaitWriteFinish,\n          this.options.awaitWriteFinish.pollInterval,\n          curStat\n        );\n      }\n    });\n  };\n\n  if (!this._pendingWrites.has(path)) {\n    this._pendingWrites.set(path, {\n      lastChange: now,\n      cancelWait: () => {\n        this._pendingWrites.delete(path);\n        clearTimeout(timeoutHandler);\n        return event;\n      }\n    });\n    timeoutHandler = setTimeout(\n      awaitWriteFinish,\n      this.options.awaitWriteFinish.pollInterval\n    );\n  }\n}\n\n_getGlobIgnored() {\n  return [...this._ignoredPaths.values()];\n}\n\n/**\n * Determines whether user has asked to ignore this path.\n * @param {Path} path filepath or dir\n * @param {fs.Stats=} stats result of fs.stat\n * @returns {Boolean}\n */\n_isIgnored(path, stats) {\n  if (this.options.atomic && DOT_RE.test(path)) return true;\n  if (!this._userIgnored) {\n    const {cwd} = this.options;\n    const ign = this.options.ignored;\n\n    const ignored = ign && ign.map(normalizeIgnored(cwd));\n    const paths = arrify(ignored)\n      .filter((path) => typeof path === STRING_TYPE && !isGlob(path))\n      .map((path) => path + SLASH_GLOBSTAR);\n    const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);\n    this._userIgnored = anymatch(list, undefined, ANYMATCH_OPTS);\n  }\n\n  return this._userIgnored([path, stats]);\n}\n\n_isntIgnored(path, stat) {\n  return !this._isIgnored(path, stat);\n}\n\n/**\n * Provides a set of common helpers and properties relating to symlink and glob handling.\n * @param {Path} path file, directory, or glob pattern being watched\n * @param {Number=} depth at any depth > 0, this isn't a glob\n * @returns {WatchHelper} object containing helpers for this path\n */\n_getWatchHelpers(path, depth) {\n  const watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);\n  const follow = this.options.followSymlinks;\n\n  return new WatchHelper(path, watchPath, follow, this);\n}\n\n// Directory helpers\n// -----------------\n\n/**\n * Provides directory tracking objects\n * @param {String} directory path of the directory\n * @returns {DirEntry} the directory's tracking object\n */\n_getWatchedDir(directory) {\n  if (!this._boundRemove) this._boundRemove = this._remove.bind(this);\n  const dir = sysPath.resolve(directory);\n  if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));\n  return this._watched.get(dir);\n}\n\n// File helpers\n// ------------\n\n/**\n * Check for read permissions.\n * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405\n * @param {fs.Stats} stats - object, result of fs_stat\n * @returns {Boolean} indicates whether the file can be read\n*/\n_hasReadPermissions(stats) {\n  if (this.options.ignorePermissionErrors) return true;\n\n  // stats.mode may be bigint\n  const md = stats && Number.parseInt(stats.mode, 10);\n  const st = md & 0o777;\n  const it = Number.parseInt(st.toString(8)[0], 10);\n  return Boolean(4 & it);\n}\n\n/**\n * Handles emitting unlink events for\n * files and directories, and via recursion, for\n * files and directories within directories that are unlinked\n * @param {String} directory within which the following item is located\n * @param {String} item      base path of item/directory\n * @returns {void}\n*/\n_remove(directory, item, isDirectory) {\n  // if what is being deleted is a directory, get that directory's paths\n  // for recursive deleting and cleaning of watched object\n  // if it is not a directory, nestedDirectoryChildren will be empty array\n  const path = sysPath.join(directory, item);\n  const fullPath = sysPath.resolve(path);\n  isDirectory = isDirectory != null\n    ? isDirectory\n    : this._watched.has(path) || this._watched.has(fullPath);\n\n  // prevent duplicate handling in case of arriving here nearly simultaneously\n  // via multiple paths (such as _handleFile and _handleDir)\n  if (!this._throttle('remove', path, 100)) return;\n\n  // if the only watched file is removed, watch for its return\n  if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {\n    this.add(directory, item, true);\n  }\n\n  // This will create a new entry in the watched object in either case\n  // so we got to do the directory check beforehand\n  const wp = this._getWatchedDir(path);\n  const nestedDirectoryChildren = wp.getChildren();\n\n  // Recursively remove children directories / files.\n  nestedDirectoryChildren.forEach(nested => this._remove(path, nested));\n\n  // Check if item was on the watched list and remove it\n  const parent = this._getWatchedDir(directory);\n  const wasTracked = parent.has(item);\n  parent.remove(item);\n\n  // Fixes issue #1042 -> Relative paths were detected and added as symlinks\n  // (https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L612),\n  // but never removed from the map in case the path was deleted.\n  // This leads to an incorrect state if the path was recreated:\n  // https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L553\n  if (this._symlinkPaths.has(fullPath)) {\n    this._symlinkPaths.delete(fullPath);\n  }\n\n  // If we wait for this file to be fully written, cancel the wait.\n  let relPath = path;\n  if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);\n  if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {\n    const event = this._pendingWrites.get(relPath).cancelWait();\n    if (event === EV_ADD) return;\n  }\n\n  // The Entry will either be a directory that just got removed\n  // or a bogus entry to a file, in either case we have to remove it\n  this._watched.delete(path);\n  this._watched.delete(fullPath);\n  const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;\n  if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path);\n\n  // Avoid conflicts if we later create another file with the same name\n  if (!this.options.useFsEvents) {\n    this._closePath(path);\n  }\n}\n\n/**\n * Closes all watchers for a path\n * @param {Path} path\n */\n_closePath(path) {\n  this._closeFile(path)\n  const dir = sysPath.dirname(path);\n  this._getWatchedDir(dir).remove(sysPath.basename(path));\n}\n\n/**\n * Closes only file-specific watchers\n * @param {Path} path\n */\n_closeFile(path) {\n  const closers = this._closers.get(path);\n  if (!closers) return;\n  closers.forEach(closer => closer());\n  this._closers.delete(path);\n}\n\n/**\n *\n * @param {Path} path\n * @param {Function} closer\n */\n_addPathCloser(path, closer) {\n  if (!closer) return;\n  let list = this._closers.get(path);\n  if (!list) {\n    list = [];\n    this._closers.set(path, list);\n  }\n  list.push(closer);\n}\n\n_readdirp(root, opts) {\n  if (this.closed) return;\n  const options = {type: EV_ALL, alwaysStat: true, lstat: true, ...opts};\n  let stream = readdirp(root, options);\n  this._streams.add(stream);\n  stream.once(STR_CLOSE, () => {\n    stream = undefined;\n  });\n  stream.once(STR_END, () => {\n    if (stream) {\n      this._streams.delete(stream);\n      stream = undefined;\n    }\n  });\n  return stream;\n}\n\n}\n\n// Export FSWatcher class\nexports.FSWatcher = FSWatcher;\n\n/**\n * Instantiates watcher with paths to be tracked.\n * @param {String|Array<String>} paths file/directory paths and/or globs\n * @param {Object=} options chokidar opts\n * @returns an instance of FSWatcher for chaining.\n */\nconst watch = (paths, options) => {\n  const watcher = new FSWatcher(options);\n  watcher.add(paths);\n  return watcher;\n};\n\nexports.watch = watch;\n","/**\n * @fileoverview File system watchers for detecting workspace and git changes.\n * Uses chokidar to watch for file changes and emits debounced events.\n * @module main/watchers\n */\n\nimport chokidar, { type FSWatcher } from 'chokidar';\nimport path from 'node:path';\nimport { emitAppEvent } from '../events';\n\n/** File watcher for workspace files */\nlet fileWatcher: FSWatcher | null = null;\n/** Watcher for .git directory changes */\nlet gitWatcher: FSWatcher | null = null;\n/** Timer for debouncing event emissions */\nlet debounceTimer: NodeJS.Timeout | null = null;\n/** Pending events to emit after debounce */\nlet pending = {\n  workspace: false,\n  git: false,\n  diff: false\n};\n\n/**\n * Schedules events to be emitted after a debounce period.\n * Consolidates multiple rapid file changes into a single event emission.\n * @param {Partial<typeof pending>} events - Events to schedule for emission\n */\nfunction schedule(events: Partial<typeof pending>) {\n  pending = {\n    workspace: pending.workspace || Boolean(events.workspace),\n    git: pending.git || Boolean(events.git),\n    diff: pending.diff || Boolean(events.diff)\n  };\n\n  if (debounceTimer) clearTimeout(debounceTimer);\n  debounceTimer = setTimeout(() => {\n    if (pending.workspace) emitAppEvent('workspace:changed');\n    if (pending.git) emitAppEvent('git:changed');\n    if (pending.diff) emitAppEvent('diff:changed');\n\n    pending = { workspace: false, git: false, diff: false };\n    debounceTimer = null;\n  }, 250);\n}\n\n/**\n * Stops all active file system watchers.\n * @returns {Promise<void>}\n */\nexport async function stopWatchers() {\n  if (fileWatcher) {\n    await fileWatcher.close();\n    fileWatcher = null;\n  }\n  if (gitWatcher) {\n    await gitWatcher.close();\n    gitWatcher = null;\n  }\n}\n\n/**\n * Starts file system watchers for a workspace directory.\n * Watches for general file changes and git-specific changes separately.\n * @param {string} rootPath - Root directory path to watch\n * @returns {Promise<void>}\n */\nexport async function startWatchers(rootPath: string) {\n  await stopWatchers();\n\n  fileWatcher = chokidar.watch(rootPath, {\n    ignored: [\n      '**/node_modules/**',\n      '**/.git/**',\n      '**/dist/**',\n      '**/.next/**'\n    ],\n    ignoreInitial: true\n  });\n\n  fileWatcher.on('all', () => {\n    schedule({ workspace: true, git: true, diff: true });\n  });\n\n  gitWatcher = chokidar.watch(path.join(rootPath, '.git'), {\n    ignoreInitial: true,\n    depth: 5\n  });\n\n  gitWatcher.on('all', () => {\n    schedule({ git: true, diff: true });\n  });\n}\n","/**\n * @fileoverview Thread management module for the main process.\n * Provides functionality for creating, listing, renaming, and removing threads.\n * Stores thread state in a JSON file in the user data directory.\n * @module main/thread\n */\n\nimport { app } from 'electron';\nimport fs from 'node:fs/promises';\nimport path from 'node:path';\nimport { randomUUID } from 'node:crypto';\nimport type { Thread } from '../../shared/thread';\n\n/**\n * Internal store structure for thread management.\n */\ntype ThreadStore = {\n  threads: Thread[];\n};\n\n/** Current thread store held in memory */\nlet store: ThreadStore = { threads: [] };\n\n/**\n * Gets the file path for storing thread state.\n * @returns Path to threads.json in user data directory\n */\nfunction getStorePath() {\n  return path.join(app.getPath('userData'), 'threads.json');\n}\n\n/**\n * Loads thread state from the persistent storage file.\n * Initializes empty state if the file doesn't exist or is invalid.\n */\nasync function loadStore() {\n  try {\n    const data = await fs.readFile(getStorePath(), 'utf-8');\n    store = JSON.parse(data) as ThreadStore;\n  } catch {\n    store = { threads: [] };\n  }\n}\n\n/**\n * Saves the current thread state to the persistent storage file.\n */\nasync function saveStore() {\n  await fs.writeFile(getStorePath(), JSON.stringify(store, null, 2), 'utf-8');\n}\n\n/**\n * Initializes the thread module by loading saved state.\n */\nexport async function initThread() {\n  await loadStore();\n}\n\n/**\n * Lists all threads for a specific workspace.\n * @param workspaceId - The workspace ID to filter threads by\n * @returns Array of threads sorted by updatedAt descending\n */\nexport async function listThreads(workspaceId: string): Promise<Thread[]> {\n  return store.threads\n    .filter((t) => t.workspaceId === workspaceId)\n    .sort((a, b) => b.updatedAt - a.updatedAt);\n}\n\n/**\n * Creates a new thread in the specified workspace.\n * @param workspaceId - The workspace ID to create the thread in\n * @param title - The title of the new thread\n * @returns The newly created thread\n */\nexport async function createThread(workspaceId: string, title: string): Promise<Thread> {\n  const now = Date.now();\n  const thread: Thread = {\n    id: randomUUID(),\n    workspaceId,\n    title,\n    createdAt: now,\n    updatedAt: now\n  };\n  store.threads.push(thread);\n  await saveStore();\n  return thread;\n}\n\n/**\n * Renames an existing thread.\n * @param id - The thread ID to rename\n * @param title - The new title for the thread\n * @returns The updated thread or null if not found\n */\nexport async function renameThread(id: string, title: string): Promise<Thread | null> {\n  const thread = store.threads.find((t) => t.id === id);\n  if (!thread) return null;\n  thread.title = title;\n  thread.updatedAt = Date.now();\n  await saveStore();\n  return thread;\n}\n\n/**\n * Removes a thread by ID.\n * @param id - The thread ID to remove\n * @returns True if the thread was removed, false if not found\n */\nexport async function removeThread(id: string): Promise<boolean> {\n  const index = store.threads.findIndex((t) => t.id === id);\n  if (index === -1) return false;\n  store.threads.splice(index, 1);\n  await saveStore();\n  return true;\n}\n","/**\n * @fileoverview IPC handler registration for main process communication.\n * Registers all IPC channels for workspace, git, and diff operations,\n * and broadcasts events to all renderer windows.\n * @module main/ipc\n */\n\nimport { BrowserWindow, ipcMain } from 'electron';\nimport {\n  addWorkspace,\n  getCurrentWorkspace,\n  listRecentWorkspaces,\n  listWorkspaces,\n  discoverGitWorkspaces,\n  pickWorkspace,\n  removeWorkspace,\n  ignoreWorkspacePath,\n  listIgnoredWorkspaces,\n  renameWorkspace,\n  restoreIgnoredWorkspace,\n  setCurrentWorkspace\n} from '../workspace';\nimport { getGitSummary, getGitStatus, getGitFileStatuses } from '../git';\nimport { getDiff, getDiffForFile } from '../diff';\nimport { emitAppEvent, onAppEvent, type AppEvent } from '../events';\nimport { startWatchers, stopWatchers } from '../watchers';\nimport { listThreads, createThread, renameThread, removeThread } from '../thread';\n\n/** Flag to track if event listeners have been bound */\nlet eventsBound = false;\n\n/**\n * Broadcasts an event to all open browser windows.\n * @param {AppEvent} event - The event name to broadcast\n */\nfunction broadcast(event: AppEvent) {\n  for (const window of BrowserWindow.getAllWindows()) {\n    window.webContents.send(event);\n  }\n}\n\n/**\n * Refreshes file system watchers based on the current workspace.\n * Stops existing watchers if no workspace is selected, or starts\n * new watchers for the current workspace path.\n * @returns {Promise<void>}\n */\nasync function refreshWatchers() {\n  const current = await getCurrentWorkspace();\n  if (!current) {\n    await stopWatchers();\n    return;\n  }\n  await startWatchers(current.path);\n}\n\n/**\n * Registers all IPC handlers for the main process.\n * Sets up handlers for workspace, git, and diff operations.\n * Also binds event listeners to broadcast changes to renderer windows.\n */\nexport function registerIpc() {\n  if (!eventsBound) {\n    eventsBound = true;\n    onAppEvent('workspace:changed', () => broadcast('workspace:changed'));\n    onAppEvent('git:changed', () => broadcast('git:changed'));\n    onAppEvent('diff:changed', () => broadcast('diff:changed'));\n  }\n\n  ipcMain.handle('ping', async () => {\n    return 'pong from main';\n  });\n\n  ipcMain.handle('workspace:list', async () => {\n    return listWorkspaces();\n  });\n\n  ipcMain.handle('workspace:recent', async (_event, limit?: number) => {\n    return listRecentWorkspaces(limit ?? 5);\n  });\n\n  ipcMain.handle(\n    'workspace:discover',\n    async (\n      _event,\n      options?: { roots?: string[]; maxDepth?: number; limit?: number; includeIgnored?: boolean }\n    ) => {\n    return discoverGitWorkspaces(options);\n    }\n  );\n\n  ipcMain.handle('workspace:ignored:list', async () => {\n    return listIgnoredWorkspaces();\n  });\n\n  ipcMain.handle('workspace:ignored:add', async (_event, dirPath: string) => {\n    return ignoreWorkspacePath(dirPath);\n  });\n\n  ipcMain.handle('workspace:ignored:remove', async (_event, dirPath: string) => {\n    return restoreIgnoredWorkspace(dirPath);\n  });\n\n  ipcMain.handle('workspace:current', async () => {\n    return getCurrentWorkspace();\n  });\n\n  ipcMain.handle('workspace:add', async (_event, dirPath: string) => {\n    const entry = await addWorkspace(dirPath);\n    await refreshWatchers();\n    emitAppEvent('workspace:changed');\n    emitAppEvent('git:changed');\n    emitAppEvent('diff:changed');\n    return entry;\n  });\n\n  ipcMain.handle('workspace:pick', async () => {\n    const entry = await pickWorkspace();\n    await refreshWatchers();\n    emitAppEvent('workspace:changed');\n    emitAppEvent('git:changed');\n    emitAppEvent('diff:changed');\n    return entry;\n  });\n\n  ipcMain.handle('workspace:set', async (_event, id: string) => {\n    const entry = await setCurrentWorkspace(id);\n    await refreshWatchers();\n    emitAppEvent('workspace:changed');\n    emitAppEvent('git:changed');\n    emitAppEvent('diff:changed');\n    return entry;\n  });\n\n  ipcMain.handle('workspace:rename', async (_event, id: string, name: string) => {\n    const entry = await renameWorkspace(id, name);\n    emitAppEvent('workspace:changed');\n    return entry;\n  });\n\n  ipcMain.handle('workspace:remove', async (_event, id: string) => {\n    const result = await removeWorkspace(id);\n    await refreshWatchers();\n    emitAppEvent('workspace:changed');\n    emitAppEvent('git:changed');\n    emitAppEvent('diff:changed');\n    return result;\n  });\n\n  ipcMain.handle('git:summary', async () => {\n    return getGitSummary();\n  });\n\n  ipcMain.handle('git:status', async () => {\n    return getGitStatus();\n  });\n\n  ipcMain.handle('git:files', async () => {\n    return getGitFileStatuses();\n  });\n\n  ipcMain.handle('diff:current', async () => {\n    return getDiff();\n  });\n\n  ipcMain.handle('diff:file', async (_event, filePath: string) => {\n    return getDiffForFile(filePath);\n  });\n\n  ipcMain.handle('thread:list', async (_event, workspaceId: string) => {\n    return listThreads(workspaceId);\n  });\n\n  ipcMain.handle('thread:create', async (_event, workspaceId: string, title: string) => {\n    return createThread(workspaceId, title);\n  });\n\n  ipcMain.handle('thread:rename', async (_event, id: string, title: string) => {\n    return renameThread(id, title);\n  });\n\n  ipcMain.handle('thread:remove', async (_event, id: string) => {\n    return removeThread(id);\n  });\n\n  refreshWatchers().catch(() => {});\n}\n","/**\n * @fileoverview Main process entry point for the Electron desktop application.\n * Handles app lifecycle, window creation, and module initialization.\n * @module main\n */\n\nimport { app, BrowserWindow } from 'electron';\nimport fs from 'node:fs';\nimport path from 'node:path';\nimport { registerIpc } from './ipc';\nimport { initWorkspace } from './workspace';\nimport { initGit } from './git';\nimport { initDiff } from './diff';\nimport { initScripts } from './scripts';\nimport { initTesting } from './testing';\nimport { initSpotlight } from './spotlight';\nimport { initTodos } from './todos';\nimport { initCheckpoints } from './checkpoints';\nimport { initIntegrations } from './integrations';\nimport { initProviders } from './providers';\nimport { initStorage } from './storage';\nimport { initThread } from './thread';\n\n/** Development server URL from environment variables */\nconst devServerUrl = process.env.VITE_DEV_SERVER_URL ?? process.env.ELECTRON_RENDERER_URL;\n/** Fallback URL when dev server URL is not configured */\nconst fallbackDevServerUrl = 'http://127.0.0.1:5173';\n/** Whether the app is running in development mode */\nconst isDev = Boolean(devServerUrl);\n/** Reference to the main application window */\nlet mainWindow: BrowserWindow | null = null;\n\n/**\n * Creates and configures the main application window.\n * Sets up preload script, window dimensions, and loads the appropriate content\n * based on development or production mode.\n */\nfunction createWindow() {\n  const preloadMjs = path.join(__dirname, '../preload/index.mjs');\n  const preloadJs = path.join(__dirname, '../preload/index.js');\n  const preloadPath = fs.existsSync(preloadMjs) ? preloadMjs : preloadJs;\n\n  mainWindow = new BrowserWindow({\n    width: 1200,\n    height: 800,\n    webPreferences: {\n      preload: preloadPath,\n      contextIsolation: true,\n      nodeIntegration: false\n    }\n  });\n\n  if (isDev) {\n    const url = devServerUrl ?? fallbackDevServerUrl;\n    mainWindow.loadURL(url);\n    mainWindow.webContents.openDevTools({ mode: 'detach' });\n  } else {\n    const indexHtml = path.join(__dirname, '../renderer/index.html');\n    mainWindow.loadFile(indexHtml);\n  }\n\n  mainWindow.on('closed', () => {\n    mainWindow = null;\n  });\n}\n\n/**\n * Initializes all application modules.\n * Loads workspace, git, diff, scripts, testing, spotlight, todos,\n * checkpoints, integrations, providers, storage modules, and registers IPC handlers.\n * @returns {Promise<void>}\n */\nasync function initModules() {\n  initWorkspace();\n  initGit();\n  initDiff();\n  initScripts();\n  initTesting();\n  initSpotlight();\n  initTodos();\n  initCheckpoints();\n  initIntegrations();\n  initProviders();\n  initStorage();\n  await initThread();\n  registerIpc();\n}\n\napp.whenReady().then(async () => {\n  await initModules();\n  createWindow();\n\n  app.on('activate', () => {\n    if (BrowserWindow.getAllWindows().length === 0) {\n      createWindow();\n    }\n  });\n});\n\napp.on('window-all-closed', () => {\n  if (process.platform !== 'darwin') {\n    app.quit();\n  }\n});\n"],"names":["getStorePath","path","execFileAsync","require$$0","constants","require$$1","exports","state","utils","isGlob","isExtglob","opts","value","rest","source","parse_1","require$$2","require$$3","require$$4","picomatch","fs","promisify","normalizePath","anymatch","testString","returnIndex","anymatchModule","globParent","node","stringify","isNumber","max","index","binaryExtensions","isBinaryPath","rawEmitter","listener","newStats","stats","ready","require","fsevents","fseventsHandlerModule","EventEmitter","require$$5","require$$6","require$$7","require$$8","require$$9","require$$10","require$$11","require$$12","now","stat","chokidar"],"mappings":"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","x_google_ignoreList":[4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33]}