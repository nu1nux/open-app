{"version":3,"file":"index.js","sources":["../../src/main/workspace/index.ts","../../src/main/git/index.ts","../../src/main/diff/index.ts","../../src/main/events/index.ts","../../src/main/watchers/index.ts","../../src/main/thread/index.ts","../../src/main/ipc/index.ts","../../src/main/index.ts"],"sourcesContent":["/**\n * @fileoverview Workspace management module for handling user workspaces.\n * Provides functionality for creating, listing, removing, and discovering workspaces.\n * Stores workspace state in a JSON file in the user data directory.\n * @module main/workspace\n */\n\nimport { app, BrowserWindow, dialog, type OpenDialogOptions } from 'electron';\nimport type { Dirent } from 'node:fs';\nimport fs from 'node:fs/promises';\nimport path from 'node:path';\nimport { randomUUID } from 'node:crypto';\n\n/**\n * Represents a workspace entry stored in the application.\n */\nexport type WorkspaceEntry = {\n  id: string;\n  name: string;\n  path: string;\n  lastOpenedAt: string;\n};\n\n/**\n * Represents a workspace discovered during filesystem scanning.\n */\nexport type DiscoveredWorkspace = {\n  name: string;\n  path: string;\n  lastModifiedAt: string;\n};\n\n/**\n * Internal state structure for workspace management.\n */\ntype WorkspaceState = {\n  currentId: string | null;\n  entries: WorkspaceEntry[];\n  ignoredPaths: string[];\n};\n\n/** Current workspace state held in memory */\nconst state: WorkspaceState = {\n  currentId: null,\n  entries: [],\n  ignoredPaths: []\n};\n\n/** Promise that resolves when state is loaded */\nlet ready: Promise<void> = Promise.resolve();\n\n/**\n * Gets the file path for storing workspace state.\n * @returns {string} Path to workspaces.json in user data directory\n */\nfunction getStorePath() {\n  return path.join(app.getPath('userData'), 'workspaces.json');\n}\n\n/**\n * Loads workspace state from the persistent storage file.\n * Initializes empty state if the file doesn't exist or is invalid.\n * @returns {Promise<void>}\n */\nasync function loadState() {\n  try {\n    const data = await fs.readFile(getStorePath(), 'utf-8');\n    const parsed = JSON.parse(data) as WorkspaceState;\n    state.currentId = parsed.currentId ?? null;\n    state.entries = Array.isArray(parsed.entries) ? parsed.entries : [];\n    state.ignoredPaths = Array.isArray(parsed.ignoredPaths) ? parsed.ignoredPaths : [];\n  } catch {\n    state.currentId = null;\n    state.entries = [];\n    state.ignoredPaths = [];\n  }\n}\n\n/**\n * Saves the current workspace state to the persistent storage file.\n * @returns {Promise<void>}\n */\nasync function saveState() {\n  const payload: WorkspaceState = {\n    currentId: state.currentId,\n    entries: state.entries,\n    ignoredPaths: state.ignoredPaths\n  };\n  await fs.writeFile(getStorePath(), JSON.stringify(payload, null, 2), 'utf-8');\n}\n\n/**\n * Finds a workspace entry by its directory path.\n * @param {string} dirPath - The directory path to search for\n * @returns {WorkspaceEntry | null} The matching workspace entry or null\n */\nfunction findEntryByPath(dirPath: string) {\n  return state.entries.find((entry) => entry.path === dirPath) ?? null;\n}\n\n/**\n * Gets a workspace entry by its unique identifier.\n * @param {string | null} id - The workspace ID to search for\n * @returns {WorkspaceEntry | null} The matching workspace entry or null\n */\nfunction getEntryById(id: string | null) {\n  if (!id) return null;\n  return state.entries.find((entry) => entry.id === id) ?? null;\n}\n\n/**\n * Ensures the workspace state has been loaded before operations.\n * @returns {Promise<void>}\n */\nasync function ensureReady() {\n  await ready;\n}\n\n/**\n * Initializes the workspace module by loading saved state.\n */\nexport function initWorkspace() {\n  ready = loadState();\n}\n\n/**\n * Lists all workspaces sorted by last opened date (most recent first).\n * @returns {Promise<WorkspaceEntry[]>} Array of workspace entries\n */\nexport async function listWorkspaces() {\n  await ensureReady();\n  return [...state.entries].sort((a, b) => b.lastOpenedAt.localeCompare(a.lastOpenedAt));\n}\n\n/**\n * Lists the most recently opened workspaces.\n * @param {number} [limit=5] - Maximum number of workspaces to return\n * @returns {Promise<WorkspaceEntry[]>} Array of recent workspace entries\n */\nexport async function listRecentWorkspaces(limit = 5) {\n  const list = await listWorkspaces();\n  return list.slice(0, limit);\n}\n\n/**\n * Gets the currently active workspace.\n * @returns {Promise<WorkspaceEntry | null>} The current workspace entry or null\n */\nexport async function getCurrentWorkspace() {\n  await ensureReady();\n  return getEntryById(state.currentId);\n}\n\n/**\n * Sets the current workspace by ID and updates its last opened timestamp.\n * @param {string} id - The workspace ID to set as current\n * @returns {Promise<WorkspaceEntry | null>} The updated workspace entry or null if not found\n */\nexport async function setCurrentWorkspace(id: string) {\n  await ensureReady();\n  const entry = getEntryById(id);\n  if (!entry) return null;\n  state.currentId = entry.id;\n  entry.lastOpenedAt = new Date().toISOString();\n  await saveState();\n  return entry;\n}\n\n/**\n * Adds a new workspace or updates an existing one if the path already exists.\n * Removes the path from ignored list if present.\n * @param {string} dirPath - The directory path to add as a workspace\n * @returns {Promise<WorkspaceEntry>} The created or updated workspace entry\n */\nexport async function addWorkspace(dirPath: string) {\n  await ensureReady();\n  if (state.ignoredPaths.includes(dirPath)) {\n    state.ignoredPaths = state.ignoredPaths.filter((path) => path !== dirPath);\n  }\n  const existing = findEntryByPath(dirPath);\n  if (existing) {\n    existing.lastOpenedAt = new Date().toISOString();\n    state.currentId = existing.id;\n    await saveState();\n    return existing;\n  }\n\n  const entry: WorkspaceEntry = {\n    id: randomUUID(),\n    name: path.basename(dirPath),\n    path: dirPath,\n    lastOpenedAt: new Date().toISOString()\n  };\n\n  state.entries.push(entry);\n  state.currentId = entry.id;\n  await saveState();\n  return entry;\n}\n\n/**\n * Renames a workspace.\n * @param {string} id - The workspace ID to rename\n * @param {string} name - The new name for the workspace\n * @returns {Promise<WorkspaceEntry | null>} The updated workspace entry or null if not found\n */\nexport async function renameWorkspace(id: string, name: string) {\n  await ensureReady();\n  const entry = getEntryById(id);\n  if (!entry) return null;\n\n  const nextName = name.trim();\n  if (!nextName) return null;\n\n  entry.name = nextName;\n  await saveState();\n  return entry;\n}\n\n/**\n * Removes a workspace by ID.\n * If the removed workspace was current, sets the first available workspace as current.\n * @param {string} id - The workspace ID to remove\n * @returns {Promise<{removed: boolean, current: WorkspaceEntry | null}>} Result with removal status and new current workspace\n */\nexport async function removeWorkspace(id: string) {\n  await ensureReady();\n  const index = state.entries.findIndex((entry) => entry.id === id);\n  if (index === -1) return { removed: false, current: getEntryById(state.currentId) };\n\n  const [removed] = state.entries.splice(index, 1);\n  if (state.currentId === removed.id) {\n    state.currentId = state.entries[0]?.id ?? null;\n  }\n  await saveState();\n  return { removed: true, current: getEntryById(state.currentId) };\n}\n\n/**\n * Lists all ignored workspace paths.\n * @returns {Promise<string[]>} Array of ignored directory paths\n */\nexport async function listIgnoredWorkspaces() {\n  await ensureReady();\n  return [...state.ignoredPaths];\n}\n\n/**\n * Adds a path to the ignored workspaces list.\n * @param {string} pathToIgnore - The directory path to ignore\n * @returns {Promise<string[]>} Updated array of ignored paths\n */\nexport async function ignoreWorkspacePath(pathToIgnore: string) {\n  await ensureReady();\n  if (!state.ignoredPaths.includes(pathToIgnore)) {\n    state.ignoredPaths.push(pathToIgnore);\n    await saveState();\n  }\n  return [...state.ignoredPaths];\n}\n\n/**\n * Removes a path from the ignored workspaces list.\n * @param {string} pathToRestore - The directory path to restore\n * @returns {Promise<string[]>} Updated array of ignored paths\n */\nexport async function restoreIgnoredWorkspace(pathToRestore: string) {\n  await ensureReady();\n  state.ignoredPaths = state.ignoredPaths.filter((value) => value !== pathToRestore);\n  await saveState();\n  return [...state.ignoredPaths];\n}\n\n/** Default directories to search for git repositories */\nconst DEFAULT_DISCOVERY_DIRS = ['Desktop', 'Documents', 'Projects', 'Code', 'workspace', 'dev'];\n/** Directories to ignore during workspace discovery */\nconst IGNORE_DIRS = new Set(['node_modules', '.git', 'dist', 'build', '.next', 'out', 'coverage']);\n\n/**\n * Discovers git repositories in the filesystem.\n * Searches through specified root directories or default locations.\n * @param {Object} [options] - Discovery options\n * @param {string[]} [options.roots] - Root directories to search in\n * @param {number} [options.maxDepth=4] - Maximum directory depth to traverse\n * @param {number} [options.limit=50] - Maximum number of repositories to return\n * @param {boolean} [options.includeIgnored=false] - Whether to include ignored paths\n * @returns {Promise<DiscoveredWorkspace[]>} Array of discovered workspaces\n */\nexport async function discoverGitWorkspaces(options?: {\n  roots?: string[];\n  maxDepth?: number;\n  limit?: number;\n  includeIgnored?: boolean;\n}): Promise<DiscoveredWorkspace[]> {\n  const home = app.getPath('home');\n  const roots = options?.roots ??\n    (await Promise.all(\n      DEFAULT_DISCOVERY_DIRS.map(async (dir) => {\n        const full = path.join(home, dir);\n        try {\n          const stat = await fs.stat(full);\n          return stat.isDirectory() ? full : null;\n        } catch {\n          return null;\n        }\n      })\n    )).filter((value): value is string => Boolean(value));\n\n  const maxDepth = options?.maxDepth ?? 4;\n  const limit = options?.limit ?? 50;\n  const discovered: DiscoveredWorkspace[] = [];\n  const visited = new Set<string>();\n\n  const isGitRepo = async (dirPath: string) => {\n    try {\n      const stat = await fs.stat(path.join(dirPath, '.git'));\n      return stat.isDirectory();\n    } catch {\n      return false;\n    }\n  };\n\n  const walk = async (dirPath: string, depth: number) => {\n    if (depth < 0 || discovered.length >= limit) return;\n\n    let realPath = dirPath;\n    try {\n      realPath = await fs.realpath(dirPath);\n    } catch {\n      return;\n    }\n\n    if (visited.has(realPath)) return;\n    visited.add(realPath);\n\n    if (await isGitRepo(dirPath)) {\n      try {\n        const stat = await fs.stat(dirPath);\n        discovered.push({\n          name: path.basename(dirPath),\n          path: dirPath,\n          lastModifiedAt: stat.mtime.toISOString()\n        });\n      } catch {\n        discovered.push({\n          name: path.basename(dirPath),\n          path: dirPath,\n          lastModifiedAt: new Date().toISOString()\n        });\n      }\n      return;\n    }\n\n    let entries: Dirent[] = [];\n    try {\n      entries = await fs.readdir(dirPath, { withFileTypes: true });\n    } catch {\n      return;\n    }\n\n    await Promise.all(\n      entries.map(async (entry) => {\n        if (!entry.isDirectory() || entry.isSymbolicLink()) return;\n        if (IGNORE_DIRS.has(entry.name)) return;\n        if (entry.name.startsWith('.')) return;\n        await walk(path.join(dirPath, entry.name), depth - 1);\n      })\n    );\n  };\n\n  await Promise.all(roots.map((root) => walk(root, maxDepth)));\n\n  const filtered = options?.includeIgnored\n    ? discovered\n    : discovered.filter((entry) => !state.ignoredPaths.includes(entry.path));\n\n  return filtered\n    .sort((a, b) => b.lastModifiedAt.localeCompare(a.lastModifiedAt))\n    .slice(0, limit);\n}\n\n/**\n * Opens a native directory picker dialog to select a workspace.\n * @returns {Promise<WorkspaceEntry | null>} The selected workspace entry or null if canceled\n */\nexport async function pickWorkspace() {\n  await ensureReady();\n  const window = BrowserWindow.getFocusedWindow();\n  const options: OpenDialogOptions = {\n    properties: ['openDirectory'],\n    title: 'Select a workspace folder'\n  };\n\n  const result = window\n    ? await dialog.showOpenDialog(window, options)\n    : await dialog.showOpenDialog(options);\n\n  if (result.canceled || result.filePaths.length === 0) {\n    return null;\n  }\n\n  return addWorkspace(result.filePaths[0]);\n}\n\n/**\n * Gets the directory path of the current workspace.\n * @returns {Promise<string | null>} The current workspace path or null\n */\nexport async function getCurrentWorkspacePath() {\n  const entry = await getCurrentWorkspace();\n  return entry?.path ?? null;\n}\n","/**\n * @fileoverview Git integration module for the main process.\n * Provides functions to interact with git repositories including\n * getting status, summaries, and file change information.\n * @module main/git\n */\n\nimport { execFile } from 'node:child_process';\nimport { promisify } from 'node:util';\nimport { getCurrentWorkspacePath } from '../workspace';\n\n/** Promisified version of execFile for async git commands */\nconst execFileAsync = promisify(execFile);\n\n/**\n * Summary information about a git repository.\n */\nexport type GitSummary = {\n  available: boolean;\n  reason?: string;\n  root?: string;\n  branch?: string;\n  status?: string;\n  lastCommit?: string;\n};\n\n/**\n * Status information for a single file in the git repository.\n */\nexport type GitFileStatus = {\n  path: string;\n  staged: boolean;\n  unstaged: boolean;\n  status: string;\n};\n\n/**\n * Executes a git command in the specified directory.\n * @param {string[]} args - Arguments to pass to the git command\n * @param {string} cwd - Working directory for the git command\n * @returns {Promise<{ok: boolean, stdout: string, error?: string}>} Result of the git command\n */\nasync function runGit(args: string[], cwd: string) {\n  try {\n    const { stdout } = await execFileAsync('git', args, { cwd });\n    return { ok: true, stdout: stdout.trim() };\n  } catch (error: any) {\n    return {\n      ok: false,\n      stdout: '',\n      error: error?.stderr?.toString?.() ?? error?.message ?? 'git command failed'\n    };\n  }\n}\n\n/**\n * Initializes the git module.\n * Placeholder for future git module bootstrapping.\n */\nexport function initGit() {\n  // Placeholder for future git module bootstrapping.\n}\n\n/**\n * Gets a summary of the current git repository state.\n * Includes branch name, status, root path, and last commit information.\n * @returns {Promise<GitSummary>} Git repository summary\n */\nexport async function getGitSummary(): Promise<GitSummary> {\n  const cwd = await getCurrentWorkspacePath();\n  if (!cwd) {\n    return { available: false, reason: 'No workspace selected' };\n  }\n\n  const repoCheck = await runGit(['rev-parse', '--is-inside-work-tree'], cwd);\n  if (!repoCheck.ok || repoCheck.stdout !== 'true') {\n    return { available: false, reason: 'Not a git repository' };\n  }\n\n  const root = await runGit(['rev-parse', '--show-toplevel'], cwd);\n  const branch = await runGit(['rev-parse', '--abbrev-ref', 'HEAD'], cwd);\n  const status = await runGit(['status', '-sb'], cwd);\n  const lastCommit = await runGit(\n    ['log', '-1', '--pretty=format:%h %s (%an, %ad)', '--date=short'],\n    cwd\n  );\n\n  return {\n    available: true,\n    root: root.ok ? root.stdout : undefined,\n    branch: branch.ok ? branch.stdout : undefined,\n    status: status.ok ? status.stdout : undefined,\n    lastCommit: lastCommit.ok ? lastCommit.stdout : undefined\n  };\n}\n\n/**\n * Gets the git status for the current workspace.\n * @returns {Promise<GitSummary>} Git status information\n */\nexport async function getGitStatus() {\n  const summary = await getGitSummary();\n  if (!summary.available) {\n    return summary;\n  }\n\n  return { ...summary, status: summary.status ?? '' };\n}\n\n/**\n * Gets the status of all changed files in the current workspace.\n * Parses git porcelain output to determine staged/unstaged state.\n * @returns {Promise<{available: boolean, reason?: string, files: GitFileStatus[]}>} File status information\n */\nexport async function getGitFileStatuses() {\n  const cwd = await getCurrentWorkspacePath();\n  if (!cwd) {\n    return { available: false, reason: 'No workspace selected', files: [] as GitFileStatus[] };\n  }\n\n  const repoCheck = await runGit(['rev-parse', '--is-inside-work-tree'], cwd);\n  if (!repoCheck.ok || repoCheck.stdout !== 'true') {\n    return { available: false, reason: 'Not a git repository', files: [] as GitFileStatus[] };\n  }\n\n  const status = await runGit(['status', '--porcelain=v1'], cwd);\n  if (!status.ok) {\n    return { available: false, reason: status.error ?? 'git status failed', files: [] as GitFileStatus[] };\n  }\n\n  const files = status.stdout\n    .split('\\n')\n    .map((line) => line.trimEnd())\n    .filter(Boolean)\n    .map((line) => {\n      const statusCode = line.slice(0, 2);\n      const rawPath = line.slice(3).trim();\n      const pathPart = rawPath.includes(' -> ')\n        ? rawPath.split(' -> ').slice(-1)[0]\n        : rawPath;\n\n      return {\n        path: pathPart,\n        status: statusCode,\n        staged: statusCode[0] !== ' ',\n        unstaged: statusCode[1] !== ' '\n      };\n    });\n\n  return { available: true, files };\n}\n","/**\n * @fileoverview Git diff module for the main process.\n * Provides functions to retrieve staged and unstaged diffs\n * for the current workspace.\n * @module main/diff\n */\n\nimport { execFile } from 'node:child_process';\nimport { promisify } from 'node:util';\nimport { getCurrentWorkspacePath } from '../workspace';\n\n/** Promisified version of execFile for async git commands */\nconst execFileAsync = promisify(execFile);\n/** Maximum characters to include in diff output before truncation */\nconst MAX_CHARS = 20000;\n\n/**\n * Result of a diff operation.\n */\nexport type DiffResult = {\n  available: boolean;\n  reason?: string;\n  unstaged?: string;\n  staged?: string;\n};\n\n/**\n * Truncates text to the maximum allowed characters.\n * @param {string} text - The text to truncate\n * @returns {string} The truncated text with a message if truncated\n */\nfunction truncate(text: string) {\n  if (text.length <= MAX_CHARS) return text;\n  return `${text.slice(0, MAX_CHARS)}\\n...diff truncated (${text.length - MAX_CHARS} more chars)`;\n}\n\n/**\n * Runs a git diff command with the specified arguments.\n * @param {string[]} args - Arguments to pass to git diff\n * @param {string} cwd - Working directory for the command\n * @returns {Promise<string>} The diff output or error message\n */\nasync function runGitDiff(args: string[], cwd: string) {\n  try {\n    const { stdout } = await execFileAsync('git', args, { cwd });\n    const content = stdout.trim();\n    return content.length === 0 ? '(no changes)' : truncate(content);\n  } catch (error: any) {\n    return `git diff failed: ${error?.stderr?.toString?.() ?? error?.message ?? 'unknown error'}`;\n  }\n}\n\n/**\n * Initializes the diff module.\n * Placeholder for future diff module bootstrapping.\n */\nexport function initDiff() {\n  // Placeholder for future diff module bootstrapping.\n}\n\n/**\n * Checks if the given directory is inside a git repository.\n * @param {string} cwd - Directory path to check\n * @returns {Promise<boolean>} True if inside a git repository\n */\nasync function ensureRepo(cwd: string) {\n  try {\n    await execFileAsync('git', ['rev-parse', '--is-inside-work-tree'], { cwd });\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Gets the diff for all files in the current workspace.\n * Returns both staged and unstaged changes.\n * @returns {Promise<DiffResult>} The diff result with staged and unstaged changes\n */\nexport async function getDiff(): Promise<DiffResult> {\n  const cwd = await getCurrentWorkspacePath();\n  if (!cwd) {\n    return { available: false, reason: 'No workspace selected' };\n  }\n\n  const isRepo = await ensureRepo(cwd);\n  if (!isRepo) {\n    return { available: false, reason: 'Not a git repository' };\n  }\n\n  const unstaged = await runGitDiff(['diff'], cwd);\n  const staged = await runGitDiff(['diff', '--staged'], cwd);\n\n  return {\n    available: true,\n    unstaged,\n    staged\n  };\n}\n\n/**\n * Gets the diff for a specific file in the current workspace.\n * Returns both staged and unstaged changes for the file.\n * @param {string} filePath - Path to the file relative to the repository root\n * @returns {Promise<DiffResult>} The diff result for the specified file\n */\nexport async function getDiffForFile(filePath: string): Promise<DiffResult> {\n  const cwd = await getCurrentWorkspacePath();\n  if (!cwd) {\n    return { available: false, reason: 'No workspace selected' };\n  }\n\n  const isRepo = await ensureRepo(cwd);\n  if (!isRepo) {\n    return { available: false, reason: 'Not a git repository' };\n  }\n\n  const unstaged = await runGitDiff(['diff', '--', filePath], cwd);\n  const staged = await runGitDiff(['diff', '--staged', '--', filePath], cwd);\n\n  return {\n    available: true,\n    unstaged,\n    staged\n  };\n}\n","/**\n * @fileoverview Application event bus for internal event communication.\n * Provides a centralized event emitter for broadcasting app state changes.\n * @module main/events\n */\n\nimport { EventEmitter } from 'node:events';\n\n/**\n * Application event types that can be emitted and listened to.\n */\nexport type AppEvent = 'workspace:changed' | 'git:changed' | 'diff:changed';\n\n/**\n * Event listener callback function type.\n */\ntype Listener = () => void;\n\n/** Internal event emitter instance */\nconst emitter = new EventEmitter();\n\n/**\n * Registers a listener for an application event.\n * @param {AppEvent} event - The event type to listen for\n * @param {Listener} listener - Callback function to invoke when event fires\n * @returns {() => void} Unsubscribe function to remove the listener\n */\nexport function onAppEvent(event: AppEvent, listener: Listener) {\n  emitter.on(event, listener);\n  return () => emitter.off(event, listener);\n}\n\n/**\n * Emits an application event to all registered listeners.\n * @param {AppEvent} event - The event type to emit\n */\nexport function emitAppEvent(event: AppEvent) {\n  emitter.emit(event);\n}\n","/**\n * @fileoverview File system watchers for detecting workspace and git changes.\n * Uses chokidar to watch for file changes and emits debounced events.\n * @module main/watchers\n */\n\nimport chokidar, { type FSWatcher } from 'chokidar';\nimport path from 'node:path';\nimport { emitAppEvent } from '../events';\n\n/** File watcher for workspace files */\nlet fileWatcher: FSWatcher | null = null;\n/** Watcher for .git directory changes */\nlet gitWatcher: FSWatcher | null = null;\n/** Timer for debouncing event emissions */\nlet debounceTimer: NodeJS.Timeout | null = null;\n/** Pending events to emit after debounce */\nlet pending = {\n  workspace: false,\n  git: false,\n  diff: false\n};\n\n/**\n * Schedules events to be emitted after a debounce period.\n * Consolidates multiple rapid file changes into a single event emission.\n * @param {Partial<typeof pending>} events - Events to schedule for emission\n */\nfunction schedule(events: Partial<typeof pending>) {\n  pending = {\n    workspace: pending.workspace || Boolean(events.workspace),\n    git: pending.git || Boolean(events.git),\n    diff: pending.diff || Boolean(events.diff)\n  };\n\n  if (debounceTimer) clearTimeout(debounceTimer);\n  debounceTimer = setTimeout(() => {\n    if (pending.workspace) emitAppEvent('workspace:changed');\n    if (pending.git) emitAppEvent('git:changed');\n    if (pending.diff) emitAppEvent('diff:changed');\n\n    pending = { workspace: false, git: false, diff: false };\n    debounceTimer = null;\n  }, 250);\n}\n\n/**\n * Stops all active file system watchers.\n * @returns {Promise<void>}\n */\nexport async function stopWatchers() {\n  if (fileWatcher) {\n    await fileWatcher.close();\n    fileWatcher = null;\n  }\n  if (gitWatcher) {\n    await gitWatcher.close();\n    gitWatcher = null;\n  }\n}\n\n/**\n * Starts file system watchers for a workspace directory.\n * Watches for general file changes and git-specific changes separately.\n * @param {string} rootPath - Root directory path to watch\n * @returns {Promise<void>}\n */\nexport async function startWatchers(rootPath: string) {\n  await stopWatchers();\n\n  fileWatcher = chokidar.watch(rootPath, {\n    ignored: [\n      '**/node_modules/**',\n      '**/.git/**',\n      '**/dist/**',\n      '**/.next/**'\n    ],\n    ignoreInitial: true\n  });\n\n  fileWatcher.on('all', () => {\n    schedule({ workspace: true, git: true, diff: true });\n  });\n\n  gitWatcher = chokidar.watch(path.join(rootPath, '.git'), {\n    ignoreInitial: true,\n    depth: 5\n  });\n\n  gitWatcher.on('all', () => {\n    schedule({ git: true, diff: true });\n  });\n}\n","/**\n * @fileoverview Thread management module for the main process.\n * Provides functionality for creating, listing, renaming, and removing threads.\n * Stores thread state in a JSON file in the user data directory.\n * @module main/thread\n */\n\nimport { app } from 'electron';\nimport fs from 'node:fs/promises';\nimport path from 'node:path';\nimport { randomUUID } from 'node:crypto';\nimport type { Thread } from '../../shared/thread';\n\n/**\n * Internal store structure for thread management.\n */\ntype ThreadStore = {\n  threads: Thread[];\n};\n\n/** Current thread store held in memory */\nlet store: ThreadStore = { threads: [] };\n\n/**\n * Gets the file path for storing thread state.\n * @returns Path to threads.json in user data directory\n */\nfunction getStorePath() {\n  return path.join(app.getPath('userData'), 'threads.json');\n}\n\n/**\n * Loads thread state from the persistent storage file.\n * Initializes empty state if the file doesn't exist or is invalid.\n */\nasync function loadStore() {\n  try {\n    const data = await fs.readFile(getStorePath(), 'utf-8');\n    store = JSON.parse(data) as ThreadStore;\n  } catch {\n    store = { threads: [] };\n  }\n}\n\n/**\n * Saves the current thread state to the persistent storage file.\n */\nasync function saveStore() {\n  await fs.writeFile(getStorePath(), JSON.stringify(store, null, 2), 'utf-8');\n}\n\n/**\n * Initializes the thread module by loading saved state.\n */\nexport async function initThread() {\n  await loadStore();\n}\n\n/**\n * Lists all threads for a specific workspace.\n * @param workspaceId - The workspace ID to filter threads by\n * @returns Array of threads sorted by updatedAt descending\n */\nexport async function listThreads(workspaceId: string): Promise<Thread[]> {\n  return store.threads\n    .filter((t) => t.workspaceId === workspaceId)\n    .sort((a, b) => b.updatedAt - a.updatedAt);\n}\n\n/**\n * Creates a new thread in the specified workspace.\n * @param workspaceId - The workspace ID to create the thread in\n * @param title - The title of the new thread\n * @returns The newly created thread\n */\nexport async function createThread(workspaceId: string, title: string): Promise<Thread> {\n  const now = Date.now();\n  const thread: Thread = {\n    id: randomUUID(),\n    workspaceId,\n    title,\n    createdAt: now,\n    updatedAt: now\n  };\n  store.threads.push(thread);\n  await saveStore();\n  return thread;\n}\n\n/**\n * Renames an existing thread.\n * @param id - The thread ID to rename\n * @param title - The new title for the thread\n * @returns The updated thread or null if not found\n */\nexport async function renameThread(id: string, title: string): Promise<Thread | null> {\n  const thread = store.threads.find((t) => t.id === id);\n  if (!thread) return null;\n  thread.title = title;\n  thread.updatedAt = Date.now();\n  await saveStore();\n  return thread;\n}\n\n/**\n * Removes a thread by ID.\n * @param id - The thread ID to remove\n * @returns True if the thread was removed, false if not found\n */\nexport async function removeThread(id: string): Promise<boolean> {\n  const index = store.threads.findIndex((t) => t.id === id);\n  if (index === -1) return false;\n  store.threads.splice(index, 1);\n  await saveStore();\n  return true;\n}\n","/**\n * @fileoverview IPC handler registration for main process communication.\n * Registers all IPC channels for workspace, git, and diff operations,\n * and broadcasts events to all renderer windows.\n * @module main/ipc\n */\n\nimport { BrowserWindow, ipcMain } from 'electron';\nimport {\n  addWorkspace,\n  getCurrentWorkspace,\n  listRecentWorkspaces,\n  listWorkspaces,\n  discoverGitWorkspaces,\n  pickWorkspace,\n  removeWorkspace,\n  ignoreWorkspacePath,\n  listIgnoredWorkspaces,\n  renameWorkspace,\n  restoreIgnoredWorkspace,\n  setCurrentWorkspace\n} from '../workspace';\nimport { getGitSummary, getGitStatus, getGitFileStatuses } from '../git';\nimport { getDiff, getDiffForFile } from '../diff';\nimport { emitAppEvent, onAppEvent, type AppEvent } from '../events';\nimport { startWatchers, stopWatchers } from '../watchers';\nimport { listThreads, createThread, renameThread, removeThread } from '../thread';\n\n/** Flag to track if event listeners have been bound */\nlet eventsBound = false;\n\n/**\n * Broadcasts an event to all open browser windows.\n * @param {AppEvent} event - The event name to broadcast\n */\nfunction broadcast(event: AppEvent) {\n  for (const window of BrowserWindow.getAllWindows()) {\n    window.webContents.send(event);\n  }\n}\n\n/**\n * Refreshes file system watchers based on the current workspace.\n * Stops existing watchers if no workspace is selected, or starts\n * new watchers for the current workspace path.\n * @returns {Promise<void>}\n */\nasync function refreshWatchers() {\n  const current = await getCurrentWorkspace();\n  if (!current) {\n    await stopWatchers();\n    return;\n  }\n  await startWatchers(current.path);\n}\n\n/**\n * Registers all IPC handlers for the main process.\n * Sets up handlers for workspace, git, and diff operations.\n * Also binds event listeners to broadcast changes to renderer windows.\n */\nexport function registerIpc() {\n  if (!eventsBound) {\n    eventsBound = true;\n    onAppEvent('workspace:changed', () => broadcast('workspace:changed'));\n    onAppEvent('git:changed', () => broadcast('git:changed'));\n    onAppEvent('diff:changed', () => broadcast('diff:changed'));\n  }\n\n  ipcMain.handle('ping', async () => {\n    return 'pong from main';\n  });\n\n  ipcMain.handle('workspace:list', async () => {\n    return listWorkspaces();\n  });\n\n  ipcMain.handle('workspace:recent', async (_event, limit?: number) => {\n    return listRecentWorkspaces(limit ?? 5);\n  });\n\n  ipcMain.handle(\n    'workspace:discover',\n    async (\n      _event,\n      options?: { roots?: string[]; maxDepth?: number; limit?: number; includeIgnored?: boolean }\n    ) => {\n    return discoverGitWorkspaces(options);\n    }\n  );\n\n  ipcMain.handle('workspace:ignored:list', async () => {\n    return listIgnoredWorkspaces();\n  });\n\n  ipcMain.handle('workspace:ignored:add', async (_event, dirPath: string) => {\n    return ignoreWorkspacePath(dirPath);\n  });\n\n  ipcMain.handle('workspace:ignored:remove', async (_event, dirPath: string) => {\n    return restoreIgnoredWorkspace(dirPath);\n  });\n\n  ipcMain.handle('workspace:current', async () => {\n    return getCurrentWorkspace();\n  });\n\n  ipcMain.handle('workspace:add', async (_event, dirPath: string) => {\n    const entry = await addWorkspace(dirPath);\n    await refreshWatchers();\n    emitAppEvent('workspace:changed');\n    emitAppEvent('git:changed');\n    emitAppEvent('diff:changed');\n    return entry;\n  });\n\n  ipcMain.handle('workspace:pick', async () => {\n    const entry = await pickWorkspace();\n    await refreshWatchers();\n    emitAppEvent('workspace:changed');\n    emitAppEvent('git:changed');\n    emitAppEvent('diff:changed');\n    return entry;\n  });\n\n  ipcMain.handle('workspace:set', async (_event, id: string) => {\n    const entry = await setCurrentWorkspace(id);\n    await refreshWatchers();\n    emitAppEvent('workspace:changed');\n    emitAppEvent('git:changed');\n    emitAppEvent('diff:changed');\n    return entry;\n  });\n\n  ipcMain.handle('workspace:rename', async (_event, id: string, name: string) => {\n    const entry = await renameWorkspace(id, name);\n    emitAppEvent('workspace:changed');\n    return entry;\n  });\n\n  ipcMain.handle('workspace:remove', async (_event, id: string) => {\n    const result = await removeWorkspace(id);\n    await refreshWatchers();\n    emitAppEvent('workspace:changed');\n    emitAppEvent('git:changed');\n    emitAppEvent('diff:changed');\n    return result;\n  });\n\n  ipcMain.handle('git:summary', async () => {\n    return getGitSummary();\n  });\n\n  ipcMain.handle('git:status', async () => {\n    return getGitStatus();\n  });\n\n  ipcMain.handle('git:files', async () => {\n    return getGitFileStatuses();\n  });\n\n  ipcMain.handle('diff:current', async () => {\n    return getDiff();\n  });\n\n  ipcMain.handle('diff:file', async (_event, filePath: string) => {\n    return getDiffForFile(filePath);\n  });\n\n  ipcMain.handle('thread:list', async (_event, workspaceId: string) => {\n    return listThreads(workspaceId);\n  });\n\n  ipcMain.handle('thread:create', async (_event, workspaceId: string, title: string) => {\n    return createThread(workspaceId, title);\n  });\n\n  ipcMain.handle('thread:rename', async (_event, id: string, title: string) => {\n    return renameThread(id, title);\n  });\n\n  ipcMain.handle('thread:remove', async (_event, id: string) => {\n    return removeThread(id);\n  });\n\n  refreshWatchers().catch(() => {});\n}\n","/**\n * @fileoverview Main process entry point for the Electron desktop application.\n * Handles app lifecycle, window creation, and module initialization.\n * @module main\n */\n\nimport { app, BrowserWindow } from 'electron';\nimport fs from 'node:fs';\nimport path from 'node:path';\nimport { registerIpc } from './ipc';\nimport { initWorkspace } from './workspace';\nimport { initGit } from './git';\nimport { initDiff } from './diff';\nimport { initScripts } from './scripts';\nimport { initTesting } from './testing';\nimport { initSpotlight } from './spotlight';\nimport { initTodos } from './todos';\nimport { initCheckpoints } from './checkpoints';\nimport { initIntegrations } from './integrations';\nimport { initProviders } from './providers';\nimport { initStorage } from './storage';\nimport { initThread } from './thread';\n\n/** Development server URL from environment variables */\nconst devServerUrl = process.env.VITE_DEV_SERVER_URL ?? process.env.ELECTRON_RENDERER_URL;\n/** Fallback URL when dev server URL is not configured */\nconst fallbackDevServerUrl = 'http://127.0.0.1:5173';\n/** Whether the app is running in development mode */\nconst isDev = Boolean(devServerUrl);\n/** Reference to the main application window */\nlet mainWindow: BrowserWindow | null = null;\n\n/**\n * Creates and configures the main application window.\n * Sets up preload script, window dimensions, and loads the appropriate content\n * based on development or production mode.\n */\nfunction createWindow() {\n  const preloadMjs = path.join(__dirname, '../preload/index.mjs');\n  const preloadJs = path.join(__dirname, '../preload/index.js');\n  const preloadPath = fs.existsSync(preloadMjs) ? preloadMjs : preloadJs;\n\n  mainWindow = new BrowserWindow({\n    width: 1200,\n    height: 800,\n    webPreferences: {\n      preload: preloadPath,\n      contextIsolation: true,\n      nodeIntegration: false\n    }\n  });\n\n  if (isDev) {\n    const url = devServerUrl ?? fallbackDevServerUrl;\n    mainWindow.loadURL(url);\n    mainWindow.webContents.openDevTools({ mode: 'detach' });\n  } else {\n    const indexHtml = path.join(__dirname, '../renderer/index.html');\n    mainWindow.loadFile(indexHtml);\n  }\n\n  mainWindow.on('closed', () => {\n    mainWindow = null;\n  });\n}\n\n/**\n * Initializes all application modules.\n * Loads workspace, git, diff, scripts, testing, spotlight, todos,\n * checkpoints, integrations, providers, storage modules, and registers IPC handlers.\n * @returns {Promise<void>}\n */\nasync function initModules() {\n  initWorkspace();\n  initGit();\n  initDiff();\n  initScripts();\n  initTesting();\n  initSpotlight();\n  initTodos();\n  initCheckpoints();\n  initIntegrations();\n  initProviders();\n  initStorage();\n  await initThread();\n  registerIpc();\n}\n\napp.whenReady().then(async () => {\n  await initModules();\n  createWindow();\n\n  app.on('activate', () => {\n    if (BrowserWindow.getAllWindows().length === 0) {\n      createWindow();\n    }\n  });\n});\n\napp.on('window-all-closed', () => {\n  if (process.platform !== 'darwin') {\n    app.quit();\n  }\n});\n"],"names":["getStorePath","path","execFileAsync","fs"],"mappings":"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"}